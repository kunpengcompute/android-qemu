// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module VkDecoder
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "VkDecoder.h"


#include "common/goldfish_vk_marshaling.h"
#include "common/goldfish_vk_private_defs.h"
#include "common/goldfish_vk_transform.h"

#include "android/base/Pool.h"
#include "android/base/system/System.h"

#include "IOStream.h"
#include "emugl/common/logging.h"

#include "VkDecoderGlobalState.h"
#include "VkDecoderSnapshot.h"

#include "VulkanDispatch.h"
#include "VulkanStream.h"

#include <unordered_map>
#include <stdio.h>

extern "C" {

using VmiGetClientHandleFn = uint32_t (*)(uint32_t hostHandle);
VmiGetClientHandleFn g_vmiGetClientHandle = nullptr;

uint32_t GetClientHandle(uint32_t hostHandle)
{
    if (g_vmiGetClientHandle) {
        return g_vmiGetClientHandle(hostHandle);
    }
    return 0;
}

void* GetVkDecoder(uint32_t pid, uint32_t tid, VmiWriteFullyFn vmiWriteFully, VmiGetClientHandleFn vmiGetClientHandle)
{
    if (!g_vmiGetClientHandle) {
        g_vmiGetClientHandle = vmiGetClientHandle;
    }

    VkIOStream* vkIOStream = new VkIOStream(pid, tid, vmiWriteFully);
    return new VkDecoder(vkIOStream);
}

void RunVkDecoder(void* vkDecoder, void* buf, size_t bufsize)
{
    VkDecoder* decoder = (VkDecoder*)vkDecoder;
    decoder->decode(buf, bufsize, nullptr);
}
}

using emugl::vkDispatch;

using namespace goldfish_vk;

using android::base::System;

static void DumpOpcode(unsigned char* ptr)
{
    uint32_t opcode = *(uint32_t *)ptr;
    int32_t packetLen = *(int32_t *)(ptr + 4);

    char data[1024];
    unsigned char* ch = ptr + 8;
    int32_t pos = 0;
    int32_t dataLen = packetLen - 8 < 256 ? packetLen - 8 : 256;
    while (dataLen--) {
        pos += snprintf(data + pos, 1024 - pos, "%x ", *ch);
        ch++;
    }
    data[pos] = '\0';

    INFO("DumpOpcode:%s, len:%d, data:%s", api_opcode_to_string(opcode), packetLen, "Not show");
}

class VkDecoder::Impl {
public:
    Impl() : m_logCalls(true), m_vk(vkDispatch()), m_state(VkDecoderGlobalState::get()) { }
    VulkanStream* stream() { return &m_vkStream; }
    VulkanMemReadingStream* readStream() { return &m_vkMemReadingStream; }

    void setForSnapshotLoad(bool forSnapshotLoad) {
        m_forSnapshotLoad = forSnapshotLoad;
    }

    size_t decode(void* buf, size_t bufsize, IOStream* stream);

private:
    bool m_logCalls;
    bool m_forSnapshotLoad = false;
    VulkanDispatch* m_vk;
    VkDecoderGlobalState* m_state;
    VulkanStream m_vkStream { nullptr };
    VulkanMemReadingStream m_vkMemReadingStream { nullptr };
    BoxedHandleUnwrapMapping m_boxedHandleUnwrapMapping;
    BoxedHandleCreateMapping m_boxedHandleCreateMapping;
    BoxedHandleDestroyMapping m_boxedHandleDestroyMapping;
    BoxedHandleUnwrapAndDeleteMapping m_boxedHandleUnwrapAndDeleteMapping;
    android::base::Pool m_pool { 8, 4096, 64 };
    BoxedHandleUnwrapAndDeletePreserveBoxedMapping m_boxedHandleUnwrapAndDeletePreserveBoxedMapping;
};

VkDecoder::VkDecoder() :
    mImpl(new VkDecoder::Impl()), m_ioStream(nullptr) { }

VkDecoder::VkDecoder(VkIOStream* ioStream) :
    mImpl(new VkDecoder::Impl()), m_ioStream(ioStream) { }

VkDecoder::~VkDecoder() = default;

void VkDecoder::setForSnapshotLoad(bool forSnapshotLoad) {
    mImpl->setForSnapshotLoad(forSnapshotLoad);
}

size_t VkDecoder::decode(void* buf, size_t bufsize, IOStream* ioStream) {
    if (ioStream) {
        return mImpl->decode(buf, bufsize, ioStream);
    } else {
        return mImpl->decode(buf, bufsize, m_ioStream);
    }
}

// VkDecoder::Impl::decode to follow
size_t VkDecoder::Impl::decode(void* buf, size_t len, IOStream* ioStream)
{
    if (len < 8) return 0;;
    unsigned char *ptr = (unsigned char *)buf;
    const unsigned char* const end = (const unsigned char*)buf + len;
    if (m_forSnapshotLoad)
    {
        ptr += m_state->setCreatedHandlesForSnapshotLoad(ptr);
    }
    while (end - ptr >= 8)
    {
        uint32_t opcode = *(uint32_t *)ptr;
        int32_t packetLen = *(int32_t *)(ptr + 4);
        if (end - ptr < packetLen) return ptr - (unsigned char*)buf;
        stream()->setStream(ioStream);
        VulkanStream* vkStream = stream();
        VulkanMemReadingStream* vkReadStream = readStream();
        vkReadStream->setBuf((uint8_t*)(ptr + 8));
        uint8_t* snapshotTraceBegin = vkReadStream->beginTrace();
        vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
        auto vk = m_vk;

        DumpOpcode(ptr);

        switch (opcode)
        {
#ifdef VK_VERSION_1_0
            case OP_vkCreateInstance:
            {
                const VkInstanceCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkInstance* pInstance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkInstanceCreateInfo));
                unmarshal_VkInstanceCreateInfo(vkReadStream, (VkInstanceCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pInstance;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pInstance, sizeof(VkInstance));
                uint64_t cgen_var_1;
                vkReadStream->read((uint64_t*)&cgen_var_1, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_1, (VkInstance*)pInstance, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pInstance;
                if (pCreateInfo)
                {
                    transform_tohost_VkInstanceCreateInfo(m_state, (VkInstanceCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateInstance 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pInstance);
                }
                VkResult vkCreateInstance_VkResult_return = (VkResult)0;
                vkCreateInstance_VkResult_return = m_state->on_vkCreateInstance(&m_pool, pCreateInfo, pAllocator, pInstance);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_2;
                static_assert(8 == sizeof(VkInstance), "handle map overwrite requres VkInstance to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkInstance((VkInstance*)pInstance, 1);
                vkStream->write((VkInstance*)pInstance, 8 * 1);
                vkStream->write(&vkCreateInstance_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateInstance(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateInstance_VkResult_return, pCreateInfo, pAllocator, pInstance);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyInstance:
            {
                VkInstance instance;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_3;
                vkReadStream->read((uint64_t*)&cgen_var_3, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_3, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyInstance 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyInstance(&m_pool, instance, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyInstance(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkEnumeratePhysicalDevices:
            {
                VkInstance instance;
                uint32_t* pPhysicalDeviceCount;
                VkPhysicalDevice* pPhysicalDevices;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_5;
                vkReadStream->read((uint64_t*)&cgen_var_5, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_5, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPhysicalDeviceCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDeviceCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPhysicalDeviceCount;
                // Begin manual dispatchable handle unboxing for pPhysicalDevices;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPhysicalDevices = (VkPhysicalDevice*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDevices)
                {
                    vkReadStream->alloc((void**)&pPhysicalDevices, (*(pPhysicalDeviceCount)) * sizeof(VkPhysicalDevice));
                    if ((*(pPhysicalDeviceCount)))
                    {
                        uint64_t* cgen_var_8;
                        vkReadStream->alloc((void**)&cgen_var_8, (*(pPhysicalDeviceCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_8, (*(pPhysicalDeviceCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(cgen_var_8, (VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPhysicalDevices;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkEnumeratePhysicalDevices 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pPhysicalDeviceCount, (unsigned long long)pPhysicalDevices);
                }
                VkResult vkEnumeratePhysicalDevices_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDevices_VkResult_return = m_state->on_vkEnumeratePhysicalDevices(&m_pool, instance, pPhysicalDeviceCount, pPhysicalDevices);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_9 = (uint64_t)(uintptr_t)pPhysicalDeviceCount;
                vkStream->putBe64(cgen_var_9);
                if (pPhysicalDeviceCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_10 = (uint64_t)(uintptr_t)pPhysicalDevices;
                vkStream->putBe64(cgen_var_10);
                if (pPhysicalDevices)
                {
                    if ((*(pPhysicalDeviceCount)))
                    {
                        uint64_t* cgen_var_11;
                        vkStream->alloc((void**)&cgen_var_11, (*(pPhysicalDeviceCount)) * 8);
                        static_assert(8 == sizeof(VkPhysicalDevice), "handle map overwrite requres VkPhysicalDevice to be 8 bytes long");
                        vkStream->handleMapping()->mapHandles_VkPhysicalDevice((VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)));
                        vkStream->write((VkPhysicalDevice*)pPhysicalDevices, 8 * (*(pPhysicalDeviceCount)));
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDevices_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumeratePhysicalDevices(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumeratePhysicalDevices_VkResult_return, instance, pPhysicalDeviceCount, pPhysicalDevices);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceFeatures:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures* pFeatures;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_12;
                vkReadStream->read((uint64_t*)&cgen_var_12, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_12, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures));
                unmarshal_VkPhysicalDeviceFeatures(vkReadStream, (VkPhysicalDeviceFeatures*)(pFeatures));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFeatures;
                if (pFeatures)
                {
                    transform_tohost_VkPhysicalDeviceFeatures(m_state, (VkPhysicalDeviceFeatures*)(pFeatures));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceFeatures 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFeatures);
                }
                m_state->on_vkGetPhysicalDeviceFeatures(&m_pool, physicalDevice, pFeatures);
                vkStream->unsetHandleMapping();
                if (pFeatures)
                {
                    transform_fromhost_VkPhysicalDeviceFeatures(m_state, (VkPhysicalDeviceFeatures*)(pFeatures));
                }
                marshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(pFeatures));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFeatures(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFeatures);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties* pFormatProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_13;
                vkReadStream->read((uint64_t*)&cgen_var_13, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_13, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                // Begin manual dispatchable handle unboxing for pFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties));
                unmarshal_VkFormatProperties(vkReadStream, (VkFormatProperties*)(pFormatProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFormatProperties;
                if (pFormatProperties)
                {
                    transform_tohost_VkFormatProperties(m_state, (VkFormatProperties*)(pFormatProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceFormatProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)pFormatProperties);
                }
                m_state->on_vkGetPhysicalDeviceFormatProperties(&m_pool, physicalDevice, format, pFormatProperties);
                vkStream->unsetHandleMapping();
                if (pFormatProperties)
                {
                    transform_fromhost_VkFormatProperties(m_state, (VkFormatProperties*)(pFormatProperties));
                }
                marshal_VkFormatProperties(vkStream, (VkFormatProperties*)(pFormatProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFormatProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format, pFormatProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkImageTiling tiling;
                VkImageUsageFlags usage;
                VkImageCreateFlags flags;
                VkImageFormatProperties* pImageFormatProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_14;
                vkReadStream->read((uint64_t*)&cgen_var_14, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_14, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->read((VkImageType*)&type, sizeof(VkImageType));
                vkReadStream->read((VkImageTiling*)&tiling, sizeof(VkImageTiling));
                vkReadStream->read((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
                vkReadStream->read((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
                // Begin manual dispatchable handle unboxing for pImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties));
                unmarshal_VkImageFormatProperties(vkReadStream, (VkImageFormatProperties*)(pImageFormatProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pImageFormatProperties;
                if (pImageFormatProperties)
                {
                    transform_tohost_VkImageFormatProperties(m_state, (VkImageFormatProperties*)(pImageFormatProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceImageFormatProperties 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)type, (unsigned long long)tiling, (unsigned long long)usage, (unsigned long long)flags, (unsigned long long)pImageFormatProperties);
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties_VkResult_return = m_state->on_vkGetPhysicalDeviceImageFormatProperties(&m_pool, physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pImageFormatProperties)
                {
                    transform_fromhost_VkImageFormatProperties(m_state, (VkImageFormatProperties*)(pImageFormatProperties));
                }
                marshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceImageFormatProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceImageFormatProperties_VkResult_return, physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_15;
                vkReadStream->read((uint64_t*)&cgen_var_15, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_15, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties));
                unmarshal_VkPhysicalDeviceProperties(vkReadStream, (VkPhysicalDeviceProperties*)(pProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    transform_tohost_VkPhysicalDeviceProperties(m_state, (VkPhysicalDeviceProperties*)(pProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceProperties 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pProperties);
                }
                m_state->on_vkGetPhysicalDeviceProperties(&m_pool, physicalDevice, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkPhysicalDeviceProperties(m_state, (VkPhysicalDeviceProperties*)(pProperties));
                }
                marshal_VkPhysicalDeviceProperties(vkStream, (VkPhysicalDeviceProperties*)(pProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties* pQueueFamilyProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_16;
                vkReadStream->read((uint64_t*)&cgen_var_16, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_16, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                // Begin manual dispatchable handle unboxing for pQueueFamilyProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pQueueFamilyProperties = (VkQueueFamilyProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        unmarshal_VkQueueFamilyProperties(vkReadStream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueueFamilyProperties;
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_tohost_VkQueueFamilyProperties(m_state, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceQueueFamilyProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pQueueFamilyPropertyCount, (unsigned long long)pQueueFamilyProperties);
                }
                vk->vkGetPhysicalDeviceQueueFamilyProperties(unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_19 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
                vkStream->putBe64(cgen_var_19);
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_fromhost_VkQueueFamilyProperties(m_state, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_20 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
                vkStream->putBe64(cgen_var_20);
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        marshal_VkQueueFamilyProperties(vkStream, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
                    }
                }
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties* pMemoryProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_21;
                vkReadStream->read((uint64_t*)&cgen_var_21, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_21, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pMemoryProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties));
                unmarshal_VkPhysicalDeviceMemoryProperties(vkReadStream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryProperties;
                if (pMemoryProperties)
                {
                    transform_tohost_VkPhysicalDeviceMemoryProperties(m_state, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceMemoryProperties 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pMemoryProperties);
                }
                m_state->on_vkGetPhysicalDeviceMemoryProperties(&m_pool, physicalDevice, pMemoryProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryProperties)
                {
                    transform_fromhost_VkPhysicalDeviceMemoryProperties(m_state, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                }
                marshal_VkPhysicalDeviceMemoryProperties(vkStream, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceMemoryProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pMemoryProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetInstanceProcAddr:
            {
                VkInstance instance;
                const char* pName;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_22;
                vkReadStream->read((uint64_t*)&cgen_var_22, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_22, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->loadStringInPlace((char**)&pName);
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetInstanceProcAddr 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pName);
                }
                PFN_vkVoidFunction vkGetInstanceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
                vkGetInstanceProcAddr_PFN_vkVoidFunction_return = vk->vkGetInstanceProcAddr(unboxed_instance, pName);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetInstanceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetInstanceProcAddr(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetInstanceProcAddr_PFN_vkVoidFunction_return, instance, pName);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetDeviceProcAddr:
            {
                VkDevice device;
                const char* pName;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_23;
                vkReadStream->read((uint64_t*)&cgen_var_23, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_23, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->loadStringInPlace((char**)&pName);
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetDeviceProcAddr 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pName);
                }
                PFN_vkVoidFunction vkGetDeviceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
                vkGetDeviceProcAddr_PFN_vkVoidFunction_return = vk->vkGetDeviceProcAddr(unboxed_device, pName);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetDeviceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceProcAddr(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDeviceProcAddr_PFN_vkVoidFunction_return, device, pName);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateDevice:
            {
                VkPhysicalDevice physicalDevice;
                const VkDeviceCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDevice* pDevice;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_24;
                vkReadStream->read((uint64_t*)&cgen_var_24, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_24, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDeviceCreateInfo));
                unmarshal_VkDeviceCreateInfo(vkReadStream, (VkDeviceCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pDevice;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDevice, sizeof(VkDevice));
                uint64_t cgen_var_26;
                vkReadStream->read((uint64_t*)&cgen_var_26, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_26, (VkDevice*)pDevice, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDevice;
                if (pCreateInfo)
                {
                    transform_tohost_VkDeviceCreateInfo(m_state, (VkDeviceCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateDevice 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pDevice);
                }
                VkResult vkCreateDevice_VkResult_return = (VkResult)0;
                vkCreateDevice_VkResult_return = m_state->on_vkCreateDevice(&m_pool, physicalDevice, pCreateInfo, pAllocator, pDevice);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_27;
                static_assert(8 == sizeof(VkDevice), "handle map overwrite requres VkDevice to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDevice((VkDevice*)pDevice, 1);
                vkStream->write((VkDevice*)pDevice, 8 * 1);
                vkStream->write(&vkCreateDevice_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDevice(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDevice_VkResult_return, physicalDevice, pCreateInfo, pAllocator, pDevice);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyDevice:
            {
                VkDevice device;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_28;
                vkReadStream->read((uint64_t*)&cgen_var_28, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_28, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyDevice 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyDevice(&m_pool, device, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDevice(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkEnumerateInstanceExtensionProperties:
            {
                const char* pLayerName;
                uint32_t* pPropertyCount;
                VkExtensionProperties* pProperties;
                if (vkReadStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
                {
                    // WARNING PTR CHECK
                    pLayerName = (const char*)(uintptr_t)vkReadStream->getBe64();
                    if (pLayerName)
                    {
                        vkReadStream->loadStringInPlace((char**)&pLayerName);
                    }
                }
                else
                {
                    vkReadStream->loadStringInPlace((char**)&pLayerName);
                }
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkExtensionProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkExtensionProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkExtensionProperties(vkReadStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkEnumerateInstanceExtensionProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)pLayerName, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkEnumerateInstanceExtensionProperties_VkResult_return = (VkResult)0;
                vkEnumerateInstanceExtensionProperties_VkResult_return = vk->vkEnumerateInstanceExtensionProperties(pLayerName, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_33 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_33);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_34 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_34);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkExtensionProperties(vkStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateInstanceExtensionProperties_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumerateInstanceExtensionProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumerateInstanceExtensionProperties_VkResult_return, pLayerName, pPropertyCount, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkEnumerateDeviceExtensionProperties:
            {
                VkPhysicalDevice physicalDevice;
                const char* pLayerName;
                uint32_t* pPropertyCount;
                VkExtensionProperties* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_35;
                vkReadStream->read((uint64_t*)&cgen_var_35, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_35, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                if (vkReadStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
                {
                    // WARNING PTR CHECK
                    pLayerName = (const char*)(uintptr_t)vkReadStream->getBe64();
                    if (pLayerName)
                    {
                        vkReadStream->loadStringInPlace((char**)&pLayerName);
                    }
                }
                else
                {
                    vkReadStream->loadStringInPlace((char**)&pLayerName);
                }
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkExtensionProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkExtensionProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkExtensionProperties(vkReadStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkEnumerateDeviceExtensionProperties 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pLayerName, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkEnumerateDeviceExtensionProperties_VkResult_return = (VkResult)0;
                vkEnumerateDeviceExtensionProperties_VkResult_return = vk->vkEnumerateDeviceExtensionProperties(unboxed_physicalDevice, pLayerName, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_39 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_39);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkExtensionProperties(m_state, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_40 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_40);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkExtensionProperties(vkStream, (VkExtensionProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateDeviceExtensionProperties_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumerateDeviceExtensionProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumerateDeviceExtensionProperties_VkResult_return, physicalDevice, pLayerName, pPropertyCount, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkEnumerateInstanceLayerProperties:
            {
                uint32_t* pPropertyCount;
                VkLayerProperties* pProperties;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkLayerProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkLayerProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkLayerProperties(vkReadStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkEnumerateInstanceLayerProperties 0x%llx 0x%llx \n", ioStream, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkEnumerateInstanceLayerProperties_VkResult_return = (VkResult)0;
                vkEnumerateInstanceLayerProperties_VkResult_return = vk->vkEnumerateInstanceLayerProperties(pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_43 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_43);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_44 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_44);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkLayerProperties(vkStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateInstanceLayerProperties_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumerateInstanceLayerProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumerateInstanceLayerProperties_VkResult_return, pPropertyCount, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkEnumerateDeviceLayerProperties:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkLayerProperties* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_45;
                vkReadStream->read((uint64_t*)&cgen_var_45, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_45, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkLayerProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkLayerProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkLayerProperties(vkReadStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkEnumerateDeviceLayerProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkEnumerateDeviceLayerProperties_VkResult_return = (VkResult)0;
                vkEnumerateDeviceLayerProperties_VkResult_return = vk->vkEnumerateDeviceLayerProperties(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_48 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_48);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkLayerProperties(m_state, (VkLayerProperties*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_49 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_49);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkLayerProperties(vkStream, (VkLayerProperties*)(pProperties + i));
                    }
                }
                vkStream->write(&vkEnumerateDeviceLayerProperties_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumerateDeviceLayerProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumerateDeviceLayerProperties_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetDeviceQueue:
            {
                VkDevice device;
                uint32_t queueFamilyIndex;
                uint32_t queueIndex;
                VkQueue* pQueue;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_50;
                vkReadStream->read((uint64_t*)&cgen_var_50, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_50, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queueIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for pQueue;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pQueue, sizeof(VkQueue));
                uint64_t cgen_var_51;
                vkReadStream->read((uint64_t*)&cgen_var_51, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_51, (VkQueue*)pQueue, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueue;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetDeviceQueue 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)queueFamilyIndex, (unsigned long long)queueIndex, (unsigned long long)pQueue);
                }
                m_state->on_vkGetDeviceQueue(&m_pool, device, queueFamilyIndex, queueIndex, pQueue);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_52;
                static_assert(8 == sizeof(VkQueue), "handle map overwrite requres VkQueue to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkQueue((VkQueue*)pQueue, 1);
                vkStream->write((VkQueue*)pQueue, 8 * 1);
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceQueue(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, queueFamilyIndex, queueIndex, pQueue);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkQueueSubmit:
            {
                VkQueue queue;
                uint32_t submitCount;
                const VkSubmitInfo* pSubmits;
                VkFence fence;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_53;
                vkReadStream->read((uint64_t*)&cgen_var_53, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_53, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->read((uint32_t*)&submitCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSubmits, ((submitCount)) * sizeof(const VkSubmitInfo));
                for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
                {
                    unmarshal_VkSubmitInfo(vkReadStream, (VkSubmitInfo*)(pSubmits + i));
                }
                uint64_t cgen_var_54;
                vkReadStream->read((uint64_t*)&cgen_var_54, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_54, (VkFence*)&fence, 1);
                if (pSubmits)
                {
                    for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
                    {
                        transform_tohost_VkSubmitInfo(m_state, (VkSubmitInfo*)(pSubmits + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkQueueSubmit 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)submitCount, (unsigned long long)pSubmits, (unsigned long long)fence);
                }
                VkResult vkQueueSubmit_VkResult_return = (VkResult)0;
                vkQueueSubmit_VkResult_return = m_state->on_vkQueueSubmit(&m_pool, queue, submitCount, pSubmits, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueueSubmit_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueSubmit(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueueSubmit_VkResult_return, queue, submitCount, pSubmits, fence);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkQueueWaitIdle:
            {
                VkQueue queue;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_55;
                vkReadStream->read((uint64_t*)&cgen_var_55, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_55, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkQueueWaitIdle 0x%llx \n", ioStream, (unsigned long long)queue);
                }
                VkResult vkQueueWaitIdle_VkResult_return = (VkResult)0;
                vkQueueWaitIdle_VkResult_return = m_state->on_vkQueueWaitIdle(&m_pool, queue);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueueWaitIdle_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueWaitIdle(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueueWaitIdle_VkResult_return, queue);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDeviceWaitIdle:
            {
                VkDevice device;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_56;
                vkReadStream->read((uint64_t*)&cgen_var_56, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_56, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDeviceWaitIdle 0x%llx \n", ioStream, (unsigned long long)device);
                }
                VkResult vkDeviceWaitIdle_VkResult_return = (VkResult)0;
                vkDeviceWaitIdle_VkResult_return = vk->vkDeviceWaitIdle(unboxed_device);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDeviceWaitIdle_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDeviceWaitIdle(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkDeviceWaitIdle_VkResult_return, device);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkAllocateMemory:
            {
                VkDevice device;
                const VkMemoryAllocateInfo* pAllocateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDeviceMemory* pMemory;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_57;
                vkReadStream->read((uint64_t*)&cgen_var_57, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_57, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkMemoryAllocateInfo));
                unmarshal_VkMemoryAllocateInfo(vkReadStream, (VkMemoryAllocateInfo*)(pAllocateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pMemory;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemory, sizeof(VkDeviceMemory));
                uint64_t cgen_var_59;
                vkReadStream->read((uint64_t*)&cgen_var_59, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_59, (VkDeviceMemory*)pMemory, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemory;
                if (pAllocateInfo)
                {
                    transform_tohost_VkMemoryAllocateInfo(m_state, (VkMemoryAllocateInfo*)(pAllocateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkAllocateMemory 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAllocateInfo, (unsigned long long)pAllocator, (unsigned long long)pMemory);
                }
                VkResult vkAllocateMemory_VkResult_return = (VkResult)0;
                vkAllocateMemory_VkResult_return = m_state->on_vkAllocateMemory(&m_pool, device, pAllocateInfo, pAllocator, pMemory);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pMemory;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_60;
                static_assert(8 == sizeof(VkDeviceMemory), "handle map overwrite requres VkDeviceMemory to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDeviceMemory((VkDeviceMemory*)pMemory, 1);
                vkStream->write((VkDeviceMemory*)pMemory, 8 * 1);
                // Begin manual non dispatchable handle create for pMemory;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkAllocateMemory_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAllocateMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAllocateMemory_VkResult_return, device, pAllocateInfo, pAllocator, pMemory);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkFreeMemory:
            {
                VkDevice device;
                VkDeviceMemory memory;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_61;
                vkReadStream->read((uint64_t*)&cgen_var_61, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_61, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for memory;
                VkDeviceMemory* boxed_memory_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_memory_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_62;
                vkReadStream->read((uint64_t*)&cgen_var_62, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_62, (VkDeviceMemory*)&memory, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for memory;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkFreeMemory 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)pAllocator);
                }
                m_state->on_vkFreeMemory(&m_pool, device, memory, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkFreeMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_memory_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkMapMemory:
            {
                VkDevice device;
                VkDeviceMemory memory;
                VkDeviceSize offset;
                VkDeviceSize size;
                VkMemoryMapFlags flags;
                void** ppData;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_64;
                vkReadStream->read((uint64_t*)&cgen_var_64, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_64, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_65;
                vkReadStream->read((uint64_t*)&cgen_var_65, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_65, (VkDeviceMemory*)&memory, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&size, sizeof(VkDeviceSize));
                vkReadStream->read((VkMemoryMapFlags*)&flags, sizeof(VkMemoryMapFlags));
                // Begin manual dispatchable handle unboxing for ppData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                ppData = (void**)(uintptr_t)vkReadStream->getBe64();
                if (ppData)
                {
                    vkReadStream->alloc((void**)&ppData, sizeof(void*));
                    vkReadStream->read((void**)ppData, sizeof(void*));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for ppData;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkMapMemory 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)offset, (unsigned long long)size, (unsigned long long)flags, (unsigned long long)ppData);
                }
                VkResult vkMapMemory_VkResult_return = (VkResult)0;
                vkMapMemory_VkResult_return = m_state->on_vkMapMemory(&m_pool, device, memory, offset, size, flags, ppData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_67 = (uint64_t)(uintptr_t)ppData;
                vkStream->putBe64(cgen_var_67);
                if (ppData)
                {
                    vkStream->write((void**)ppData, sizeof(void*));
                }
                vkStream->write(&vkMapMemory_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkMapMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkMapMemory_VkResult_return, device, memory, offset, size, flags, ppData);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkUnmapMemory:
            {
                VkDevice device;
                VkDeviceMemory memory;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_68;
                vkReadStream->read((uint64_t*)&cgen_var_68, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_68, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_69;
                vkReadStream->read((uint64_t*)&cgen_var_69, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_69, (VkDeviceMemory*)&memory, 1);
                if (m_logCalls)
                {
                    INFO("stream %p: call vkUnmapMemory 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory);
                }
                m_state->on_vkUnmapMemory(&m_pool, device, memory);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUnmapMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, memory);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkFlushMappedMemoryRanges:
            {
                VkDevice device;
                uint32_t memoryRangeCount;
                const VkMappedMemoryRange* pMemoryRanges;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_70;
                vkReadStream->read((uint64_t*)&cgen_var_70, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_70, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryRanges, ((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
                for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                {
                    unmarshal_VkMappedMemoryRange(vkReadStream, (VkMappedMemoryRange*)(pMemoryRanges + i));
                }
                if (pMemoryRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                    {
                        transform_tohost_VkMappedMemoryRange(m_state, (VkMappedMemoryRange*)(pMemoryRanges + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkFlushMappedMemoryRanges 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memoryRangeCount, (unsigned long long)pMemoryRanges);
                }
                if (!m_state->usingDirectMapping())
                {
                    for (uint32_t i = 0; i < memoryRangeCount; ++i)
                    {
                        auto range = pMemoryRanges[i];
                        auto memory = pMemoryRanges[i].memory;
                        auto size = pMemoryRanges[i].size;
                        auto offset = pMemoryRanges[i].offset;
                        uint64_t readStream = 0;
                        vkReadStream->read(&readStream, sizeof(uint64_t));
                        auto hostPtr = m_state->getMappedHostPointer(memory);
                        if (!hostPtr && readStream > 0) abort();
                        if (!hostPtr) continue;
                        uint8_t* targetRange = hostPtr + offset;
                        vkReadStream->read(targetRange, readStream);
                    }
                }
                VkResult vkFlushMappedMemoryRanges_VkResult_return = (VkResult)0;
                vkFlushMappedMemoryRanges_VkResult_return = vk->vkFlushMappedMemoryRanges(unboxed_device, memoryRangeCount, pMemoryRanges);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkFlushMappedMemoryRanges_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkFlushMappedMemoryRanges(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkFlushMappedMemoryRanges_VkResult_return, device, memoryRangeCount, pMemoryRanges);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkInvalidateMappedMemoryRanges:
            {
                VkDevice device;
                uint32_t memoryRangeCount;
                const VkMappedMemoryRange* pMemoryRanges;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_71;
                vkReadStream->read((uint64_t*)&cgen_var_71, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_71, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&memoryRangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryRanges, ((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
                for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                {
                    unmarshal_VkMappedMemoryRange(vkReadStream, (VkMappedMemoryRange*)(pMemoryRanges + i));
                }
                if (pMemoryRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
                    {
                        transform_tohost_VkMappedMemoryRange(m_state, (VkMappedMemoryRange*)(pMemoryRanges + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkInvalidateMappedMemoryRanges 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memoryRangeCount, (unsigned long long)pMemoryRanges);
                }
                VkResult vkInvalidateMappedMemoryRanges_VkResult_return = (VkResult)0;
                vkInvalidateMappedMemoryRanges_VkResult_return = vk->vkInvalidateMappedMemoryRanges(unboxed_device, memoryRangeCount, pMemoryRanges);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkInvalidateMappedMemoryRanges_VkResult_return, sizeof(VkResult));
                if (!m_state->usingDirectMapping())
                {
                    for (uint32_t i = 0; i < memoryRangeCount; ++i)
                    {
                        auto range = pMemoryRanges[i];
                        auto memory = range.memory;
                        auto size = range.size;
                        auto offset = range.offset;
                        auto hostPtr = m_state->getMappedHostPointer(memory);
                        auto actualSize = size == VK_WHOLE_SIZE ? m_state->getDeviceMemorySize(memory) : size;
                        uint64_t writeStream = 0;
                        if (!hostPtr) { vkStream->write(&writeStream, sizeof(uint64_t)); continue; };
                        uint8_t* targetRange = hostPtr + offset;
                        writeStream = actualSize;
                        vkStream->write(&writeStream, sizeof(uint64_t));
                        vkStream->write(targetRange, actualSize);
                    }
                }
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkInvalidateMappedMemoryRanges(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkInvalidateMappedMemoryRanges_VkResult_return, device, memoryRangeCount, pMemoryRanges);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetDeviceMemoryCommitment:
            {
                VkDevice device;
                VkDeviceMemory memory;
                VkDeviceSize* pCommittedMemoryInBytes;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_72;
                vkReadStream->read((uint64_t*)&cgen_var_72, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_72, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_73;
                vkReadStream->read((uint64_t*)&cgen_var_73, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_73, (VkDeviceMemory*)&memory, 1);
                // Begin manual dispatchable handle unboxing for pCommittedMemoryInBytes;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCommittedMemoryInBytes;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetDeviceMemoryCommitment 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)pCommittedMemoryInBytes);
                }
                vk->vkGetDeviceMemoryCommitment(unboxed_device, memory, pCommittedMemoryInBytes);
                vkStream->unsetHandleMapping();
                vkStream->write((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceMemoryCommitment(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, memory, pCommittedMemoryInBytes);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkBindBufferMemory:
            {
                VkDevice device;
                VkBuffer buffer;
                VkDeviceMemory memory;
                VkDeviceSize memoryOffset;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_74;
                vkReadStream->read((uint64_t*)&cgen_var_74, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_74, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_75;
                vkReadStream->read((uint64_t*)&cgen_var_75, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_75, (VkBuffer*)&buffer, 1);
                uint64_t cgen_var_76;
                vkReadStream->read((uint64_t*)&cgen_var_76, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_76, (VkDeviceMemory*)&memory, 1);
                vkReadStream->read((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkBindBufferMemory 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buffer, (unsigned long long)memory, (unsigned long long)memoryOffset);
                }
                VkResult vkBindBufferMemory_VkResult_return = (VkResult)0;
                vkBindBufferMemory_VkResult_return = m_state->on_vkBindBufferMemory(&m_pool, device, buffer, memory, memoryOffset);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindBufferMemory_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindBufferMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindBufferMemory_VkResult_return, device, buffer, memory, memoryOffset);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkBindImageMemory:
            {
                VkDevice device;
                VkImage image;
                VkDeviceMemory memory;
                VkDeviceSize memoryOffset;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_77;
                vkReadStream->read((uint64_t*)&cgen_var_77, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_77, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_78;
                vkReadStream->read((uint64_t*)&cgen_var_78, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_78, (VkImage*)&image, 1);
                uint64_t cgen_var_79;
                vkReadStream->read((uint64_t*)&cgen_var_79, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_79, (VkDeviceMemory*)&memory, 1);
                vkReadStream->read((VkDeviceSize*)&memoryOffset, sizeof(VkDeviceSize));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkBindImageMemory 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)memory, (unsigned long long)memoryOffset);
                }
                VkResult vkBindImageMemory_VkResult_return = (VkResult)0;
                vkBindImageMemory_VkResult_return = m_state->on_vkBindImageMemory(&m_pool, device, image, memory, memoryOffset);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindImageMemory_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindImageMemory(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindImageMemory_VkResult_return, device, image, memory, memoryOffset);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetBufferMemoryRequirements:
            {
                VkDevice device;
                VkBuffer buffer;
                VkMemoryRequirements* pMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_80;
                vkReadStream->read((uint64_t*)&cgen_var_80, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_80, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_81;
                vkReadStream->read((uint64_t*)&cgen_var_81, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_81, (VkBuffer*)&buffer, 1);
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                unmarshal_VkMemoryRequirements(vkReadStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryRequirements;
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetBufferMemoryRequirements 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buffer, (unsigned long long)pMemoryRequirements);
                }
                vk->vkGetBufferMemoryRequirements(unboxed_device, buffer, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetBufferMemoryRequirements(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, buffer, pMemoryRequirements);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetImageMemoryRequirements:
            {
                VkDevice device;
                VkImage image;
                VkMemoryRequirements* pMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_82;
                vkReadStream->read((uint64_t*)&cgen_var_82, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_82, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_83;
                vkReadStream->read((uint64_t*)&cgen_var_83, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_83, (VkImage*)&image, 1);
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                unmarshal_VkMemoryRequirements(vkReadStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryRequirements;
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetImageMemoryRequirements 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)pMemoryRequirements);
                }
                m_state->on_vkGetImageMemoryRequirements(&m_pool, device, image, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageMemoryRequirements(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, image, pMemoryRequirements);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements:
            {
                VkDevice device;
                VkImage image;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements* pSparseMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_84;
                vkReadStream->read((uint64_t*)&cgen_var_84, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_84, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_85;
                vkReadStream->read((uint64_t*)&cgen_var_85, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_85, (VkImage*)&image, 1);
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSparseMemoryRequirements = (VkSparseImageMemoryRequirements*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        unmarshal_VkSparseImageMemoryRequirements(vkReadStream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSparseMemoryRequirements;
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_tohost_VkSparseImageMemoryRequirements(m_state, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetImageSparseMemoryRequirements 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)pSparseMemoryRequirementCount, (unsigned long long)pSparseMemoryRequirements);
                }
                vk->vkGetImageSparseMemoryRequirements(unboxed_device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_88 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
                vkStream->putBe64(cgen_var_88);
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageMemoryRequirements(m_state, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_89 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
                vkStream->putBe64(cgen_var_89);
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        marshal_VkSparseImageMemoryRequirements(vkStream, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
                    }
                }
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageSparseMemoryRequirements(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkSampleCountFlagBits samples;
                VkImageUsageFlags usage;
                VkImageTiling tiling;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_90;
                vkReadStream->read((uint64_t*)&cgen_var_90, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_90, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->read((VkImageType*)&type, sizeof(VkImageType));
                vkReadStream->read((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
                vkReadStream->read((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
                vkReadStream->read((VkImageTiling*)&tiling, sizeof(VkImageTiling));
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkSparseImageFormatProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkSparseImageFormatProperties(vkReadStream, (VkSparseImageFormatProperties*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkSparseImageFormatProperties(m_state, (VkSparseImageFormatProperties*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceSparseImageFormatProperties 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)type, (unsigned long long)samples, (unsigned long long)usage, (unsigned long long)tiling, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                vk->vkGetPhysicalDeviceSparseImageFormatProperties(unboxed_physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_93 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_93);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageFormatProperties(m_state, (VkSparseImageFormatProperties*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_94 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_94);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(pProperties + i));
                    }
                }
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSparseImageFormatProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkQueueBindSparse:
            {
                VkQueue queue;
                uint32_t bindInfoCount;
                const VkBindSparseInfo* pBindInfo;
                VkFence fence;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_95;
                vkReadStream->read((uint64_t*)&cgen_var_95, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_95, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfo, ((bindInfoCount)) * sizeof(const VkBindSparseInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindSparseInfo(vkReadStream, (VkBindSparseInfo*)(pBindInfo + i));
                }
                uint64_t cgen_var_96;
                vkReadStream->read((uint64_t*)&cgen_var_96, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_96, (VkFence*)&fence, 1);
                if (pBindInfo)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindSparseInfo(m_state, (VkBindSparseInfo*)(pBindInfo + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkQueueBindSparse 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfo, (unsigned long long)fence);
                }
                VkResult vkQueueBindSparse_VkResult_return = (VkResult)0;
                vkQueueBindSparse_VkResult_return = vk->vkQueueBindSparse(unboxed_queue, bindInfoCount, pBindInfo, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueueBindSparse_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueBindSparse(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueueBindSparse_VkResult_return, queue, bindInfoCount, pBindInfo, fence);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateFence:
            {
                VkDevice device;
                const VkFenceCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_97;
                vkReadStream->read((uint64_t*)&cgen_var_97, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_97, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkFenceCreateInfo));
                unmarshal_VkFenceCreateInfo(vkReadStream, (VkFenceCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pFence;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                uint64_t cgen_var_99;
                vkReadStream->read((uint64_t*)&cgen_var_99, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_99, (VkFence*)pFence, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFence;
                if (pCreateInfo)
                {
                    transform_tohost_VkFenceCreateInfo(m_state, (VkFenceCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateFence 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pFence);
                }
                VkResult vkCreateFence_VkResult_return = (VkResult)0;
                vkCreateFence_VkResult_return = vk->vkCreateFence(unboxed_device, pCreateInfo, pAllocator, pFence);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pFence;
                if (vkCreateFence_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_100;
                static_assert(8 == sizeof(VkFence), "handle map overwrite requres VkFence to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkFence((VkFence*)pFence, 1);
                vkStream->write((VkFence*)pFence, 8 * 1);
                // Begin auto non dispatchable handle create for pFence;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateFence_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateFence(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateFence_VkResult_return, device, pCreateInfo, pAllocator, pFence);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyFence:
            {
                VkDevice device;
                VkFence fence;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_101;
                vkReadStream->read((uint64_t*)&cgen_var_101, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_101, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for fence;
                VkFence* boxed_fence_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_fence_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_102;
                vkReadStream->read((uint64_t*)&cgen_var_102, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_102, (VkFence*)&fence, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for fence;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyFence 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)fence, (unsigned long long)pAllocator);
                }
                vk->vkDestroyFence(unboxed_device, fence, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyFence(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_fence_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkResetFences:
            {
                VkDevice device;
                uint32_t fenceCount;
                const VkFence* pFences;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_104;
                vkReadStream->read((uint64_t*)&cgen_var_104, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_104, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&fenceCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
                if (((fenceCount)))
                {
                    uint64_t* cgen_var_105;
                    vkReadStream->alloc((void**)&cgen_var_105, ((fenceCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_105, ((fenceCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkFence(cgen_var_105, (VkFence*)pFences, ((fenceCount)));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkResetFences 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)fenceCount, (unsigned long long)pFences);
                }
                VkResult vkResetFences_VkResult_return = (VkResult)0;
                vkResetFences_VkResult_return = vk->vkResetFences(unboxed_device, fenceCount, pFences);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetFences_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetFences(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkResetFences_VkResult_return, device, fenceCount, pFences);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetFenceStatus:
            {
                VkDevice device;
                VkFence fence;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_106;
                vkReadStream->read((uint64_t*)&cgen_var_106, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_106, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_107;
                vkReadStream->read((uint64_t*)&cgen_var_107, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_107, (VkFence*)&fence, 1);
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetFenceStatus 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)fence);
                }
                VkResult vkGetFenceStatus_VkResult_return = (VkResult)0;
                vkGetFenceStatus_VkResult_return = vk->vkGetFenceStatus(unboxed_device, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetFenceStatus_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetFenceStatus(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetFenceStatus_VkResult_return, device, fence);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkWaitForFences:
            {
                VkDevice device;
                uint32_t fenceCount;
                const VkFence* pFences;
                VkBool32 waitAll;
                uint64_t timeout;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_108;
                vkReadStream->read((uint64_t*)&cgen_var_108, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_108, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&fenceCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pFences, ((fenceCount)) * sizeof(const VkFence));
                if (((fenceCount)))
                {
                    uint64_t* cgen_var_109;
                    vkReadStream->alloc((void**)&cgen_var_109, ((fenceCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_109, ((fenceCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkFence(cgen_var_109, (VkFence*)pFences, ((fenceCount)));
                }
                vkReadStream->read((VkBool32*)&waitAll, sizeof(VkBool32));
                vkReadStream->read((uint64_t*)&timeout, sizeof(uint64_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkWaitForFences 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)fenceCount, (unsigned long long)pFences, (unsigned long long)waitAll, (unsigned long long)timeout);
                }
                VkResult vkWaitForFences_VkResult_return = (VkResult)0;
                vkWaitForFences_VkResult_return = vk->vkWaitForFences(unboxed_device, fenceCount, pFences, waitAll, timeout);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkWaitForFences_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkWaitForFences(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkWaitForFences_VkResult_return, device, fenceCount, pFences, waitAll, timeout);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateSemaphore:
            {
                VkDevice device;
                const VkSemaphoreCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSemaphore* pSemaphore;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_110;
                vkReadStream->read((uint64_t*)&cgen_var_110, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_110, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSemaphoreCreateInfo));
                unmarshal_VkSemaphoreCreateInfo(vkReadStream, (VkSemaphoreCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSemaphore;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSemaphore, sizeof(VkSemaphore));
                uint64_t cgen_var_112;
                vkReadStream->read((uint64_t*)&cgen_var_112, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_112, (VkSemaphore*)pSemaphore, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSemaphore;
                if (pCreateInfo)
                {
                    transform_tohost_VkSemaphoreCreateInfo(m_state, (VkSemaphoreCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateSemaphore 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSemaphore);
                }
                VkResult vkCreateSemaphore_VkResult_return = (VkResult)0;
                vkCreateSemaphore_VkResult_return = m_state->on_vkCreateSemaphore(&m_pool, device, pCreateInfo, pAllocator, pSemaphore);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pSemaphore;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_113;
                static_assert(8 == sizeof(VkSemaphore), "handle map overwrite requres VkSemaphore to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkSemaphore((VkSemaphore*)pSemaphore, 1);
                vkStream->write((VkSemaphore*)pSemaphore, 8 * 1);
                // Begin manual non dispatchable handle create for pSemaphore;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSemaphore_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSemaphore(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSemaphore_VkResult_return, device, pCreateInfo, pAllocator, pSemaphore);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroySemaphore:
            {
                VkDevice device;
                VkSemaphore semaphore;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_114;
                vkReadStream->read((uint64_t*)&cgen_var_114, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_114, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for semaphore;
                VkSemaphore* boxed_semaphore_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_semaphore_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_115;
                vkReadStream->read((uint64_t*)&cgen_var_115, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_115, (VkSemaphore*)&semaphore, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for semaphore;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroySemaphore 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)semaphore, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroySemaphore(&m_pool, device, semaphore, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySemaphore(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_semaphore_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateEvent:
            {
                VkDevice device;
                const VkEventCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkEvent* pEvent;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_117;
                vkReadStream->read((uint64_t*)&cgen_var_117, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_117, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkEventCreateInfo));
                unmarshal_VkEventCreateInfo(vkReadStream, (VkEventCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pEvent;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pEvent, sizeof(VkEvent));
                uint64_t cgen_var_119;
                vkReadStream->read((uint64_t*)&cgen_var_119, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_119, (VkEvent*)pEvent, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pEvent;
                if (pCreateInfo)
                {
                    transform_tohost_VkEventCreateInfo(m_state, (VkEventCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateEvent 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pEvent);
                }
                VkResult vkCreateEvent_VkResult_return = (VkResult)0;
                vkCreateEvent_VkResult_return = vk->vkCreateEvent(unboxed_device, pCreateInfo, pAllocator, pEvent);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pEvent;
                if (vkCreateEvent_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_120;
                static_assert(8 == sizeof(VkEvent), "handle map overwrite requres VkEvent to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkEvent((VkEvent*)pEvent, 1);
                vkStream->write((VkEvent*)pEvent, 8 * 1);
                // Begin auto non dispatchable handle create for pEvent;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateEvent_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateEvent_VkResult_return, device, pCreateInfo, pAllocator, pEvent);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyEvent:
            {
                VkDevice device;
                VkEvent event;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_121;
                vkReadStream->read((uint64_t*)&cgen_var_121, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_121, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for event;
                VkEvent* boxed_event_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_event_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_122;
                vkReadStream->read((uint64_t*)&cgen_var_122, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_122, (VkEvent*)&event, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for event;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyEvent 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)event, (unsigned long long)pAllocator);
                }
                vk->vkDestroyEvent(unboxed_device, event, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_event_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetEventStatus:
            {
                VkDevice device;
                VkEvent event;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_124;
                vkReadStream->read((uint64_t*)&cgen_var_124, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_124, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_125;
                vkReadStream->read((uint64_t*)&cgen_var_125, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_125, (VkEvent*)&event, 1);
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetEventStatus 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)event);
                }
                VkResult vkGetEventStatus_VkResult_return = (VkResult)0;
                vkGetEventStatus_VkResult_return = vk->vkGetEventStatus(unboxed_device, event);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetEventStatus_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetEventStatus(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetEventStatus_VkResult_return, device, event);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkSetEvent:
            {
                VkDevice device;
                VkEvent event;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_126;
                vkReadStream->read((uint64_t*)&cgen_var_126, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_126, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_127;
                vkReadStream->read((uint64_t*)&cgen_var_127, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_127, (VkEvent*)&event, 1);
                if (m_logCalls)
                {
                    INFO("stream %p: call vkSetEvent 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)event);
                }
                VkResult vkSetEvent_VkResult_return = (VkResult)0;
                vkSetEvent_VkResult_return = vk->vkSetEvent(unboxed_device, event);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkSetEvent_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkSetEvent_VkResult_return, device, event);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkResetEvent:
            {
                VkDevice device;
                VkEvent event;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_128;
                vkReadStream->read((uint64_t*)&cgen_var_128, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_128, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_129;
                vkReadStream->read((uint64_t*)&cgen_var_129, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_129, (VkEvent*)&event, 1);
                if (m_logCalls)
                {
                    INFO("stream %p: call vkResetEvent 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)event);
                }
                VkResult vkResetEvent_VkResult_return = (VkResult)0;
                vkResetEvent_VkResult_return = vk->vkResetEvent(unboxed_device, event);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetEvent_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkResetEvent_VkResult_return, device, event);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateQueryPool:
            {
                VkDevice device;
                const VkQueryPoolCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkQueryPool* pQueryPool;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_130;
                vkReadStream->read((uint64_t*)&cgen_var_130, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_130, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkQueryPoolCreateInfo));
                unmarshal_VkQueryPoolCreateInfo(vkReadStream, (VkQueryPoolCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pQueryPool;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pQueryPool, sizeof(VkQueryPool));
                uint64_t cgen_var_132;
                vkReadStream->read((uint64_t*)&cgen_var_132, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_132, (VkQueryPool*)pQueryPool, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueryPool;
                if (pCreateInfo)
                {
                    transform_tohost_VkQueryPoolCreateInfo(m_state, (VkQueryPoolCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateQueryPool 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pQueryPool);
                }
                VkResult vkCreateQueryPool_VkResult_return = (VkResult)0;
                vkCreateQueryPool_VkResult_return = vk->vkCreateQueryPool(unboxed_device, pCreateInfo, pAllocator, pQueryPool);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pQueryPool;
                if (vkCreateQueryPool_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_133;
                static_assert(8 == sizeof(VkQueryPool), "handle map overwrite requres VkQueryPool to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkQueryPool((VkQueryPool*)pQueryPool, 1);
                vkStream->write((VkQueryPool*)pQueryPool, 8 * 1);
                // Begin auto non dispatchable handle create for pQueryPool;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateQueryPool_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateQueryPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateQueryPool_VkResult_return, device, pCreateInfo, pAllocator, pQueryPool);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyQueryPool:
            {
                VkDevice device;
                VkQueryPool queryPool;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_134;
                vkReadStream->read((uint64_t*)&cgen_var_134, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_134, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for queryPool;
                VkQueryPool* boxed_queryPool_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_queryPool_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_135;
                vkReadStream->read((uint64_t*)&cgen_var_135, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_135, (VkQueryPool*)&queryPool, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for queryPool;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyQueryPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)queryPool, (unsigned long long)pAllocator);
                }
                vk->vkDestroyQueryPool(unboxed_device, queryPool, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyQueryPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_queryPool_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetQueryPoolResults:
            {
                VkDevice device;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                size_t dataSize;
                void* pData;
                VkDeviceSize stride;
                VkQueryResultFlags flags;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_137;
                vkReadStream->read((uint64_t*)&cgen_var_137, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_137, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_138;
                vkReadStream->read((uint64_t*)&cgen_var_138, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_138, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&firstQuery, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queryCount, sizeof(uint32_t));
                dataSize = (size_t)vkReadStream->getBe64();
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(uint8_t));
                vkReadStream->read((void*)pData, ((dataSize)) * sizeof(uint8_t));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pData;
                vkReadStream->read((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
                vkReadStream->read((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetQueryPoolResults 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)queryPool, (unsigned long long)firstQuery, (unsigned long long)queryCount, (unsigned long long)dataSize, (unsigned long long)pData, (unsigned long long)stride, (unsigned long long)flags);
                }
                VkResult vkGetQueryPoolResults_VkResult_return = (VkResult)0;
                vkGetQueryPoolResults_VkResult_return = vk->vkGetQueryPoolResults(unboxed_device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
                vkStream->unsetHandleMapping();
                vkStream->write((void*)pData, ((dataSize)) * sizeof(uint8_t));
                vkStream->write(&vkGetQueryPoolResults_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetQueryPoolResults(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetQueryPoolResults_VkResult_return, device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateBuffer:
            {
                VkDevice device;
                const VkBufferCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkBuffer* pBuffer;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_140;
                vkReadStream->read((uint64_t*)&cgen_var_140, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_140, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferCreateInfo));
                unmarshal_VkBufferCreateInfo(vkReadStream, (VkBufferCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pBuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pBuffer, sizeof(VkBuffer));
                uint64_t cgen_var_142;
                vkReadStream->read((uint64_t*)&cgen_var_142, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_142, (VkBuffer*)pBuffer, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pBuffer;
                if (pCreateInfo)
                {
                    transform_tohost_VkBufferCreateInfo(m_state, (VkBufferCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateBuffer 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pBuffer);
                }
                VkResult vkCreateBuffer_VkResult_return = (VkResult)0;
                vkCreateBuffer_VkResult_return = m_state->on_vkCreateBuffer(&m_pool, device, pCreateInfo, pAllocator, pBuffer);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pBuffer;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_143;
                static_assert(8 == sizeof(VkBuffer), "handle map overwrite requres VkBuffer to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkBuffer((VkBuffer*)pBuffer, 1);
                vkStream->write((VkBuffer*)pBuffer, 8 * 1);
                // Begin manual non dispatchable handle create for pBuffer;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateBuffer_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateBuffer_VkResult_return, device, pCreateInfo, pAllocator, pBuffer);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyBuffer:
            {
                VkDevice device;
                VkBuffer buffer;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_144;
                vkReadStream->read((uint64_t*)&cgen_var_144, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_144, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for buffer;
                VkBuffer* boxed_buffer_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_buffer_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_145;
                vkReadStream->read((uint64_t*)&cgen_var_145, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_145, (VkBuffer*)&buffer, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for buffer;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyBuffer 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buffer, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyBuffer(&m_pool, device, buffer, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_buffer_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateBufferView:
            {
                VkDevice device;
                const VkBufferViewCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkBufferView* pView;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_147;
                vkReadStream->read((uint64_t*)&cgen_var_147, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_147, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferViewCreateInfo));
                unmarshal_VkBufferViewCreateInfo(vkReadStream, (VkBufferViewCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pView;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pView, sizeof(VkBufferView));
                uint64_t cgen_var_149;
                vkReadStream->read((uint64_t*)&cgen_var_149, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBufferView(&cgen_var_149, (VkBufferView*)pView, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pView;
                if (pCreateInfo)
                {
                    transform_tohost_VkBufferViewCreateInfo(m_state, (VkBufferViewCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateBufferView 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pView);
                }
                VkResult vkCreateBufferView_VkResult_return = (VkResult)0;
                vkCreateBufferView_VkResult_return = vk->vkCreateBufferView(unboxed_device, pCreateInfo, pAllocator, pView);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pView;
                if (vkCreateBufferView_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_150;
                static_assert(8 == sizeof(VkBufferView), "handle map overwrite requres VkBufferView to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkBufferView((VkBufferView*)pView, 1);
                vkStream->write((VkBufferView*)pView, 8 * 1);
                // Begin auto non dispatchable handle create for pView;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateBufferView_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateBufferView(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateBufferView_VkResult_return, device, pCreateInfo, pAllocator, pView);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyBufferView:
            {
                VkDevice device;
                VkBufferView bufferView;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_151;
                vkReadStream->read((uint64_t*)&cgen_var_151, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_151, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for bufferView;
                VkBufferView* boxed_bufferView_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_bufferView_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_152;
                vkReadStream->read((uint64_t*)&cgen_var_152, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBufferView(&cgen_var_152, (VkBufferView*)&bufferView, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for bufferView;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyBufferView 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bufferView, (unsigned long long)pAllocator);
                }
                vk->vkDestroyBufferView(unboxed_device, bufferView, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyBufferView(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_bufferView_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateImage:
            {
                VkDevice device;
                const VkImageCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkImage* pImage;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_154;
                vkReadStream->read((uint64_t*)&cgen_var_154, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_154, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageCreateInfo));
                unmarshal_VkImageCreateInfo(vkReadStream, (VkImageCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pImage;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImage, sizeof(VkImage));
                uint64_t cgen_var_156;
                vkReadStream->read((uint64_t*)&cgen_var_156, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_156, (VkImage*)pImage, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pImage;
                if (pCreateInfo)
                {
                    transform_tohost_VkImageCreateInfo(m_state, (VkImageCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateImage 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pImage);
                }
                VkResult vkCreateImage_VkResult_return = (VkResult)0;
                vkCreateImage_VkResult_return = m_state->on_vkCreateImage(&m_pool, device, pCreateInfo, pAllocator, pImage);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pImage;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_157;
                static_assert(8 == sizeof(VkImage), "handle map overwrite requres VkImage to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkImage((VkImage*)pImage, 1);
                vkStream->write((VkImage*)pImage, 8 * 1);
                // Begin manual non dispatchable handle create for pImage;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateImage_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateImage_VkResult_return, device, pCreateInfo, pAllocator, pImage);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyImage:
            {
                VkDevice device;
                VkImage image;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_158;
                vkReadStream->read((uint64_t*)&cgen_var_158, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_158, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for image;
                VkImage* boxed_image_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_image_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_159;
                vkReadStream->read((uint64_t*)&cgen_var_159, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_159, (VkImage*)&image, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for image;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyImage 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyImage(&m_pool, device, image, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_image_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetImageSubresourceLayout:
            {
                VkDevice device;
                VkImage image;
                const VkImageSubresource* pSubresource;
                VkSubresourceLayout* pLayout;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_161;
                vkReadStream->read((uint64_t*)&cgen_var_161, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_161, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_162;
                vkReadStream->read((uint64_t*)&cgen_var_162, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_162, (VkImage*)&image, 1);
                vkReadStream->alloc((void**)&pSubresource, sizeof(const VkImageSubresource));
                unmarshal_VkImageSubresource(vkReadStream, (VkImageSubresource*)(pSubresource));
                // Begin manual dispatchable handle unboxing for pLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pLayout, sizeof(VkSubresourceLayout));
                unmarshal_VkSubresourceLayout(vkReadStream, (VkSubresourceLayout*)(pLayout));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pLayout;
                if (pSubresource)
                {
                    transform_tohost_VkImageSubresource(m_state, (VkImageSubresource*)(pSubresource));
                }
                if (pLayout)
                {
                    transform_tohost_VkSubresourceLayout(m_state, (VkSubresourceLayout*)(pLayout));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetImageSubresourceLayout 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)pSubresource, (unsigned long long)pLayout);
                }
                vk->vkGetImageSubresourceLayout(unboxed_device, image, pSubresource, pLayout);
                vkStream->unsetHandleMapping();
                if (pLayout)
                {
                    transform_fromhost_VkSubresourceLayout(m_state, (VkSubresourceLayout*)(pLayout));
                }
                marshal_VkSubresourceLayout(vkStream, (VkSubresourceLayout*)(pLayout));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageSubresourceLayout(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, image, pSubresource, pLayout);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateImageView:
            {
                VkDevice device;
                const VkImageViewCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkImageView* pView;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_163;
                vkReadStream->read((uint64_t*)&cgen_var_163, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_163, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageViewCreateInfo));
                unmarshal_VkImageViewCreateInfo(vkReadStream, (VkImageViewCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pView;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pView, sizeof(VkImageView));
                uint64_t cgen_var_165;
                vkReadStream->read((uint64_t*)&cgen_var_165, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImageView(&cgen_var_165, (VkImageView*)pView, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pView;
                if (pCreateInfo)
                {
                    transform_tohost_VkImageViewCreateInfo(m_state, (VkImageViewCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateImageView 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pView);
                }
                VkResult vkCreateImageView_VkResult_return = (VkResult)0;
                vkCreateImageView_VkResult_return = m_state->on_vkCreateImageView(&m_pool, device, pCreateInfo, pAllocator, pView);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pView;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_166;
                static_assert(8 == sizeof(VkImageView), "handle map overwrite requres VkImageView to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkImageView((VkImageView*)pView, 1);
                vkStream->write((VkImageView*)pView, 8 * 1);
                // Begin manual non dispatchable handle create for pView;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateImageView_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateImageView(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateImageView_VkResult_return, device, pCreateInfo, pAllocator, pView);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyImageView:
            {
                VkDevice device;
                VkImageView imageView;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_167;
                vkReadStream->read((uint64_t*)&cgen_var_167, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_167, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for imageView;
                VkImageView* boxed_imageView_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_imageView_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_168;
                vkReadStream->read((uint64_t*)&cgen_var_168, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImageView(&cgen_var_168, (VkImageView*)&imageView, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for imageView;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyImageView 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)imageView, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyImageView(&m_pool, device, imageView, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyImageView(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_imageView_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateShaderModule:
            {
                VkDevice device;
                const VkShaderModuleCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkShaderModule* pShaderModule;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_170;
                vkReadStream->read((uint64_t*)&cgen_var_170, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_170, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkShaderModuleCreateInfo));
                unmarshal_VkShaderModuleCreateInfo(vkReadStream, (VkShaderModuleCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pShaderModule;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pShaderModule, sizeof(VkShaderModule));
                uint64_t cgen_var_172;
                vkReadStream->read((uint64_t*)&cgen_var_172, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkShaderModule(&cgen_var_172, (VkShaderModule*)pShaderModule, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pShaderModule;
                if (pCreateInfo)
                {
                    transform_tohost_VkShaderModuleCreateInfo(m_state, (VkShaderModuleCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateShaderModule 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pShaderModule);
                }
                VkResult vkCreateShaderModule_VkResult_return = (VkResult)0;
                vkCreateShaderModule_VkResult_return = vk->vkCreateShaderModule(unboxed_device, pCreateInfo, pAllocator, pShaderModule);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pShaderModule;
                if (vkCreateShaderModule_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_173;
                static_assert(8 == sizeof(VkShaderModule), "handle map overwrite requres VkShaderModule to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkShaderModule((VkShaderModule*)pShaderModule, 1);
                vkStream->write((VkShaderModule*)pShaderModule, 8 * 1);
                // Begin auto non dispatchable handle create for pShaderModule;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateShaderModule_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateShaderModule(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateShaderModule_VkResult_return, device, pCreateInfo, pAllocator, pShaderModule);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyShaderModule:
            {
                VkDevice device;
                VkShaderModule shaderModule;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_174;
                vkReadStream->read((uint64_t*)&cgen_var_174, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_174, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for shaderModule;
                VkShaderModule* boxed_shaderModule_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_shaderModule_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_175;
                vkReadStream->read((uint64_t*)&cgen_var_175, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkShaderModule(&cgen_var_175, (VkShaderModule*)&shaderModule, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for shaderModule;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyShaderModule 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)shaderModule, (unsigned long long)pAllocator);
                }
                vk->vkDestroyShaderModule(unboxed_device, shaderModule, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyShaderModule(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_shaderModule_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreatePipelineCache:
            {
                VkDevice device;
                const VkPipelineCacheCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkPipelineCache* pPipelineCache;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_177;
                vkReadStream->read((uint64_t*)&cgen_var_177, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_177, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineCacheCreateInfo));
                unmarshal_VkPipelineCacheCreateInfo(vkReadStream, (VkPipelineCacheCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pPipelineCache;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelineCache, sizeof(VkPipelineCache));
                uint64_t cgen_var_179;
                vkReadStream->read((uint64_t*)&cgen_var_179, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_179, (VkPipelineCache*)pPipelineCache, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPipelineCache;
                if (pCreateInfo)
                {
                    transform_tohost_VkPipelineCacheCreateInfo(m_state, (VkPipelineCacheCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreatePipelineCache 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pPipelineCache);
                }
                VkResult vkCreatePipelineCache_VkResult_return = (VkResult)0;
                vkCreatePipelineCache_VkResult_return = vk->vkCreatePipelineCache(unboxed_device, pCreateInfo, pAllocator, pPipelineCache);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pPipelineCache;
                if (vkCreatePipelineCache_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_180;
                static_assert(8 == sizeof(VkPipelineCache), "handle map overwrite requres VkPipelineCache to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkPipelineCache((VkPipelineCache*)pPipelineCache, 1);
                vkStream->write((VkPipelineCache*)pPipelineCache, 8 * 1);
                // Begin auto non dispatchable handle create for pPipelineCache;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreatePipelineCache_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreatePipelineCache(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreatePipelineCache_VkResult_return, device, pCreateInfo, pAllocator, pPipelineCache);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyPipelineCache:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_181;
                vkReadStream->read((uint64_t*)&cgen_var_181, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_181, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for pipelineCache;
                VkPipelineCache* boxed_pipelineCache_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_pipelineCache_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_182;
                vkReadStream->read((uint64_t*)&cgen_var_182, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_182, (VkPipelineCache*)&pipelineCache, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for pipelineCache;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyPipelineCache 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineCache, (unsigned long long)pAllocator);
                }
                vk->vkDestroyPipelineCache(unboxed_device, pipelineCache, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyPipelineCache(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_pipelineCache_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPipelineCacheData:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                size_t* pDataSize;
                void* pData;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_184;
                vkReadStream->read((uint64_t*)&cgen_var_184, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_184, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_185;
                vkReadStream->read((uint64_t*)&cgen_var_185, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_185, (VkPipelineCache*)&pipelineCache, 1);
                // Begin manual dispatchable handle unboxing for pDataSize;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pDataSize = (size_t*)(uintptr_t)vkReadStream->getBe64();
                if (pDataSize)
                {
                    vkReadStream->alloc((void**)&pDataSize, sizeof(size_t));
                    (*pDataSize) = (size_t)vkReadStream->getBe64();
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDataSize;
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pData = (void*)(uintptr_t)vkReadStream->getBe64();
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, (*(pDataSize)) * sizeof(uint8_t));
                    vkReadStream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pData;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPipelineCacheData 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineCache, (unsigned long long)pDataSize, (unsigned long long)pData);
                }
                VkResult vkGetPipelineCacheData_VkResult_return = (VkResult)0;
                vkGetPipelineCacheData_VkResult_return = vk->vkGetPipelineCacheData(unboxed_device, pipelineCache, pDataSize, pData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_189 = (uint64_t)(uintptr_t)pDataSize;
                vkStream->putBe64(cgen_var_189);
                if (pDataSize)
                {
                    uint64_t cgen_var_190 = (uint64_t)(*pDataSize);
                    vkStream->putBe64(cgen_var_190);
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_191 = (uint64_t)(uintptr_t)pData;
                vkStream->putBe64(cgen_var_191);
                if (pData)
                {
                    vkStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetPipelineCacheData_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPipelineCacheData(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPipelineCacheData_VkResult_return, device, pipelineCache, pDataSize, pData);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkMergePipelineCaches:
            {
                VkDevice device;
                VkPipelineCache dstCache;
                uint32_t srcCacheCount;
                const VkPipelineCache* pSrcCaches;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_192;
                vkReadStream->read((uint64_t*)&cgen_var_192, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_192, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_193;
                vkReadStream->read((uint64_t*)&cgen_var_193, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_193, (VkPipelineCache*)&dstCache, 1);
                vkReadStream->read((uint32_t*)&srcCacheCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSrcCaches, ((srcCacheCount)) * sizeof(const VkPipelineCache));
                if (((srcCacheCount)))
                {
                    uint64_t* cgen_var_194;
                    vkReadStream->alloc((void**)&cgen_var_194, ((srcCacheCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_194, ((srcCacheCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(cgen_var_194, (VkPipelineCache*)pSrcCaches, ((srcCacheCount)));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkMergePipelineCaches 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)dstCache, (unsigned long long)srcCacheCount, (unsigned long long)pSrcCaches);
                }
                VkResult vkMergePipelineCaches_VkResult_return = (VkResult)0;
                vkMergePipelineCaches_VkResult_return = vk->vkMergePipelineCaches(unboxed_device, dstCache, srcCacheCount, pSrcCaches);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkMergePipelineCaches_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkMergePipelineCaches(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkMergePipelineCaches_VkResult_return, device, dstCache, srcCacheCount, pSrcCaches);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateGraphicsPipelines:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                uint32_t createInfoCount;
                const VkGraphicsPipelineCreateInfo* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkPipeline* pPipelines;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_195;
                vkReadStream->read((uint64_t*)&cgen_var_195, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_195, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_196;
                vkReadStream->read((uint64_t*)&cgen_var_196, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_196, (VkPipelineCache*)&pipelineCache, 1);
                vkReadStream->read((uint32_t*)&createInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkGraphicsPipelineCreateInfo));
                for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                {
                    unmarshal_VkGraphicsPipelineCreateInfo(vkReadStream, (VkGraphicsPipelineCreateInfo*)(pCreateInfos + i));
                }
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pPipelines;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_198;
                    vkReadStream->alloc((void**)&cgen_var_198, ((createInfoCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_198, ((createInfoCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_198, (VkPipeline*)pPipelines, ((createInfoCount)));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPipelines;
                if (pCreateInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                    {
                        transform_tohost_VkGraphicsPipelineCreateInfo(m_state, (VkGraphicsPipelineCreateInfo*)(pCreateInfos + i));
                    }
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateGraphicsPipelines 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineCache, (unsigned long long)createInfoCount, (unsigned long long)pCreateInfos, (unsigned long long)pAllocator, (unsigned long long)pPipelines);
                }
                VkResult vkCreateGraphicsPipelines_VkResult_return = (VkResult)0;
                vkCreateGraphicsPipelines_VkResult_return = m_state->on_vkCreateGraphicsPipelines(&m_pool, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pPipelines;
                vkStream->unsetHandleMapping();
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_199;
                    vkStream->alloc((void**)&cgen_var_199, ((createInfoCount)) * 8);
                    static_assert(8 == sizeof(VkPipeline), "handle map overwrite requres VkPipeline to be 8 bytes long");
                    vkStream->handleMapping()->mapHandles_VkPipeline((VkPipeline*)pPipelines, ((createInfoCount)));
                    vkStream->write((VkPipeline*)pPipelines, 8 * ((createInfoCount)));
                }
                // Begin manual non dispatchable handle create for pPipelines;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateGraphicsPipelines_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateGraphicsPipelines(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateGraphicsPipelines_VkResult_return, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateComputePipelines:
            {
                VkDevice device;
                VkPipelineCache pipelineCache;
                uint32_t createInfoCount;
                const VkComputePipelineCreateInfo* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkPipeline* pPipelines;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_200;
                vkReadStream->read((uint64_t*)&cgen_var_200, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_200, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_201;
                vkReadStream->read((uint64_t*)&cgen_var_201, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_201, (VkPipelineCache*)&pipelineCache, 1);
                vkReadStream->read((uint32_t*)&createInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCreateInfos, ((createInfoCount)) * sizeof(const VkComputePipelineCreateInfo));
                for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                {
                    unmarshal_VkComputePipelineCreateInfo(vkReadStream, (VkComputePipelineCreateInfo*)(pCreateInfos + i));
                }
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pPipelines;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelines, ((createInfoCount)) * sizeof(VkPipeline));
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_203;
                    vkReadStream->alloc((void**)&cgen_var_203, ((createInfoCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_203, ((createInfoCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_203, (VkPipeline*)pPipelines, ((createInfoCount)));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPipelines;
                if (pCreateInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
                    {
                        transform_tohost_VkComputePipelineCreateInfo(m_state, (VkComputePipelineCreateInfo*)(pCreateInfos + i));
                    }
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateComputePipelines 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineCache, (unsigned long long)createInfoCount, (unsigned long long)pCreateInfos, (unsigned long long)pAllocator, (unsigned long long)pPipelines);
                }
                VkResult vkCreateComputePipelines_VkResult_return = (VkResult)0;
                vkCreateComputePipelines_VkResult_return = m_state->on_vkCreateComputePipelines(&m_pool, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pPipelines;
                vkStream->unsetHandleMapping();
                if (((createInfoCount)))
                {
                    uint64_t* cgen_var_204;
                    vkStream->alloc((void**)&cgen_var_204, ((createInfoCount)) * 8);
                    static_assert(8 == sizeof(VkPipeline), "handle map overwrite requres VkPipeline to be 8 bytes long");
                    vkStream->handleMapping()->mapHandles_VkPipeline((VkPipeline*)pPipelines, ((createInfoCount)));
                    vkStream->write((VkPipeline*)pPipelines, 8 * ((createInfoCount)));
                }
                // Begin manual non dispatchable handle create for pPipelines;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateComputePipelines_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateComputePipelines(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateComputePipelines_VkResult_return, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyPipeline:
            {
                VkDevice device;
                VkPipeline pipeline;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_205;
                vkReadStream->read((uint64_t*)&cgen_var_205, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_205, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for pipeline;
                VkPipeline* boxed_pipeline_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_pipeline_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_206;
                vkReadStream->read((uint64_t*)&cgen_var_206, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_206, (VkPipeline*)&pipeline, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for pipeline;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyPipeline 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipeline, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyPipeline(&m_pool, device, pipeline, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyPipeline(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_pipeline_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreatePipelineLayout:
            {
                VkDevice device;
                const VkPipelineLayoutCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkPipelineLayout* pPipelineLayout;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_208;
                vkReadStream->read((uint64_t*)&cgen_var_208, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_208, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkPipelineLayoutCreateInfo));
                unmarshal_VkPipelineLayoutCreateInfo(vkReadStream, (VkPipelineLayoutCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pPipelineLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPipelineLayout, sizeof(VkPipelineLayout));
                uint64_t cgen_var_210;
                vkReadStream->read((uint64_t*)&cgen_var_210, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_210, (VkPipelineLayout*)pPipelineLayout, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPipelineLayout;
                if (pCreateInfo)
                {
                    transform_tohost_VkPipelineLayoutCreateInfo(m_state, (VkPipelineLayoutCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreatePipelineLayout 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pPipelineLayout);
                }
                m_state->lock();
                VkResult vkCreatePipelineLayout_VkResult_return = (VkResult)0;
                vkCreatePipelineLayout_VkResult_return = m_state->on_vkCreatePipelineLayout(&m_pool, device, pCreateInfo, pAllocator, pPipelineLayout);
                m_state->unlock();
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pPipelineLayout;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_211;
                static_assert(8 == sizeof(VkPipelineLayout), "handle map overwrite requres VkPipelineLayout to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkPipelineLayout((VkPipelineLayout*)pPipelineLayout, 1);
                vkStream->write((VkPipelineLayout*)pPipelineLayout, 8 * 1);
                // Begin manual non dispatchable handle create for pPipelineLayout;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreatePipelineLayout_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreatePipelineLayout(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreatePipelineLayout_VkResult_return, device, pCreateInfo, pAllocator, pPipelineLayout);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyPipelineLayout:
            {
                VkDevice device;
                VkPipelineLayout pipelineLayout;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_212;
                vkReadStream->read((uint64_t*)&cgen_var_212, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_212, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for pipelineLayout;
                VkPipelineLayout* boxed_pipelineLayout_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_pipelineLayout_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_213;
                vkReadStream->read((uint64_t*)&cgen_var_213, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_213, (VkPipelineLayout*)&pipelineLayout, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for pipelineLayout;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyPipelineLayout 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipelineLayout, (unsigned long long)pAllocator);
                }
                m_state->lock();
                m_state->on_vkDestroyPipelineLayout(&m_pool, device, pipelineLayout, pAllocator);
                m_state->unlock();
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyPipelineLayout(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_pipelineLayout_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateSampler:
            {
                VkDevice device;
                const VkSamplerCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSampler* pSampler;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_215;
                vkReadStream->read((uint64_t*)&cgen_var_215, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_215, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerCreateInfo));
                unmarshal_VkSamplerCreateInfo(vkReadStream, (VkSamplerCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSampler;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSampler, sizeof(VkSampler));
                uint64_t cgen_var_217;
                vkReadStream->read((uint64_t*)&cgen_var_217, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSampler(&cgen_var_217, (VkSampler*)pSampler, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSampler;
                if (pCreateInfo)
                {
                    transform_tohost_VkSamplerCreateInfo(m_state, (VkSamplerCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateSampler 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSampler);
                }
                VkResult vkCreateSampler_VkResult_return = (VkResult)0;
                vkCreateSampler_VkResult_return = m_state->on_vkCreateSampler(&m_pool, device, pCreateInfo, pAllocator, pSampler);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pSampler;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_218;
                static_assert(8 == sizeof(VkSampler), "handle map overwrite requres VkSampler to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkSampler((VkSampler*)pSampler, 1);
                vkStream->write((VkSampler*)pSampler, 8 * 1);
                // Begin manual non dispatchable handle create for pSampler;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSampler_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSampler(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSampler_VkResult_return, device, pCreateInfo, pAllocator, pSampler);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroySampler:
            {
                VkDevice device;
                VkSampler sampler;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_219;
                vkReadStream->read((uint64_t*)&cgen_var_219, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_219, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for sampler;
                VkSampler* boxed_sampler_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_sampler_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_220;
                vkReadStream->read((uint64_t*)&cgen_var_220, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSampler(&cgen_var_220, (VkSampler*)&sampler, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for sampler;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroySampler 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)sampler, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroySampler(&m_pool, device, sampler, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySampler(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_sampler_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateDescriptorSetLayout:
            {
                VkDevice device;
                const VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorSetLayout* pSetLayout;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_222;
                vkReadStream->read((uint64_t*)&cgen_var_222, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_222, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                unmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSetLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSetLayout, sizeof(VkDescriptorSetLayout));
                uint64_t cgen_var_224;
                vkReadStream->read((uint64_t*)&cgen_var_224, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(&cgen_var_224, (VkDescriptorSetLayout*)pSetLayout, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSetLayout;
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorSetLayoutCreateInfo(m_state, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateDescriptorSetLayout 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSetLayout);
                }
                VkResult vkCreateDescriptorSetLayout_VkResult_return = (VkResult)0;
                vkCreateDescriptorSetLayout_VkResult_return = m_state->on_vkCreateDescriptorSetLayout(&m_pool, device, pCreateInfo, pAllocator, pSetLayout);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pSetLayout;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_225;
                static_assert(8 == sizeof(VkDescriptorSetLayout), "handle map overwrite requres VkDescriptorSetLayout to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDescriptorSetLayout((VkDescriptorSetLayout*)pSetLayout, 1);
                vkStream->write((VkDescriptorSetLayout*)pSetLayout, 8 * 1);
                // Begin manual non dispatchable handle create for pSetLayout;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorSetLayout_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDescriptorSetLayout(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDescriptorSetLayout_VkResult_return, device, pCreateInfo, pAllocator, pSetLayout);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyDescriptorSetLayout:
            {
                VkDevice device;
                VkDescriptorSetLayout descriptorSetLayout;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_226;
                vkReadStream->read((uint64_t*)&cgen_var_226, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_226, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for descriptorSetLayout;
                VkDescriptorSetLayout* boxed_descriptorSetLayout_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_descriptorSetLayout_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_227;
                vkReadStream->read((uint64_t*)&cgen_var_227, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(&cgen_var_227, (VkDescriptorSetLayout*)&descriptorSetLayout, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for descriptorSetLayout;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyDescriptorSetLayout 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorSetLayout, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyDescriptorSetLayout(&m_pool, device, descriptorSetLayout, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDescriptorSetLayout(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_descriptorSetLayout_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateDescriptorPool:
            {
                VkDevice device;
                const VkDescriptorPoolCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorPool* pDescriptorPool;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_229;
                vkReadStream->read((uint64_t*)&cgen_var_229, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_229, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorPoolCreateInfo));
                unmarshal_VkDescriptorPoolCreateInfo(vkReadStream, (VkDescriptorPoolCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pDescriptorPool;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorPool, sizeof(VkDescriptorPool));
                uint64_t cgen_var_231;
                vkReadStream->read((uint64_t*)&cgen_var_231, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_231, (VkDescriptorPool*)pDescriptorPool, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDescriptorPool;
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorPoolCreateInfo(m_state, (VkDescriptorPoolCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateDescriptorPool 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pDescriptorPool);
                }
                VkResult vkCreateDescriptorPool_VkResult_return = (VkResult)0;
                vkCreateDescriptorPool_VkResult_return = m_state->on_vkCreateDescriptorPool(&m_pool, device, pCreateInfo, pAllocator, pDescriptorPool);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pDescriptorPool;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_232;
                static_assert(8 == sizeof(VkDescriptorPool), "handle map overwrite requres VkDescriptorPool to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDescriptorPool((VkDescriptorPool*)pDescriptorPool, 1);
                vkStream->write((VkDescriptorPool*)pDescriptorPool, 8 * 1);
                // Begin manual non dispatchable handle create for pDescriptorPool;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorPool_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDescriptorPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDescriptorPool_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorPool);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyDescriptorPool:
            {
                VkDevice device;
                VkDescriptorPool descriptorPool;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_233;
                vkReadStream->read((uint64_t*)&cgen_var_233, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_233, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for descriptorPool;
                VkDescriptorPool* boxed_descriptorPool_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_descriptorPool_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_234;
                vkReadStream->read((uint64_t*)&cgen_var_234, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_234, (VkDescriptorPool*)&descriptorPool, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for descriptorPool;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyDescriptorPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorPool, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyDescriptorPool(&m_pool, device, descriptorPool, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDescriptorPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_descriptorPool_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkResetDescriptorPool:
            {
                VkDevice device;
                VkDescriptorPool descriptorPool;
                VkDescriptorPoolResetFlags flags;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_236;
                vkReadStream->read((uint64_t*)&cgen_var_236, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_236, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_237;
                vkReadStream->read((uint64_t*)&cgen_var_237, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_237, (VkDescriptorPool*)&descriptorPool, 1);
                vkReadStream->read((VkDescriptorPoolResetFlags*)&flags, sizeof(VkDescriptorPoolResetFlags));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkResetDescriptorPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorPool, (unsigned long long)flags);
                }
                VkResult vkResetDescriptorPool_VkResult_return = (VkResult)0;
                vkResetDescriptorPool_VkResult_return = m_state->on_vkResetDescriptorPool(&m_pool, device, descriptorPool, flags);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetDescriptorPool_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetDescriptorPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkResetDescriptorPool_VkResult_return, device, descriptorPool, flags);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkAllocateDescriptorSets:
            {
                VkDevice device;
                const VkDescriptorSetAllocateInfo* pAllocateInfo;
                VkDescriptorSet* pDescriptorSets;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_238;
                vkReadStream->read((uint64_t*)&cgen_var_238, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_238, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkDescriptorSetAllocateInfo));
                unmarshal_VkDescriptorSetAllocateInfo(vkReadStream, (VkDescriptorSetAllocateInfo*)(pAllocateInfo));
                // Begin manual dispatchable handle unboxing for pDescriptorSets;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorSets, pAllocateInfo->descriptorSetCount * sizeof(VkDescriptorSet));
                if (pAllocateInfo->descriptorSetCount)
                {
                    uint64_t* cgen_var_239;
                    vkReadStream->alloc((void**)&cgen_var_239, pAllocateInfo->descriptorSetCount * 8);
                    vkReadStream->read((uint64_t*)cgen_var_239, pAllocateInfo->descriptorSetCount * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(cgen_var_239, (VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount);
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDescriptorSets;
                if (pAllocateInfo)
                {
                    transform_tohost_VkDescriptorSetAllocateInfo(m_state, (VkDescriptorSetAllocateInfo*)(pAllocateInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkAllocateDescriptorSets 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAllocateInfo, (unsigned long long)pDescriptorSets);
                }
                VkResult vkAllocateDescriptorSets_VkResult_return = (VkResult)0;
                vkAllocateDescriptorSets_VkResult_return = m_state->on_vkAllocateDescriptorSets(&m_pool, device, pAllocateInfo, pDescriptorSets);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pDescriptorSets;
                vkStream->unsetHandleMapping();
                if (pAllocateInfo->descriptorSetCount)
                {
                    uint64_t* cgen_var_240;
                    vkStream->alloc((void**)&cgen_var_240, pAllocateInfo->descriptorSetCount * 8);
                    static_assert(8 == sizeof(VkDescriptorSet), "handle map overwrite requres VkDescriptorSet to be 8 bytes long");
                    vkStream->handleMapping()->mapHandles_VkDescriptorSet((VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount);
                    vkStream->write((VkDescriptorSet*)pDescriptorSets, 8 * pAllocateInfo->descriptorSetCount);
                }
                // Begin manual non dispatchable handle create for pDescriptorSets;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkAllocateDescriptorSets_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAllocateDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAllocateDescriptorSets_VkResult_return, device, pAllocateInfo, pDescriptorSets);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkFreeDescriptorSets:
            {
                VkDevice device;
                VkDescriptorPool descriptorPool;
                uint32_t descriptorSetCount;
                const VkDescriptorSet* pDescriptorSets;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_241;
                vkReadStream->read((uint64_t*)&cgen_var_241, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_241, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_242;
                vkReadStream->read((uint64_t*)&cgen_var_242, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_242, (VkDescriptorPool*)&descriptorPool, 1);
                vkReadStream->read((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
                // Begin manual non dispatchable handle destroy unboxing for pDescriptorSets;
                VkDescriptorSet* boxed_pDescriptorSets_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_pDescriptorSets_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                // WARNING PTR CHECK
                pDescriptorSets = (const VkDescriptorSet*)(uintptr_t)vkReadStream->getBe64();
                if (pDescriptorSets)
                {
                    vkReadStream->alloc((void**)&pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
                    if (((descriptorSetCount)))
                    {
                        uint64_t* cgen_var_244;
                        vkReadStream->alloc((void**)&cgen_var_244, ((descriptorSetCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_244, ((descriptorSetCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(cgen_var_244, (VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for pDescriptorSets;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkFreeDescriptorSets 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorPool, (unsigned long long)descriptorSetCount, (unsigned long long)pDescriptorSets);
                }
                VkResult vkFreeDescriptorSets_VkResult_return = (VkResult)0;
                vkFreeDescriptorSets_VkResult_return = m_state->on_vkFreeDescriptorSets(&m_pool, device, descriptorPool, descriptorSetCount, pDescriptorSets);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkFreeDescriptorSets_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkFreeDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkFreeDescriptorSets_VkResult_return, device, descriptorPool, descriptorSetCount, boxed_pDescriptorSets_preserve);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkUpdateDescriptorSets:
            {
                VkDevice device;
                uint32_t descriptorWriteCount;
                const VkWriteDescriptorSet* pDescriptorWrites;
                uint32_t descriptorCopyCount;
                const VkCopyDescriptorSet* pDescriptorCopies;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_245;
                vkReadStream->read((uint64_t*)&cgen_var_245, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_245, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorWrites, ((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                {
                    unmarshal_VkWriteDescriptorSet(vkReadStream, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                }
                vkReadStream->read((uint32_t*)&descriptorCopyCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorCopies, ((descriptorCopyCount)) * sizeof(const VkCopyDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
                {
                    unmarshal_VkCopyDescriptorSet(vkReadStream, (VkCopyDescriptorSet*)(pDescriptorCopies + i));
                }
                if (pDescriptorWrites)
                {
                    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                    {
                        transform_tohost_VkWriteDescriptorSet(m_state, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                    }
                }
                if (pDescriptorCopies)
                {
                    for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
                    {
                        transform_tohost_VkCopyDescriptorSet(m_state, (VkCopyDescriptorSet*)(pDescriptorCopies + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkUpdateDescriptorSets 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorWriteCount, (unsigned long long)pDescriptorWrites, (unsigned long long)descriptorCopyCount, (unsigned long long)pDescriptorCopies);
                }
                m_state->on_vkUpdateDescriptorSets(&m_pool, device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUpdateDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateFramebuffer:
            {
                VkDevice device;
                const VkFramebufferCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFramebuffer* pFramebuffer;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_246;
                vkReadStream->read((uint64_t*)&cgen_var_246, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_246, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkFramebufferCreateInfo));
                unmarshal_VkFramebufferCreateInfo(vkReadStream, (VkFramebufferCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pFramebuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFramebuffer, sizeof(VkFramebuffer));
                uint64_t cgen_var_248;
                vkReadStream->read((uint64_t*)&cgen_var_248, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFramebuffer(&cgen_var_248, (VkFramebuffer*)pFramebuffer, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFramebuffer;
                if (pCreateInfo)
                {
                    transform_tohost_VkFramebufferCreateInfo(m_state, (VkFramebufferCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateFramebuffer 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pFramebuffer);
                }
                VkResult vkCreateFramebuffer_VkResult_return = (VkResult)0;
                vkCreateFramebuffer_VkResult_return = vk->vkCreateFramebuffer(unboxed_device, pCreateInfo, pAllocator, pFramebuffer);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pFramebuffer;
                if (vkCreateFramebuffer_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_249;
                static_assert(8 == sizeof(VkFramebuffer), "handle map overwrite requres VkFramebuffer to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkFramebuffer((VkFramebuffer*)pFramebuffer, 1);
                vkStream->write((VkFramebuffer*)pFramebuffer, 8 * 1);
                // Begin auto non dispatchable handle create for pFramebuffer;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateFramebuffer_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateFramebuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateFramebuffer_VkResult_return, device, pCreateInfo, pAllocator, pFramebuffer);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyFramebuffer:
            {
                VkDevice device;
                VkFramebuffer framebuffer;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_250;
                vkReadStream->read((uint64_t*)&cgen_var_250, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_250, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for framebuffer;
                VkFramebuffer* boxed_framebuffer_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_framebuffer_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_251;
                vkReadStream->read((uint64_t*)&cgen_var_251, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFramebuffer(&cgen_var_251, (VkFramebuffer*)&framebuffer, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for framebuffer;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyFramebuffer 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)framebuffer, (unsigned long long)pAllocator);
                }
                vk->vkDestroyFramebuffer(unboxed_device, framebuffer, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyFramebuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_framebuffer_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateRenderPass:
            {
                VkDevice device;
                const VkRenderPassCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkRenderPass* pRenderPass;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_253;
                vkReadStream->read((uint64_t*)&cgen_var_253, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_253, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo));
                unmarshal_VkRenderPassCreateInfo(vkReadStream, (VkRenderPassCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pRenderPass;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pRenderPass, sizeof(VkRenderPass));
                uint64_t cgen_var_255;
                vkReadStream->read((uint64_t*)&cgen_var_255, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_255, (VkRenderPass*)pRenderPass, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pRenderPass;
                if (pCreateInfo)
                {
                    transform_tohost_VkRenderPassCreateInfo(m_state, (VkRenderPassCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateRenderPass 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pRenderPass);
                }
                VkResult vkCreateRenderPass_VkResult_return = (VkResult)0;
                vkCreateRenderPass_VkResult_return = m_state->on_vkCreateRenderPass(&m_pool, device, pCreateInfo, pAllocator, pRenderPass);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pRenderPass;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_256;
                static_assert(8 == sizeof(VkRenderPass), "handle map overwrite requres VkRenderPass to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkRenderPass((VkRenderPass*)pRenderPass, 1);
                vkStream->write((VkRenderPass*)pRenderPass, 8 * 1);
                // Begin manual non dispatchable handle create for pRenderPass;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateRenderPass_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateRenderPass(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateRenderPass_VkResult_return, device, pCreateInfo, pAllocator, pRenderPass);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyRenderPass:
            {
                VkDevice device;
                VkRenderPass renderPass;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_257;
                vkReadStream->read((uint64_t*)&cgen_var_257, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_257, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for renderPass;
                VkRenderPass* boxed_renderPass_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_renderPass_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_258;
                vkReadStream->read((uint64_t*)&cgen_var_258, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_258, (VkRenderPass*)&renderPass, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for renderPass;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyRenderPass 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)renderPass, (unsigned long long)pAllocator);
                }
                vk->vkDestroyRenderPass(unboxed_device, renderPass, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyRenderPass(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_renderPass_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetRenderAreaGranularity:
            {
                VkDevice device;
                VkRenderPass renderPass;
                VkExtent2D* pGranularity;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_260;
                vkReadStream->read((uint64_t*)&cgen_var_260, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_260, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_261;
                vkReadStream->read((uint64_t*)&cgen_var_261, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_261, (VkRenderPass*)&renderPass, 1);
                // Begin manual dispatchable handle unboxing for pGranularity;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pGranularity, sizeof(VkExtent2D));
                unmarshal_VkExtent2D(vkReadStream, (VkExtent2D*)(pGranularity));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pGranularity;
                if (pGranularity)
                {
                    transform_tohost_VkExtent2D(m_state, (VkExtent2D*)(pGranularity));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetRenderAreaGranularity 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)renderPass, (unsigned long long)pGranularity);
                }
                vk->vkGetRenderAreaGranularity(unboxed_device, renderPass, pGranularity);
                vkStream->unsetHandleMapping();
                if (pGranularity)
                {
                    transform_fromhost_VkExtent2D(m_state, (VkExtent2D*)(pGranularity));
                }
                marshal_VkExtent2D(vkStream, (VkExtent2D*)(pGranularity));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetRenderAreaGranularity(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, renderPass, pGranularity);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateCommandPool:
            {
                VkDevice device;
                const VkCommandPoolCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkCommandPool* pCommandPool;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_262;
                vkReadStream->read((uint64_t*)&cgen_var_262, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_262, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkCommandPoolCreateInfo));
                unmarshal_VkCommandPoolCreateInfo(vkReadStream, (VkCommandPoolCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pCommandPool;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCommandPool, sizeof(VkCommandPool));
                uint64_t cgen_var_264;
                vkReadStream->read((uint64_t*)&cgen_var_264, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_264, (VkCommandPool*)pCommandPool, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCommandPool;
                if (pCreateInfo)
                {
                    transform_tohost_VkCommandPoolCreateInfo(m_state, (VkCommandPoolCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateCommandPool 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pCommandPool);
                }
                VkResult vkCreateCommandPool_VkResult_return = (VkResult)0;
                vkCreateCommandPool_VkResult_return = m_state->on_vkCreateCommandPool(&m_pool, device, pCreateInfo, pAllocator, pCommandPool);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pCommandPool;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_265;
                static_assert(8 == sizeof(VkCommandPool), "handle map overwrite requres VkCommandPool to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkCommandPool((VkCommandPool*)pCommandPool, 1);
                vkStream->write((VkCommandPool*)pCommandPool, 8 * 1);
                // Begin manual non dispatchable handle create for pCommandPool;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateCommandPool_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateCommandPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateCommandPool_VkResult_return, device, pCreateInfo, pAllocator, pCommandPool);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyCommandPool:
            {
                VkDevice device;
                VkCommandPool commandPool;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_266;
                vkReadStream->read((uint64_t*)&cgen_var_266, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_266, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for commandPool;
                VkCommandPool* boxed_commandPool_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_commandPool_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_267;
                vkReadStream->read((uint64_t*)&cgen_var_267, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_267, (VkCommandPool*)&commandPool, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for commandPool;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyCommandPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)commandPool, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyCommandPool(&m_pool, device, commandPool, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyCommandPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_commandPool_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkResetCommandPool:
            {
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolResetFlags flags;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_269;
                vkReadStream->read((uint64_t*)&cgen_var_269, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_269, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_270;
                vkReadStream->read((uint64_t*)&cgen_var_270, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_270, (VkCommandPool*)&commandPool, 1);
                vkReadStream->read((VkCommandPoolResetFlags*)&flags, sizeof(VkCommandPoolResetFlags));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkResetCommandPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)commandPool, (unsigned long long)flags);
                }
                VkResult vkResetCommandPool_VkResult_return = (VkResult)0;
                vkResetCommandPool_VkResult_return = m_state->on_vkResetCommandPool(&m_pool, device, commandPool, flags);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetCommandPool_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetCommandPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkResetCommandPool_VkResult_return, device, commandPool, flags);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkAllocateCommandBuffers:
            {
                VkDevice device;
                const VkCommandBufferAllocateInfo* pAllocateInfo;
                VkCommandBuffer* pCommandBuffers;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_271;
                vkReadStream->read((uint64_t*)&cgen_var_271, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_271, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pAllocateInfo, sizeof(const VkCommandBufferAllocateInfo));
                unmarshal_VkCommandBufferAllocateInfo(vkReadStream, (VkCommandBufferAllocateInfo*)(pAllocateInfo));
                // Begin manual dispatchable handle unboxing for pCommandBuffers;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCommandBuffers, pAllocateInfo->commandBufferCount * sizeof(VkCommandBuffer));
                if (pAllocateInfo->commandBufferCount)
                {
                    uint64_t* cgen_var_272;
                    vkReadStream->alloc((void**)&cgen_var_272, pAllocateInfo->commandBufferCount * 8);
                    vkReadStream->read((uint64_t*)cgen_var_272, pAllocateInfo->commandBufferCount * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(cgen_var_272, (VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount);
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCommandBuffers;
                if (pAllocateInfo)
                {
                    transform_tohost_VkCommandBufferAllocateInfo(m_state, (VkCommandBufferAllocateInfo*)(pAllocateInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkAllocateCommandBuffers 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAllocateInfo, (unsigned long long)pCommandBuffers);
                }
                VkResult vkAllocateCommandBuffers_VkResult_return = (VkResult)0;
                vkAllocateCommandBuffers_VkResult_return = m_state->on_vkAllocateCommandBuffers(&m_pool, device, pAllocateInfo, pCommandBuffers);
                vkStream->unsetHandleMapping();
                if (pAllocateInfo->commandBufferCount)
                {
                    uint64_t* cgen_var_273;
                    vkStream->alloc((void**)&cgen_var_273, pAllocateInfo->commandBufferCount * 8);
                    static_assert(8 == sizeof(VkCommandBuffer), "handle map overwrite requres VkCommandBuffer to be 8 bytes long");
                    vkStream->handleMapping()->mapHandles_VkCommandBuffer((VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount);
                    vkStream->write((VkCommandBuffer*)pCommandBuffers, 8 * pAllocateInfo->commandBufferCount);
                }
                vkStream->write(&vkAllocateCommandBuffers_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAllocateCommandBuffers(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAllocateCommandBuffers_VkResult_return, device, pAllocateInfo, pCommandBuffers);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkFreeCommandBuffers:
            {
                VkDevice device;
                VkCommandPool commandPool;
                uint32_t commandBufferCount;
                const VkCommandBuffer* pCommandBuffers;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_274;
                vkReadStream->read((uint64_t*)&cgen_var_274, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_274, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_275;
                vkReadStream->read((uint64_t*)&cgen_var_275, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_275, (VkCommandPool*)&commandPool, 1);
                vkReadStream->read((uint32_t*)&commandBufferCount, sizeof(uint32_t));
                // Begin manual non dispatchable handle destroy unboxing for pCommandBuffers;
                VkCommandBuffer* boxed_pCommandBuffers_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_pCommandBuffers_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                // WARNING PTR CHECK
                pCommandBuffers = (const VkCommandBuffer*)(uintptr_t)vkReadStream->getBe64();
                if (pCommandBuffers)
                {
                    vkReadStream->alloc((void**)&pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
                    if (((commandBufferCount)))
                    {
                        uint64_t* cgen_var_277;
                        vkReadStream->alloc((void**)&cgen_var_277, ((commandBufferCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_277, ((commandBufferCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(cgen_var_277, (VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkFreeCommandBuffers 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)commandPool, (unsigned long long)commandBufferCount, (unsigned long long)pCommandBuffers);
                }
                m_state->on_vkFreeCommandBuffers(&m_pool, device, commandPool, commandBufferCount, pCommandBuffers);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkFreeCommandBuffers(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, commandPool, commandBufferCount, boxed_pCommandBuffers_preserve);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkBeginCommandBuffer:
            {
                VkCommandBuffer commandBuffer;
                const VkCommandBufferBeginInfo* pBeginInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_278;
                vkReadStream->read((uint64_t*)&cgen_var_278, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_278, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pBeginInfo, sizeof(const VkCommandBufferBeginInfo));
                unmarshal_VkCommandBufferBeginInfo(vkReadStream, (VkCommandBufferBeginInfo*)(pBeginInfo));
                if (pBeginInfo)
                {
                    transform_tohost_VkCommandBufferBeginInfo(m_state, (VkCommandBufferBeginInfo*)(pBeginInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkBeginCommandBuffer 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pBeginInfo);
                }
                VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
                vkBeginCommandBuffer_VkResult_return = m_state->on_vkBeginCommandBuffer(&m_pool, commandBuffer, pBeginInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBeginCommandBuffer_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBeginCommandBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBeginCommandBuffer_VkResult_return, commandBuffer, pBeginInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkEndCommandBuffer:
            {
                VkCommandBuffer commandBuffer;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_279;
                vkReadStream->read((uint64_t*)&cgen_var_279, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_279, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkEndCommandBuffer 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
                vkEndCommandBuffer_VkResult_return = vk->vkEndCommandBuffer(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkEndCommandBuffer_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEndCommandBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEndCommandBuffer_VkResult_return, commandBuffer);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkResetCommandBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkCommandBufferResetFlags flags;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_280;
                vkReadStream->read((uint64_t*)&cgen_var_280, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_280, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkCommandBufferResetFlags*)&flags, sizeof(VkCommandBufferResetFlags));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkResetCommandBuffer 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)flags);
                }
                VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
                vkResetCommandBuffer_VkResult_return = m_state->on_vkResetCommandBuffer(&m_pool, commandBuffer, flags);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkResetCommandBuffer_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetCommandBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkResetCommandBuffer_VkResult_return, commandBuffer, flags);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdBindPipeline:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipeline pipeline;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_281;
                vkReadStream->read((uint64_t*)&cgen_var_281, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_281, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
                uint64_t cgen_var_282;
                vkReadStream->read((uint64_t*)&cgen_var_282, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_282, (VkPipeline*)&pipeline, 1);
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdBindPipeline 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineBindPoint, (unsigned long long)pipeline);
                }
                m_state->on_vkCmdBindPipeline(&m_pool, commandBuffer, pipelineBindPoint, pipeline);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindPipeline(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineBindPoint, pipeline);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdSetViewport:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstViewport;
                uint32_t viewportCount;
                const VkViewport* pViewports;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_283;
                vkReadStream->read((uint64_t*)&cgen_var_283, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_283, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&firstViewport, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&viewportCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pViewports, ((viewportCount)) * sizeof(const VkViewport));
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                {
                    unmarshal_VkViewport(vkReadStream, (VkViewport*)(pViewports + i));
                }
                if (pViewports)
                {
                    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                    {
                        transform_tohost_VkViewport(m_state, (VkViewport*)(pViewports + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetViewport 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstViewport, (unsigned long long)viewportCount, (unsigned long long)pViewports);
                }
                vk->vkCmdSetViewport(unboxed_commandBuffer, firstViewport, viewportCount, pViewports);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetViewport(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstViewport, viewportCount, pViewports);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdSetScissor:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstScissor;
                uint32_t scissorCount;
                const VkRect2D* pScissors;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_284;
                vkReadStream->read((uint64_t*)&cgen_var_284, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_284, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&firstScissor, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&scissorCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pScissors, ((scissorCount)) * sizeof(const VkRect2D));
                for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
                {
                    unmarshal_VkRect2D(vkReadStream, (VkRect2D*)(pScissors + i));
                }
                if (pScissors)
                {
                    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
                    {
                        transform_tohost_VkRect2D(m_state, (VkRect2D*)(pScissors + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetScissor 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstScissor, (unsigned long long)scissorCount, (unsigned long long)pScissors);
                }
                vk->vkCmdSetScissor(unboxed_commandBuffer, firstScissor, scissorCount, pScissors);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetScissor(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstScissor, scissorCount, pScissors);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdSetLineWidth:
            {
                VkCommandBuffer commandBuffer;
                float lineWidth;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_285;
                vkReadStream->read((uint64_t*)&cgen_var_285, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_285, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((float*)&lineWidth, sizeof(float));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetLineWidth 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)lineWidth);
                }
                vk->vkCmdSetLineWidth(unboxed_commandBuffer, lineWidth);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetLineWidth(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, lineWidth);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdSetDepthBias:
            {
                VkCommandBuffer commandBuffer;
                float depthBiasConstantFactor;
                float depthBiasClamp;
                float depthBiasSlopeFactor;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_286;
                vkReadStream->read((uint64_t*)&cgen_var_286, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_286, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((float*)&depthBiasConstantFactor, sizeof(float));
                vkReadStream->read((float*)&depthBiasClamp, sizeof(float));
                vkReadStream->read((float*)&depthBiasSlopeFactor, sizeof(float));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetDepthBias 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)depthBiasConstantFactor, (unsigned long long)depthBiasClamp, (unsigned long long)depthBiasSlopeFactor);
                }
                vk->vkCmdSetDepthBias(unboxed_commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDepthBias(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdSetBlendConstants:
            {
                VkCommandBuffer commandBuffer;
                float blendConstants[4];
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_287;
                vkReadStream->read((uint64_t*)&cgen_var_287, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_287, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((float*)blendConstants, 4 * sizeof(const float));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetBlendConstants 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)blendConstants);
                }
                vk->vkCmdSetBlendConstants(unboxed_commandBuffer, blendConstants);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetBlendConstants(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, blendConstants);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdSetDepthBounds:
            {
                VkCommandBuffer commandBuffer;
                float minDepthBounds;
                float maxDepthBounds;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_288;
                vkReadStream->read((uint64_t*)&cgen_var_288, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_288, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((float*)&minDepthBounds, sizeof(float));
                vkReadStream->read((float*)&maxDepthBounds, sizeof(float));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetDepthBounds 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)minDepthBounds, (unsigned long long)maxDepthBounds);
                }
                vk->vkCmdSetDepthBounds(unboxed_commandBuffer, minDepthBounds, maxDepthBounds);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDepthBounds(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, minDepthBounds, maxDepthBounds);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdSetStencilCompareMask:
            {
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t compareMask;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_289;
                vkReadStream->read((uint64_t*)&cgen_var_289, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_289, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
                vkReadStream->read((uint32_t*)&compareMask, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetStencilCompareMask 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)faceMask, (unsigned long long)compareMask);
                }
                vk->vkCmdSetStencilCompareMask(unboxed_commandBuffer, faceMask, compareMask);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetStencilCompareMask(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, faceMask, compareMask);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdSetStencilWriteMask:
            {
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t writeMask;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_290;
                vkReadStream->read((uint64_t*)&cgen_var_290, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_290, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
                vkReadStream->read((uint32_t*)&writeMask, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetStencilWriteMask 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)faceMask, (unsigned long long)writeMask);
                }
                vk->vkCmdSetStencilWriteMask(unboxed_commandBuffer, faceMask, writeMask);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetStencilWriteMask(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, faceMask, writeMask);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdSetStencilReference:
            {
                VkCommandBuffer commandBuffer;
                VkStencilFaceFlags faceMask;
                uint32_t reference;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_291;
                vkReadStream->read((uint64_t*)&cgen_var_291, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_291, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkStencilFaceFlags*)&faceMask, sizeof(VkStencilFaceFlags));
                vkReadStream->read((uint32_t*)&reference, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetStencilReference 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)faceMask, (unsigned long long)reference);
                }
                vk->vkCmdSetStencilReference(unboxed_commandBuffer, faceMask, reference);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetStencilReference(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, faceMask, reference);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdBindDescriptorSets:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipelineLayout layout;
                uint32_t firstSet;
                uint32_t descriptorSetCount;
                const VkDescriptorSet* pDescriptorSets;
                uint32_t dynamicOffsetCount;
                const uint32_t* pDynamicOffsets;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_292;
                vkReadStream->read((uint64_t*)&cgen_var_292, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_292, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
                uint64_t cgen_var_293;
                vkReadStream->read((uint64_t*)&cgen_var_293, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_293, (VkPipelineLayout*)&layout, 1);
                vkReadStream->read((uint32_t*)&firstSet, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&descriptorSetCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorSets, ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
                if (((descriptorSetCount)))
                {
                    uint64_t* cgen_var_294;
                    vkReadStream->alloc((void**)&cgen_var_294, ((descriptorSetCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_294, ((descriptorSetCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(cgen_var_294, (VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)));
                }
                vkReadStream->read((uint32_t*)&dynamicOffsetCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
                vkReadStream->read((uint32_t*)pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(const uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdBindDescriptorSets 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineBindPoint, (unsigned long long)layout, (unsigned long long)firstSet, (unsigned long long)descriptorSetCount, (unsigned long long)pDescriptorSets, (unsigned long long)dynamicOffsetCount, (unsigned long long)pDynamicOffsets);
                }
                m_state->on_vkCmdBindDescriptorSets(&m_pool, commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindDescriptorSets(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdBindIndexBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkIndexType indexType;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_295;
                vkReadStream->read((uint64_t*)&cgen_var_295, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_295, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_296;
                vkReadStream->read((uint64_t*)&cgen_var_296, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_296, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((VkIndexType*)&indexType, sizeof(VkIndexType));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdBindIndexBuffer 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)indexType);
                }
                vk->vkCmdBindIndexBuffer(unboxed_commandBuffer, buffer, offset, indexType);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindIndexBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, indexType);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdBindVertexBuffers:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstBinding;
                uint32_t bindingCount;
                const VkBuffer* pBuffers;
                const VkDeviceSize* pOffsets;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_297;
                vkReadStream->read((uint64_t*)&cgen_var_297, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_297, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&firstBinding, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&bindingCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
                if (((bindingCount)))
                {
                    uint64_t* cgen_var_298;
                    vkReadStream->alloc((void**)&cgen_var_298, ((bindingCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_298, ((bindingCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(cgen_var_298, (VkBuffer*)pBuffers, ((bindingCount)));
                }
                vkReadStream->alloc((void**)&pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)pOffsets, ((bindingCount)) * sizeof(const VkDeviceSize));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdBindVertexBuffers 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstBinding, (unsigned long long)bindingCount, (unsigned long long)pBuffers, (unsigned long long)pOffsets);
                }
                vk->vkCmdBindVertexBuffers(unboxed_commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBindVertexBuffers(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdDraw:
            {
                VkCommandBuffer commandBuffer;
                uint32_t vertexCount;
                uint32_t instanceCount;
                uint32_t firstVertex;
                uint32_t firstInstance;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_299;
                vkReadStream->read((uint64_t*)&cgen_var_299, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_299, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&vertexCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&instanceCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&firstVertex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&firstInstance, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdDraw 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)vertexCount, (unsigned long long)instanceCount, (unsigned long long)firstVertex, (unsigned long long)firstInstance);
                }
                vk->vkCmdDraw(unboxed_commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDraw(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdDrawIndexed:
            {
                VkCommandBuffer commandBuffer;
                uint32_t indexCount;
                uint32_t instanceCount;
                uint32_t firstIndex;
                int32_t vertexOffset;
                uint32_t firstInstance;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_300;
                vkReadStream->read((uint64_t*)&cgen_var_300, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_300, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&indexCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&instanceCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&firstIndex, sizeof(uint32_t));
                vkReadStream->read((int32_t*)&vertexOffset, sizeof(int32_t));
                vkReadStream->read((uint32_t*)&firstInstance, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdDrawIndexed 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)indexCount, (unsigned long long)instanceCount, (unsigned long long)firstIndex, (unsigned long long)vertexOffset, (unsigned long long)firstInstance);
                }
                vk->vkCmdDrawIndexed(unboxed_commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndexed(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdDrawIndirect:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                uint32_t drawCount;
                uint32_t stride;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_301;
                vkReadStream->read((uint64_t*)&cgen_var_301, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_301, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_302;
                vkReadStream->read((uint64_t*)&cgen_var_302, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_302, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&drawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdDrawIndirect 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)drawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndirect(unboxed_commandBuffer, buffer, offset, drawCount, stride);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndirect(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, drawCount, stride);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdDrawIndexedIndirect:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                uint32_t drawCount;
                uint32_t stride;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_303;
                vkReadStream->read((uint64_t*)&cgen_var_303, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_303, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_304;
                vkReadStream->read((uint64_t*)&cgen_var_304, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_304, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&drawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdDrawIndexedIndirect 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)drawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndexedIndirect(unboxed_commandBuffer, buffer, offset, drawCount, stride);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndexedIndirect(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, drawCount, stride);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdDispatch:
            {
                VkCommandBuffer commandBuffer;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_305;
                vkReadStream->read((uint64_t*)&cgen_var_305, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_305, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&groupCountX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountZ, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdDispatch 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)groupCountX, (unsigned long long)groupCountY, (unsigned long long)groupCountZ);
                }
                vk->vkCmdDispatch(unboxed_commandBuffer, groupCountX, groupCountY, groupCountZ);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDispatch(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, groupCountX, groupCountY, groupCountZ);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdDispatchIndirect:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_306;
                vkReadStream->read((uint64_t*)&cgen_var_306, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_306, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_307;
                vkReadStream->read((uint64_t*)&cgen_var_307, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_307, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdDispatchIndirect 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset);
                }
                vk->vkCmdDispatchIndirect(unboxed_commandBuffer, buffer, offset);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDispatchIndirect(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdCopyBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer srcBuffer;
                VkBuffer dstBuffer;
                uint32_t regionCount;
                const VkBufferCopy* pRegions;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_308;
                vkReadStream->read((uint64_t*)&cgen_var_308, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_308, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_309;
                vkReadStream->read((uint64_t*)&cgen_var_309, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_309, (VkBuffer*)&srcBuffer, 1);
                uint64_t cgen_var_310;
                vkReadStream->read((uint64_t*)&cgen_var_310, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_310, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkBufferCopy(vkReadStream, (VkBufferCopy*)(pRegions + i));
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkBufferCopy(m_state, (VkBufferCopy*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdCopyBuffer 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcBuffer, (unsigned long long)dstBuffer, (unsigned long long)regionCount, (unsigned long long)pRegions);
                }
                vk->vkCmdCopyBuffer(unboxed_commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdCopyImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageCopy* pRegions;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_311;
                vkReadStream->read((uint64_t*)&cgen_var_311, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_311, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_312;
                vkReadStream->read((uint64_t*)&cgen_var_312, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_312, (VkImage*)&srcImage, 1);
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                uint64_t cgen_var_313;
                vkReadStream->read((uint64_t*)&cgen_var_313, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_313, (VkImage*)&dstImage, 1);
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkImageCopy(vkReadStream, (VkImageCopy*)(pRegions + i));
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkImageCopy(m_state, (VkImageCopy*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdCopyImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcImage, (unsigned long long)srcImageLayout, (unsigned long long)dstImage, (unsigned long long)dstImageLayout, (unsigned long long)regionCount, (unsigned long long)pRegions);
                }
                m_state->on_vkCmdCopyImage(&m_pool, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdBlitImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageBlit* pRegions;
                VkFilter filter;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_314;
                vkReadStream->read((uint64_t*)&cgen_var_314, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_314, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_315;
                vkReadStream->read((uint64_t*)&cgen_var_315, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_315, (VkImage*)&srcImage, 1);
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                uint64_t cgen_var_316;
                vkReadStream->read((uint64_t*)&cgen_var_316, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_316, (VkImage*)&dstImage, 1);
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageBlit));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkImageBlit(vkReadStream, (VkImageBlit*)(pRegions + i));
                }
                vkReadStream->read((VkFilter*)&filter, sizeof(VkFilter));
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkImageBlit(m_state, (VkImageBlit*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdBlitImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcImage, (unsigned long long)srcImageLayout, (unsigned long long)dstImage, (unsigned long long)dstImageLayout, (unsigned long long)regionCount, (unsigned long long)pRegions, (unsigned long long)filter);
                }
                vk->vkCmdBlitImage(unboxed_commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBlitImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdCopyBufferToImage:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer srcBuffer;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkBufferImageCopy* pRegions;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_317;
                vkReadStream->read((uint64_t*)&cgen_var_317, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_317, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_318;
                vkReadStream->read((uint64_t*)&cgen_var_318, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_318, (VkBuffer*)&srcBuffer, 1);
                uint64_t cgen_var_319;
                vkReadStream->read((uint64_t*)&cgen_var_319, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_319, (VkImage*)&dstImage, 1);
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkBufferImageCopy(vkReadStream, (VkBufferImageCopy*)(pRegions + i));
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkBufferImageCopy(m_state, (VkBufferImageCopy*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdCopyBufferToImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcBuffer, (unsigned long long)dstImage, (unsigned long long)dstImageLayout, (unsigned long long)regionCount, (unsigned long long)pRegions);
                }
                m_state->on_vkCmdCopyBufferToImage(&m_pool, commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyBufferToImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdCopyImageToBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkBuffer dstBuffer;
                uint32_t regionCount;
                const VkBufferImageCopy* pRegions;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_320;
                vkReadStream->read((uint64_t*)&cgen_var_320, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_320, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_321;
                vkReadStream->read((uint64_t*)&cgen_var_321, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_321, (VkImage*)&srcImage, 1);
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                uint64_t cgen_var_322;
                vkReadStream->read((uint64_t*)&cgen_var_322, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_322, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkBufferImageCopy));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkBufferImageCopy(vkReadStream, (VkBufferImageCopy*)(pRegions + i));
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkBufferImageCopy(m_state, (VkBufferImageCopy*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdCopyImageToBuffer 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcImage, (unsigned long long)srcImageLayout, (unsigned long long)dstBuffer, (unsigned long long)regionCount, (unsigned long long)pRegions);
                }
                m_state->on_vkCmdCopyImageToBuffer(&m_pool, commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyImageToBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdUpdateBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize dataSize;
                const void* pData;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_323;
                vkReadStream->read((uint64_t*)&cgen_var_323, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_323, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_324;
                vkReadStream->read((uint64_t*)&cgen_var_324, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_324, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&dataSize, sizeof(VkDeviceSize));
                vkReadStream->alloc((void**)&pData, ((dataSize)) * sizeof(const uint8_t));
                vkReadStream->read((void*)pData, ((dataSize)) * sizeof(const uint8_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdUpdateBuffer 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)dstBuffer, (unsigned long long)dstOffset, (unsigned long long)dataSize, (unsigned long long)pData);
                }
                vk->vkCmdUpdateBuffer(unboxed_commandBuffer, dstBuffer, dstOffset, dataSize, pData);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdUpdateBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, dstBuffer, dstOffset, dataSize, pData);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdFillBuffer:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize size;
                uint32_t data;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_325;
                vkReadStream->read((uint64_t*)&cgen_var_325, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_325, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_326;
                vkReadStream->read((uint64_t*)&cgen_var_326, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_326, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&size, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&data, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdFillBuffer 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)dstBuffer, (unsigned long long)dstOffset, (unsigned long long)size, (unsigned long long)data);
                }
                vk->vkCmdFillBuffer(unboxed_commandBuffer, dstBuffer, dstOffset, size, data);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdFillBuffer(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, dstBuffer, dstOffset, size, data);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdClearColorImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage image;
                VkImageLayout imageLayout;
                const VkClearColorValue* pColor;
                uint32_t rangeCount;
                const VkImageSubresourceRange* pRanges;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_327;
                vkReadStream->read((uint64_t*)&cgen_var_327, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_327, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_328;
                vkReadStream->read((uint64_t*)&cgen_var_328, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_328, (VkImage*)&image, 1);
                vkReadStream->read((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
                vkReadStream->alloc((void**)&pColor, sizeof(const VkClearColorValue));
                unmarshal_VkClearColorValue(vkReadStream, (VkClearColorValue*)(pColor));
                vkReadStream->read((uint32_t*)&rangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRanges, ((rangeCount)) * sizeof(const VkImageSubresourceRange));
                for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                {
                    unmarshal_VkImageSubresourceRange(vkReadStream, (VkImageSubresourceRange*)(pRanges + i));
                }
                if (pColor)
                {
                    transform_tohost_VkClearColorValue(m_state, (VkClearColorValue*)(pColor));
                }
                if (pRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                    {
                        transform_tohost_VkImageSubresourceRange(m_state, (VkImageSubresourceRange*)(pRanges + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdClearColorImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)image, (unsigned long long)imageLayout, (unsigned long long)pColor, (unsigned long long)rangeCount, (unsigned long long)pRanges);
                }
                vk->vkCmdClearColorImage(unboxed_commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdClearColorImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdClearDepthStencilImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage image;
                VkImageLayout imageLayout;
                const VkClearDepthStencilValue* pDepthStencil;
                uint32_t rangeCount;
                const VkImageSubresourceRange* pRanges;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_329;
                vkReadStream->read((uint64_t*)&cgen_var_329, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_329, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_330;
                vkReadStream->read((uint64_t*)&cgen_var_330, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_330, (VkImage*)&image, 1);
                vkReadStream->read((VkImageLayout*)&imageLayout, sizeof(VkImageLayout));
                vkReadStream->alloc((void**)&pDepthStencil, sizeof(const VkClearDepthStencilValue));
                unmarshal_VkClearDepthStencilValue(vkReadStream, (VkClearDepthStencilValue*)(pDepthStencil));
                vkReadStream->read((uint32_t*)&rangeCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRanges, ((rangeCount)) * sizeof(const VkImageSubresourceRange));
                for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                {
                    unmarshal_VkImageSubresourceRange(vkReadStream, (VkImageSubresourceRange*)(pRanges + i));
                }
                if (pDepthStencil)
                {
                    transform_tohost_VkClearDepthStencilValue(m_state, (VkClearDepthStencilValue*)(pDepthStencil));
                }
                if (pRanges)
                {
                    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
                    {
                        transform_tohost_VkImageSubresourceRange(m_state, (VkImageSubresourceRange*)(pRanges + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdClearDepthStencilImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)image, (unsigned long long)imageLayout, (unsigned long long)pDepthStencil, (unsigned long long)rangeCount, (unsigned long long)pRanges);
                }
                vk->vkCmdClearDepthStencilImage(unboxed_commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdClearDepthStencilImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdClearAttachments:
            {
                VkCommandBuffer commandBuffer;
                uint32_t attachmentCount;
                const VkClearAttachment* pAttachments;
                uint32_t rectCount;
                const VkClearRect* pRects;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_331;
                vkReadStream->read((uint64_t*)&cgen_var_331, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_331, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&attachmentCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pAttachments, ((attachmentCount)) * sizeof(const VkClearAttachment));
                for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
                {
                    unmarshal_VkClearAttachment(vkReadStream, (VkClearAttachment*)(pAttachments + i));
                }
                vkReadStream->read((uint32_t*)&rectCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRects, ((rectCount)) * sizeof(const VkClearRect));
                for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
                {
                    unmarshal_VkClearRect(vkReadStream, (VkClearRect*)(pRects + i));
                }
                if (pAttachments)
                {
                    for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
                    {
                        transform_tohost_VkClearAttachment(m_state, (VkClearAttachment*)(pAttachments + i));
                    }
                }
                if (pRects)
                {
                    for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
                    {
                        transform_tohost_VkClearRect(m_state, (VkClearRect*)(pRects + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdClearAttachments 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)attachmentCount, (unsigned long long)pAttachments, (unsigned long long)rectCount, (unsigned long long)pRects);
                }
                vk->vkCmdClearAttachments(unboxed_commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdClearAttachments(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdResolveImage:
            {
                VkCommandBuffer commandBuffer;
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageResolve* pRegions;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_332;
                vkReadStream->read((uint64_t*)&cgen_var_332, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_332, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_333;
                vkReadStream->read((uint64_t*)&cgen_var_333, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_333, (VkImage*)&srcImage, 1);
                vkReadStream->read((VkImageLayout*)&srcImageLayout, sizeof(VkImageLayout));
                uint64_t cgen_var_334;
                vkReadStream->read((uint64_t*)&cgen_var_334, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_334, (VkImage*)&dstImage, 1);
                vkReadStream->read((VkImageLayout*)&dstImageLayout, sizeof(VkImageLayout));
                vkReadStream->read((uint32_t*)&regionCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pRegions, ((regionCount)) * sizeof(const VkImageResolve));
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                {
                    unmarshal_VkImageResolve(vkReadStream, (VkImageResolve*)(pRegions + i));
                }
                if (pRegions)
                {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
                    {
                        transform_tohost_VkImageResolve(m_state, (VkImageResolve*)(pRegions + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdResolveImage 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcImage, (unsigned long long)srcImageLayout, (unsigned long long)dstImage, (unsigned long long)dstImageLayout, (unsigned long long)regionCount, (unsigned long long)pRegions);
                }
                vk->vkCmdResolveImage(unboxed_commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdResolveImage(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdSetEvent:
            {
                VkCommandBuffer commandBuffer;
                VkEvent event;
                VkPipelineStageFlags stageMask;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_335;
                vkReadStream->read((uint64_t*)&cgen_var_335, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_335, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_336;
                vkReadStream->read((uint64_t*)&cgen_var_336, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_336, (VkEvent*)&event, 1);
                vkReadStream->read((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetEvent 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)event, (unsigned long long)stageMask);
                }
                vk->vkCmdSetEvent(unboxed_commandBuffer, event, stageMask);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, event, stageMask);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdResetEvent:
            {
                VkCommandBuffer commandBuffer;
                VkEvent event;
                VkPipelineStageFlags stageMask;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_337;
                vkReadStream->read((uint64_t*)&cgen_var_337, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_337, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_338;
                vkReadStream->read((uint64_t*)&cgen_var_338, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_338, (VkEvent*)&event, 1);
                vkReadStream->read((VkPipelineStageFlags*)&stageMask, sizeof(VkPipelineStageFlags));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdResetEvent 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)event, (unsigned long long)stageMask);
                }
                vk->vkCmdResetEvent(unboxed_commandBuffer, event, stageMask);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdResetEvent(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, event, stageMask);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdWaitEvents:
            {
                VkCommandBuffer commandBuffer;
                uint32_t eventCount;
                const VkEvent* pEvents;
                VkPipelineStageFlags srcStageMask;
                VkPipelineStageFlags dstStageMask;
                uint32_t memoryBarrierCount;
                const VkMemoryBarrier* pMemoryBarriers;
                uint32_t bufferMemoryBarrierCount;
                const VkBufferMemoryBarrier* pBufferMemoryBarriers;
                uint32_t imageMemoryBarrierCount;
                const VkImageMemoryBarrier* pImageMemoryBarriers;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_339;
                vkReadStream->read((uint64_t*)&cgen_var_339, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_339, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&eventCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pEvents, ((eventCount)) * sizeof(const VkEvent));
                if (((eventCount)))
                {
                    uint64_t* cgen_var_340;
                    vkReadStream->alloc((void**)&cgen_var_340, ((eventCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_340, ((eventCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkEvent(cgen_var_340, (VkEvent*)pEvents, ((eventCount)));
                }
                vkReadStream->read((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryBarriers, ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                {
                    unmarshal_VkMemoryBarrier(vkReadStream, (VkMemoryBarrier*)(pMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBufferMemoryBarriers, ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkBufferMemoryBarrier(vkReadStream, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pImageMemoryBarriers, ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkImageMemoryBarrier(vkReadStream, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                }
                if (pMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkMemoryBarrier(m_state, (VkMemoryBarrier*)(pMemoryBarriers + i));
                    }
                }
                if (pBufferMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkBufferMemoryBarrier(m_state, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                    }
                }
                if (pImageMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkImageMemoryBarrier(m_state, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdWaitEvents 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)eventCount, (unsigned long long)pEvents, (unsigned long long)srcStageMask, (unsigned long long)dstStageMask, (unsigned long long)memoryBarrierCount, (unsigned long long)pMemoryBarriers, (unsigned long long)bufferMemoryBarrierCount, (unsigned long long)pBufferMemoryBarriers, (unsigned long long)imageMemoryBarrierCount, (unsigned long long)pImageMemoryBarriers);
                }
                vk->vkCmdWaitEvents(unboxed_commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdWaitEvents(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdPipelineBarrier:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlags srcStageMask;
                VkPipelineStageFlags dstStageMask;
                VkDependencyFlags dependencyFlags;
                uint32_t memoryBarrierCount;
                const VkMemoryBarrier* pMemoryBarriers;
                uint32_t bufferMemoryBarrierCount;
                const VkBufferMemoryBarrier* pBufferMemoryBarriers;
                uint32_t imageMemoryBarrierCount;
                const VkImageMemoryBarrier* pImageMemoryBarriers;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_341;
                vkReadStream->read((uint64_t*)&cgen_var_341, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_341, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkPipelineStageFlags*)&srcStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((VkPipelineStageFlags*)&dstStageMask, sizeof(VkPipelineStageFlags));
                vkReadStream->read((VkDependencyFlags*)&dependencyFlags, sizeof(VkDependencyFlags));
                vkReadStream->read((uint32_t*)&memoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pMemoryBarriers, ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                {
                    unmarshal_VkMemoryBarrier(vkReadStream, (VkMemoryBarrier*)(pMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&bufferMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBufferMemoryBarriers, ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkBufferMemoryBarrier(vkReadStream, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                }
                vkReadStream->read((uint32_t*)&imageMemoryBarrierCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pImageMemoryBarriers, ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
                for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                {
                    unmarshal_VkImageMemoryBarrier(vkReadStream, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                }
                if (pMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkMemoryBarrier(m_state, (VkMemoryBarrier*)(pMemoryBarriers + i));
                    }
                }
                if (pBufferMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkBufferMemoryBarrier(m_state, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                    }
                }
                if (pImageMemoryBarriers)
                {
                    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
                    {
                        transform_tohost_VkImageMemoryBarrier(m_state, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdPipelineBarrier 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)srcStageMask, (unsigned long long)dstStageMask, (unsigned long long)dependencyFlags, (unsigned long long)memoryBarrierCount, (unsigned long long)pMemoryBarriers, (unsigned long long)bufferMemoryBarrierCount, (unsigned long long)pBufferMemoryBarriers, (unsigned long long)imageMemoryBarrierCount, (unsigned long long)pImageMemoryBarriers);
                }
                m_state->on_vkCmdPipelineBarrier(&m_pool, commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdPipelineBarrier(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdBeginQuery:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t query;
                VkQueryControlFlags flags;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_342;
                vkReadStream->read((uint64_t*)&cgen_var_342, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_342, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_343;
                vkReadStream->read((uint64_t*)&cgen_var_343, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_343, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&query, sizeof(uint32_t));
                vkReadStream->read((VkQueryControlFlags*)&flags, sizeof(VkQueryControlFlags));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdBeginQuery 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool, (unsigned long long)query, (unsigned long long)flags);
                }
                vk->vkCmdBeginQuery(unboxed_commandBuffer, queryPool, query, flags);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginQuery(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool, query, flags);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdEndQuery:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t query;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_344;
                vkReadStream->read((uint64_t*)&cgen_var_344, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_344, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_345;
                vkReadStream->read((uint64_t*)&cgen_var_345, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_345, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&query, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdEndQuery 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool, (unsigned long long)query);
                }
                vk->vkCmdEndQuery(unboxed_commandBuffer, queryPool, query);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndQuery(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool, query);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdResetQueryPool:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_346;
                vkReadStream->read((uint64_t*)&cgen_var_346, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_346, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_347;
                vkReadStream->read((uint64_t*)&cgen_var_347, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_347, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&firstQuery, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queryCount, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdResetQueryPool 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool, (unsigned long long)firstQuery, (unsigned long long)queryCount);
                }
                vk->vkCmdResetQueryPool(unboxed_commandBuffer, queryPool, firstQuery, queryCount);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdResetQueryPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool, firstQuery, queryCount);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdWriteTimestamp:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlagBits pipelineStage;
                VkQueryPool queryPool;
                uint32_t query;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_348;
                vkReadStream->read((uint64_t*)&cgen_var_348, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_348, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
                uint64_t cgen_var_349;
                vkReadStream->read((uint64_t*)&cgen_var_349, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_349, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&query, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdWriteTimestamp 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineStage, (unsigned long long)queryPool, (unsigned long long)query);
                }
                vk->vkCmdWriteTimestamp(unboxed_commandBuffer, pipelineStage, queryPool, query);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdWriteTimestamp(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineStage, queryPool, query);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdCopyQueryPoolResults:
            {
                VkCommandBuffer commandBuffer;
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize stride;
                VkQueryResultFlags flags;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_350;
                vkReadStream->read((uint64_t*)&cgen_var_350, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_350, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_351;
                vkReadStream->read((uint64_t*)&cgen_var_351, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_351, (VkQueryPool*)&queryPool, 1);
                vkReadStream->read((uint32_t*)&firstQuery, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&queryCount, sizeof(uint32_t));
                uint64_t cgen_var_352;
                vkReadStream->read((uint64_t*)&cgen_var_352, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_352, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((VkDeviceSize*)&stride, sizeof(VkDeviceSize));
                vkReadStream->read((VkQueryResultFlags*)&flags, sizeof(VkQueryResultFlags));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdCopyQueryPoolResults 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)queryPool, (unsigned long long)firstQuery, (unsigned long long)queryCount, (unsigned long long)dstBuffer, (unsigned long long)dstOffset, (unsigned long long)stride, (unsigned long long)flags);
                }
                vk->vkCmdCopyQueryPoolResults(unboxed_commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdCopyQueryPoolResults(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdPushConstants:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineLayout layout;
                VkShaderStageFlags stageFlags;
                uint32_t offset;
                uint32_t size;
                const void* pValues;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_353;
                vkReadStream->read((uint64_t*)&cgen_var_353, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_353, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_354;
                vkReadStream->read((uint64_t*)&cgen_var_354, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_354, (VkPipelineLayout*)&layout, 1);
                vkReadStream->read((VkShaderStageFlags*)&stageFlags, sizeof(VkShaderStageFlags));
                vkReadStream->read((uint32_t*)&offset, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&size, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pValues, ((size)) * sizeof(const uint8_t));
                vkReadStream->read((void*)pValues, ((size)) * sizeof(const uint8_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdPushConstants 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)layout, (unsigned long long)stageFlags, (unsigned long long)offset, (unsigned long long)size, (unsigned long long)pValues);
                }
                vk->vkCmdPushConstants(unboxed_commandBuffer, layout, stageFlags, offset, size, pValues);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdPushConstants(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, layout, stageFlags, offset, size, pValues);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdBeginRenderPass:
            {
                VkCommandBuffer commandBuffer;
                const VkRenderPassBeginInfo* pRenderPassBegin;
                VkSubpassContents contents;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_355;
                vkReadStream->read((uint64_t*)&cgen_var_355, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_355, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                unmarshal_VkRenderPassBeginInfo(vkReadStream, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                vkReadStream->read((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
                if (pRenderPassBegin)
                {
                    transform_tohost_VkRenderPassBeginInfo(m_state, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdBeginRenderPass 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pRenderPassBegin, (unsigned long long)contents);
                }
                vk->vkCmdBeginRenderPass(unboxed_commandBuffer, pRenderPassBegin, contents);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginRenderPass(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pRenderPassBegin, contents);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdNextSubpass:
            {
                VkCommandBuffer commandBuffer;
                VkSubpassContents contents;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_356;
                vkReadStream->read((uint64_t*)&cgen_var_356, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_356, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkSubpassContents*)&contents, sizeof(VkSubpassContents));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdNextSubpass 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)contents);
                }
                vk->vkCmdNextSubpass(unboxed_commandBuffer, contents);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdNextSubpass(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, contents);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdEndRenderPass:
            {
                VkCommandBuffer commandBuffer;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_357;
                vkReadStream->read((uint64_t*)&cgen_var_357, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_357, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdEndRenderPass 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                vk->vkCmdEndRenderPass(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndRenderPass(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdExecuteCommands:
            {
                VkCommandBuffer commandBuffer;
                uint32_t commandBufferCount;
                const VkCommandBuffer* pCommandBuffers;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_358;
                vkReadStream->read((uint64_t*)&cgen_var_358, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_358, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&commandBufferCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCommandBuffers, ((commandBufferCount)) * sizeof(const VkCommandBuffer));
                if (((commandBufferCount)))
                {
                    uint64_t* cgen_var_359;
                    vkReadStream->alloc((void**)&cgen_var_359, ((commandBufferCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_359, ((commandBufferCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(cgen_var_359, (VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdExecuteCommands 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)commandBufferCount, (unsigned long long)pCommandBuffers);
                }
                m_state->on_vkCmdExecuteCommands(&m_pool, commandBuffer, commandBufferCount, pCommandBuffers);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdExecuteCommands(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, commandBufferCount, pCommandBuffers);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_VERSION_1_1
            case OP_vkEnumerateInstanceVersion:
            {
                uint32_t* pApiVersion;
                // Begin manual dispatchable handle unboxing for pApiVersion;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pApiVersion, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)pApiVersion, sizeof(uint32_t));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pApiVersion;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkEnumerateInstanceVersion 0x%llx \n", ioStream, (unsigned long long)pApiVersion);
                }
                VkResult vkEnumerateInstanceVersion_VkResult_return = (VkResult)0;
                vkEnumerateInstanceVersion_VkResult_return = m_state->on_vkEnumerateInstanceVersion(&m_pool, pApiVersion);
                vkStream->unsetHandleMapping();
                vkStream->write((uint32_t*)pApiVersion, sizeof(uint32_t));
                vkStream->write(&vkEnumerateInstanceVersion_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumerateInstanceVersion(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumerateInstanceVersion_VkResult_return, pApiVersion);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkBindBufferMemory2:
            {
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindBufferMemoryInfo* pBindInfos;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_360;
                vkReadStream->read((uint64_t*)&cgen_var_360, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_360, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindBufferMemoryInfo(vkReadStream, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindBufferMemoryInfo(m_state, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkBindBufferMemory2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfos);
                }
                VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
                vkBindBufferMemory2_VkResult_return = m_state->on_vkBindBufferMemory2(&m_pool, device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindBufferMemory2_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindBufferMemory2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindBufferMemory2_VkResult_return, device, bindInfoCount, pBindInfos);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkBindImageMemory2:
            {
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindImageMemoryInfo* pBindInfos;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_361;
                vkReadStream->read((uint64_t*)&cgen_var_361, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_361, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindImageMemoryInfo(vkReadStream, (VkBindImageMemoryInfo*)(pBindInfos + i));
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindImageMemoryInfo(m_state, (VkBindImageMemoryInfo*)(pBindInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkBindImageMemory2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfos);
                }
                VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
                vkBindImageMemory2_VkResult_return = vk->vkBindImageMemory2(unboxed_device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindImageMemory2_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindImageMemory2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindImageMemory2_VkResult_return, device, bindInfoCount, pBindInfos);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetDeviceGroupPeerMemoryFeatures:
            {
                VkDevice device;
                uint32_t heapIndex;
                uint32_t localDeviceIndex;
                uint32_t remoteDeviceIndex;
                VkPeerMemoryFeatureFlags* pPeerMemoryFeatures;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_362;
                vkReadStream->read((uint64_t*)&cgen_var_362, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_362, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&heapIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for pPeerMemoryFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPeerMemoryFeatures;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetDeviceGroupPeerMemoryFeatures 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)heapIndex, (unsigned long long)localDeviceIndex, (unsigned long long)remoteDeviceIndex, (unsigned long long)pPeerMemoryFeatures);
                }
                vk->vkGetDeviceGroupPeerMemoryFeatures(unboxed_device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                vkStream->unsetHandleMapping();
                vkStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceGroupPeerMemoryFeatures(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdSetDeviceMask:
            {
                VkCommandBuffer commandBuffer;
                uint32_t deviceMask;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_363;
                vkReadStream->read((uint64_t*)&cgen_var_363, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_363, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&deviceMask, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetDeviceMask 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)deviceMask);
                }
                vk->vkCmdSetDeviceMask(unboxed_commandBuffer, deviceMask);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDeviceMask(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, deviceMask);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdDispatchBase:
            {
                VkCommandBuffer commandBuffer;
                uint32_t baseGroupX;
                uint32_t baseGroupY;
                uint32_t baseGroupZ;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_364;
                vkReadStream->read((uint64_t*)&cgen_var_364, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_364, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&baseGroupX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupZ, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountZ, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdDispatchBase 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)baseGroupX, (unsigned long long)baseGroupY, (unsigned long long)baseGroupZ, (unsigned long long)groupCountX, (unsigned long long)groupCountY, (unsigned long long)groupCountZ);
                }
                vk->vkCmdDispatchBase(unboxed_commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDispatchBase(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkEnumeratePhysicalDeviceGroups:
            {
                VkInstance instance;
                uint32_t* pPhysicalDeviceGroupCount;
                VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_365;
                vkReadStream->read((uint64_t*)&cgen_var_365, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_365, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPhysicalDeviceGroupCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDeviceGroupCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPhysicalDeviceGroupCount;
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPhysicalDeviceGroupProperties = (VkPhysicalDeviceGroupProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDeviceGroupProperties)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupProperties, (*(pPhysicalDeviceGroupCount)) * sizeof(VkPhysicalDeviceGroupProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        unmarshal_VkPhysicalDeviceGroupProperties(vkReadStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPhysicalDeviceGroupProperties;
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        transform_tohost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkEnumeratePhysicalDeviceGroups 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pPhysicalDeviceGroupCount, (unsigned long long)pPhysicalDeviceGroupProperties);
                }
                VkResult vkEnumeratePhysicalDeviceGroups_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDeviceGroups_VkResult_return = vk->vkEnumeratePhysicalDeviceGroups(unboxed_instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_368 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
                vkStream->putBe64(cgen_var_368);
                if (pPhysicalDeviceGroupCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        transform_fromhost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_369 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
                vkStream->putBe64(cgen_var_369);
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        marshal_VkPhysicalDeviceGroupProperties(vkStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDeviceGroups_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumeratePhysicalDeviceGroups(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumeratePhysicalDeviceGroups_VkResult_return, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetImageMemoryRequirements2:
            {
                VkDevice device;
                const VkImageMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_370;
                vkReadStream->read((uint64_t*)&cgen_var_370, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_370, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
                unmarshal_VkImageMemoryRequirementsInfo2(vkReadStream, (VkImageMemoryRequirementsInfo2*)(pInfo));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryRequirements;
                if (pInfo)
                {
                    transform_tohost_VkImageMemoryRequirementsInfo2(m_state, (VkImageMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetImageMemoryRequirements2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pMemoryRequirements);
                }
                m_state->on_vkGetImageMemoryRequirements2(&m_pool, device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageMemoryRequirements2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pMemoryRequirements);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetBufferMemoryRequirements2:
            {
                VkDevice device;
                const VkBufferMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_371;
                vkReadStream->read((uint64_t*)&cgen_var_371, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_371, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
                unmarshal_VkBufferMemoryRequirementsInfo2(vkReadStream, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryRequirements;
                if (pInfo)
                {
                    transform_tohost_VkBufferMemoryRequirementsInfo2(m_state, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetBufferMemoryRequirements2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pMemoryRequirements);
                }
                vk->vkGetBufferMemoryRequirements2(unboxed_device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetBufferMemoryRequirements2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pMemoryRequirements);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements2:
            {
                VkDevice device;
                const VkImageSparseMemoryRequirementsInfo2* pInfo;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_372;
                vkReadStream->read((uint64_t*)&cgen_var_372, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_372, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageSparseMemoryRequirementsInfo2));
                unmarshal_VkImageSparseMemoryRequirementsInfo2(vkReadStream, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        unmarshal_VkSparseImageMemoryRequirements2(vkReadStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSparseMemoryRequirements;
                if (pInfo)
                {
                    transform_tohost_VkImageSparseMemoryRequirementsInfo2(m_state, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_tohost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetImageSparseMemoryRequirements2 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pSparseMemoryRequirementCount, (unsigned long long)pSparseMemoryRequirements);
                }
                vk->vkGetImageSparseMemoryRequirements2(unboxed_device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_375 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
                vkStream->putBe64(cgen_var_375);
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_376 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
                vkStream->putBe64(cgen_var_376);
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        marshal_VkSparseImageMemoryRequirements2(vkStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageSparseMemoryRequirements2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceFeatures2:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures2* pFeatures;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_377;
                vkReadStream->read((uint64_t*)&cgen_var_377, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_377, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures2));
                unmarshal_VkPhysicalDeviceFeatures2(vkReadStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFeatures;
                if (pFeatures)
                {
                    transform_tohost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceFeatures2 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFeatures);
                }
                m_state->on_vkGetPhysicalDeviceFeatures2(&m_pool, physicalDevice, pFeatures);
                vkStream->unsetHandleMapping();
                if (pFeatures)
                {
                    transform_fromhost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                marshal_VkPhysicalDeviceFeatures2(vkStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFeatures2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFeatures);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceProperties2:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties2* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_378;
                vkReadStream->read((uint64_t*)&cgen_var_378, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_378, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties2));
                unmarshal_VkPhysicalDeviceProperties2(vkReadStream, (VkPhysicalDeviceProperties2*)(pProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    transform_tohost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceProperties2 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pProperties);
                }
                m_state->on_vkGetPhysicalDeviceProperties2(&m_pool, physicalDevice, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                marshal_VkPhysicalDeviceProperties2(vkStream, (VkPhysicalDeviceProperties2*)(pProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties2:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties2* pFormatProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_379;
                vkReadStream->read((uint64_t*)&cgen_var_379, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_379, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                // Begin manual dispatchable handle unboxing for pFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties2));
                unmarshal_VkFormatProperties2(vkReadStream, (VkFormatProperties2*)(pFormatProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFormatProperties;
                if (pFormatProperties)
                {
                    transform_tohost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceFormatProperties2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)pFormatProperties);
                }
                m_state->on_vkGetPhysicalDeviceFormatProperties2(&m_pool, physicalDevice, format, pFormatProperties);
                vkStream->unsetHandleMapping();
                if (pFormatProperties)
                {
                    transform_fromhost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                marshal_VkFormatProperties2(vkStream, (VkFormatProperties2*)(pFormatProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFormatProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format, pFormatProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties2:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo;
                VkImageFormatProperties2* pImageFormatProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_380;
                vkReadStream->read((uint64_t*)&cgen_var_380, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_380, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pImageFormatInfo, sizeof(const VkPhysicalDeviceImageFormatInfo2));
                unmarshal_VkPhysicalDeviceImageFormatInfo2(vkReadStream, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                // Begin manual dispatchable handle unboxing for pImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties2));
                unmarshal_VkImageFormatProperties2(vkReadStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pImageFormatProperties;
                if (pImageFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceImageFormatInfo2(m_state, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                }
                if (pImageFormatProperties)
                {
                    transform_tohost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceImageFormatProperties2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pImageFormatInfo, (unsigned long long)pImageFormatProperties);
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = m_state->on_vkGetPhysicalDeviceImageFormatProperties2(&m_pool, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pImageFormatProperties)
                {
                    transform_fromhost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                marshal_VkImageFormatProperties2(vkStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceImageFormatProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties2:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties2* pQueueFamilyProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_381;
                vkReadStream->read((uint64_t*)&cgen_var_381, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_381, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                // Begin manual dispatchable handle unboxing for pQueueFamilyProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pQueueFamilyProperties = (VkQueueFamilyProperties2*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        unmarshal_VkQueueFamilyProperties2(vkReadStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueueFamilyProperties;
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_tohost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceQueueFamilyProperties2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pQueueFamilyPropertyCount, (unsigned long long)pQueueFamilyProperties);
                }
                vk->vkGetPhysicalDeviceQueueFamilyProperties2(unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_384 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
                vkStream->putBe64(cgen_var_384);
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_fromhost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_385 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
                vkStream->putBe64(cgen_var_385);
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        marshal_VkQueueFamilyProperties2(vkStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties2:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties2* pMemoryProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_386;
                vkReadStream->read((uint64_t*)&cgen_var_386, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_386, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pMemoryProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties2));
                unmarshal_VkPhysicalDeviceMemoryProperties2(vkReadStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryProperties;
                if (pMemoryProperties)
                {
                    transform_tohost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceMemoryProperties2 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pMemoryProperties);
                }
                m_state->on_vkGetPhysicalDeviceMemoryProperties2(&m_pool, physicalDevice, pMemoryProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryProperties)
                {
                    transform_fromhost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                marshal_VkPhysicalDeviceMemoryProperties2(vkStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceMemoryProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pMemoryProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties2:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties2* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_387;
                vkReadStream->read((uint64_t*)&cgen_var_387, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_387, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pFormatInfo, sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
                unmarshal_VkPhysicalDeviceSparseImageFormatInfo2(vkReadStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkSparseImageFormatProperties2*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkSparseImageFormatProperties2(vkReadStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(m_state, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceSparseImageFormatProperties2 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFormatInfo, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                vk->vkGetPhysicalDeviceSparseImageFormatProperties2(unboxed_physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_390 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_390);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_391 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_391);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkSparseImageFormatProperties2(vkStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSparseImageFormatProperties2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkTrimCommandPool:
            {
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolTrimFlags flags;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_392;
                vkReadStream->read((uint64_t*)&cgen_var_392, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_392, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_393;
                vkReadStream->read((uint64_t*)&cgen_var_393, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_393, (VkCommandPool*)&commandPool, 1);
                vkReadStream->read((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkTrimCommandPool 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)commandPool, (unsigned long long)flags);
                }
                vk->vkTrimCommandPool(unboxed_device, commandPool, flags);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkTrimCommandPool(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, commandPool, flags);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetDeviceQueue2:
            {
                VkDevice device;
                const VkDeviceQueueInfo2* pQueueInfo;
                VkQueue* pQueue;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_394;
                vkReadStream->read((uint64_t*)&cgen_var_394, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_394, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pQueueInfo, sizeof(const VkDeviceQueueInfo2));
                unmarshal_VkDeviceQueueInfo2(vkReadStream, (VkDeviceQueueInfo2*)(pQueueInfo));
                // Begin manual dispatchable handle unboxing for pQueue;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pQueue, sizeof(VkQueue));
                uint64_t cgen_var_395;
                vkReadStream->read((uint64_t*)&cgen_var_395, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_395, (VkQueue*)pQueue, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueue;
                if (pQueueInfo)
                {
                    transform_tohost_VkDeviceQueueInfo2(m_state, (VkDeviceQueueInfo2*)(pQueueInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetDeviceQueue2 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pQueueInfo, (unsigned long long)pQueue);
                }
                vk->vkGetDeviceQueue2(unboxed_device, pQueueInfo, pQueue);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_396;
                vkStream->handleMapping()->mapHandles_VkQueue_u64(pQueue, &cgen_var_396, 1);
                vkStream->write((uint64_t*)&cgen_var_396, 8);
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceQueue2(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pQueueInfo, pQueue);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateSamplerYcbcrConversion:
            {
                VkDevice device;
                const VkSamplerYcbcrConversionCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSamplerYcbcrConversion* pYcbcrConversion;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_397;
                vkReadStream->read((uint64_t*)&cgen_var_397, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_397, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerYcbcrConversionCreateInfo));
                unmarshal_VkSamplerYcbcrConversionCreateInfo(vkReadStream, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pYcbcrConversion;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                uint64_t cgen_var_399;
                vkReadStream->read((uint64_t*)&cgen_var_399, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_399, (VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pYcbcrConversion;
                if (pCreateInfo)
                {
                    transform_tohost_VkSamplerYcbcrConversionCreateInfo(m_state, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateSamplerYcbcrConversion 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pYcbcrConversion);
                }
                VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
                vkCreateSamplerYcbcrConversion_VkResult_return = vk->vkCreateSamplerYcbcrConversion(unboxed_device, pCreateInfo, pAllocator, pYcbcrConversion);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                if (vkCreateSamplerYcbcrConversion_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_400;
                static_assert(8 == sizeof(VkSamplerYcbcrConversion), "handle map overwrite requres VkSamplerYcbcrConversion to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
                vkStream->write((VkSamplerYcbcrConversion*)pYcbcrConversion, 8 * 1);
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSamplerYcbcrConversion_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSamplerYcbcrConversion(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSamplerYcbcrConversion_VkResult_return, device, pCreateInfo, pAllocator, pYcbcrConversion);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroySamplerYcbcrConversion:
            {
                VkDevice device;
                VkSamplerYcbcrConversion ycbcrConversion;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_401;
                vkReadStream->read((uint64_t*)&cgen_var_401, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_401, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for ycbcrConversion;
                VkSamplerYcbcrConversion* boxed_ycbcrConversion_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_ycbcrConversion_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_402;
                vkReadStream->read((uint64_t*)&cgen_var_402, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_402, (VkSamplerYcbcrConversion*)&ycbcrConversion, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for ycbcrConversion;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroySamplerYcbcrConversion 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)ycbcrConversion, (unsigned long long)pAllocator);
                }
                vk->vkDestroySamplerYcbcrConversion(unboxed_device, ycbcrConversion, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySamplerYcbcrConversion(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_ycbcrConversion_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateDescriptorUpdateTemplate:
            {
                VkDevice device;
                const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_404;
                vkReadStream->read((uint64_t*)&cgen_var_404, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_404, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorUpdateTemplateCreateInfo));
                unmarshal_VkDescriptorUpdateTemplateCreateInfo(vkReadStream, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pDescriptorUpdateTemplate;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                uint64_t cgen_var_406;
                vkReadStream->read((uint64_t*)&cgen_var_406, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_406, (VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDescriptorUpdateTemplate;
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorUpdateTemplateCreateInfo(m_state, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateDescriptorUpdateTemplate 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pDescriptorUpdateTemplate);
                }
                VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
                vkCreateDescriptorUpdateTemplate_VkResult_return = m_state->on_vkCreateDescriptorUpdateTemplate(&m_pool, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_407;
                static_assert(8 == sizeof(VkDescriptorUpdateTemplate), "handle map overwrite requres VkDescriptorUpdateTemplate to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
                vkStream->write((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 8 * 1);
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorUpdateTemplate_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDescriptorUpdateTemplate(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDescriptorUpdateTemplate_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyDescriptorUpdateTemplate:
            {
                VkDevice device;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_408;
                vkReadStream->read((uint64_t*)&cgen_var_408, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_408, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for descriptorUpdateTemplate;
                VkDescriptorUpdateTemplate* boxed_descriptorUpdateTemplate_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_descriptorUpdateTemplate_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_409;
                vkReadStream->read((uint64_t*)&cgen_var_409, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_409, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for descriptorUpdateTemplate;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyDescriptorUpdateTemplate 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyDescriptorUpdateTemplate(&m_pool, device, descriptorUpdateTemplate, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDescriptorUpdateTemplate(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_descriptorUpdateTemplate_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkUpdateDescriptorSetWithTemplate:
            {
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const void* pData;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_411;
                vkReadStream->read((uint64_t*)&cgen_var_411, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_411, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_412;
                vkReadStream->read((uint64_t*)&cgen_var_412, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(&cgen_var_412, (VkDescriptorSet*)&descriptorSet, 1);
                uint64_t cgen_var_413;
                vkReadStream->read((uint64_t*)&cgen_var_413, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_413, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                // WARNING PTR CHECK
                pData = (const void*)(uintptr_t)vkReadStream->getBe64();
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    vkReadStream->read((void*)pData, sizeof(const uint8_t));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkUpdateDescriptorSetWithTemplate 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorSet, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)pData);
                }
                vk->vkUpdateDescriptorSetWithTemplate(unboxed_device, descriptorSet, descriptorUpdateTemplate, pData);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUpdateDescriptorSetWithTemplate(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorSet, descriptorUpdateTemplate, pData);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceExternalBufferProperties:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo;
                VkExternalBufferProperties* pExternalBufferProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_415;
                vkReadStream->read((uint64_t*)&cgen_var_415, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_415, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalBufferInfo, sizeof(const VkPhysicalDeviceExternalBufferInfo));
                unmarshal_VkPhysicalDeviceExternalBufferInfo(vkReadStream, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                // Begin manual dispatchable handle unboxing for pExternalBufferProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalBufferProperties, sizeof(VkExternalBufferProperties));
                unmarshal_VkExternalBufferProperties(vkReadStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pExternalBufferProperties;
                if (pExternalBufferInfo)
                {
                    m_state->transformImpl_VkPhysicalDeviceExternalBufferInfo_tohost(pExternalBufferInfo, 1);
                    transform_tohost_VkPhysicalDeviceExternalBufferInfo(m_state, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                }
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_tohost(pExternalBufferProperties, 1);
                    transform_tohost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceExternalBufferProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalBufferInfo, (unsigned long long)pExternalBufferProperties);
                }
                vk->vkGetPhysicalDeviceExternalBufferProperties(unboxed_physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                vkStream->unsetHandleMapping();
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_fromhost(pExternalBufferProperties, 1);
                    transform_fromhost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                marshal_VkExternalBufferProperties(vkStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalBufferProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceExternalFenceProperties:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo;
                VkExternalFenceProperties* pExternalFenceProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_416;
                vkReadStream->read((uint64_t*)&cgen_var_416, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_416, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalFenceInfo, sizeof(const VkPhysicalDeviceExternalFenceInfo));
                unmarshal_VkPhysicalDeviceExternalFenceInfo(vkReadStream, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                // Begin manual dispatchable handle unboxing for pExternalFenceProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalFenceProperties, sizeof(VkExternalFenceProperties));
                unmarshal_VkExternalFenceProperties(vkReadStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pExternalFenceProperties;
                if (pExternalFenceInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalFenceInfo(m_state, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                }
                if (pExternalFenceProperties)
                {
                    transform_tohost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceExternalFenceProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalFenceInfo, (unsigned long long)pExternalFenceProperties);
                }
                vk->vkGetPhysicalDeviceExternalFenceProperties(unboxed_physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                vkStream->unsetHandleMapping();
                if (pExternalFenceProperties)
                {
                    transform_fromhost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                marshal_VkExternalFenceProperties(vkStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalFenceProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceExternalSemaphoreProperties:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo;
                VkExternalSemaphoreProperties* pExternalSemaphoreProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_417;
                vkReadStream->read((uint64_t*)&cgen_var_417, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_417, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalSemaphoreInfo, sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
                unmarshal_VkPhysicalDeviceExternalSemaphoreInfo(vkReadStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                // Begin manual dispatchable handle unboxing for pExternalSemaphoreProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalSemaphoreProperties, sizeof(VkExternalSemaphoreProperties));
                unmarshal_VkExternalSemaphoreProperties(vkReadStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pExternalSemaphoreProperties;
                if (pExternalSemaphoreInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(m_state, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                }
                if (pExternalSemaphoreProperties)
                {
                    transform_tohost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceExternalSemaphoreProperties 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalSemaphoreInfo, (unsigned long long)pExternalSemaphoreProperties);
                }
                m_state->on_vkGetPhysicalDeviceExternalSemaphoreProperties(&m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                vkStream->unsetHandleMapping();
                if (pExternalSemaphoreProperties)
                {
                    transform_fromhost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                marshal_VkExternalSemaphoreProperties(vkStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalSemaphoreProperties(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetDescriptorSetLayoutSupport:
            {
                VkDevice device;
                const VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                VkDescriptorSetLayoutSupport* pSupport;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_418;
                vkReadStream->read((uint64_t*)&cgen_var_418, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_418, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                unmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                // Begin manual dispatchable handle unboxing for pSupport;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSupport, sizeof(VkDescriptorSetLayoutSupport));
                unmarshal_VkDescriptorSetLayoutSupport(vkReadStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSupport;
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorSetLayoutCreateInfo(m_state, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                }
                if (pSupport)
                {
                    transform_tohost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetDescriptorSetLayoutSupport 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pSupport);
                }
                vk->vkGetDescriptorSetLayoutSupport(unboxed_device, pCreateInfo, pSupport);
                vkStream->unsetHandleMapping();
                if (pSupport)
                {
                    transform_fromhost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                marshal_VkDescriptorSetLayoutSupport(vkStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDescriptorSetLayoutSupport(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pCreateInfo, pSupport);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_surface
            case OP_vkDestroySurfaceKHR:
            {
                VkInstance instance;
                VkSurfaceKHR surface;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_419;
                vkReadStream->read((uint64_t*)&cgen_var_419, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_419, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual non dispatchable handle destroy unboxing for surface;
                VkSurfaceKHR* boxed_surface_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_surface_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_420;
                vkReadStream->read((uint64_t*)&cgen_var_420, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_420, (VkSurfaceKHR*)&surface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for surface;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroySurfaceKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)surface, (unsigned long long)pAllocator);
                }
                vk->vkDestroySurfaceKHR(unboxed_instance, surface, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, *boxed_surface_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                VkSurfaceKHR surface;
                VkBool32* pSupported;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_422;
                vkReadStream->read((uint64_t*)&cgen_var_422, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_422, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                uint64_t cgen_var_423;
                vkReadStream->read((uint64_t*)&cgen_var_423, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_423, (VkSurfaceKHR*)&surface, 1);
                // Begin manual dispatchable handle unboxing for pSupported;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSupported, sizeof(VkBool32));
                vkReadStream->read((VkBool32*)pSupported, sizeof(VkBool32));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSupported;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceSurfaceSupportKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex, (unsigned long long)surface, (unsigned long long)pSupported);
                }
                VkResult vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceSupportKHR(unboxed_physicalDevice, queueFamilyIndex, surface, pSupported);
                vkStream->unsetHandleMapping();
                vkStream->write((VkBool32*)pSupported, sizeof(VkBool32));
                vkStream->write(&vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, physicalDevice, queueFamilyIndex, surface, pSupported);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                VkSurfaceCapabilitiesKHR* pSurfaceCapabilities;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_424;
                vkReadStream->read((uint64_t*)&cgen_var_424, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_424, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_425;
                vkReadStream->read((uint64_t*)&cgen_var_425, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_425, (VkSurfaceKHR*)&surface, 1);
                // Begin manual dispatchable handle unboxing for pSurfaceCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilitiesKHR));
                unmarshal_VkSurfaceCapabilitiesKHR(vkReadStream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurfaceCapabilities;
                if (pSurfaceCapabilities)
                {
                    transform_tohost_VkSurfaceCapabilitiesKHR(m_state, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceSurfaceCapabilitiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)surface, (unsigned long long)pSurfaceCapabilities);
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceCapabilitiesKHR(unboxed_physicalDevice, surface, pSurfaceCapabilities);
                vkStream->unsetHandleMapping();
                if (pSurfaceCapabilities)
                {
                    transform_fromhost_VkSurfaceCapabilitiesKHR(m_state, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                }
                marshal_VkSurfaceCapabilitiesKHR(vkStream, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceCapabilitiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, physicalDevice, surface, pSurfaceCapabilities);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceFormatsKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pSurfaceFormatCount;
                VkSurfaceFormatKHR* pSurfaceFormats;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_426;
                vkReadStream->read((uint64_t*)&cgen_var_426, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_426, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_427;
                vkReadStream->read((uint64_t*)&cgen_var_427, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_427, (VkSurfaceKHR*)&surface, 1);
                // Begin manual dispatchable handle unboxing for pSurfaceFormatCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSurfaceFormatCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSurfaceFormatCount)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormatCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurfaceFormatCount;
                // Begin manual dispatchable handle unboxing for pSurfaceFormats;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSurfaceFormats = (VkSurfaceFormatKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pSurfaceFormats)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormats, (*(pSurfaceFormatCount)) * sizeof(VkSurfaceFormatKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        unmarshal_VkSurfaceFormatKHR(vkReadStream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurfaceFormats;
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        transform_tohost_VkSurfaceFormatKHR(m_state, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceSurfaceFormatsKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)surface, (unsigned long long)pSurfaceFormatCount, (unsigned long long)pSurfaceFormats);
                }
                VkResult vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceFormatsKHR(unboxed_physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_430 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
                vkStream->putBe64(cgen_var_430);
                if (pSurfaceFormatCount)
                {
                    vkStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        transform_fromhost_VkSurfaceFormatKHR(m_state, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_431 = (uint64_t)(uintptr_t)pSurfaceFormats;
                vkStream->putBe64(cgen_var_431);
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        marshal_VkSurfaceFormatKHR(vkStream, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceFormatsKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfacePresentModesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pPresentModeCount;
                VkPresentModeKHR* pPresentModes;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_432;
                vkReadStream->read((uint64_t*)&cgen_var_432, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_432, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_433;
                vkReadStream->read((uint64_t*)&cgen_var_433, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_433, (VkSurfaceKHR*)&surface, 1);
                // Begin manual dispatchable handle unboxing for pPresentModeCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPresentModeCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPresentModeCount)
                {
                    vkReadStream->alloc((void**)&pPresentModeCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPresentModeCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPresentModeCount;
                // Begin manual dispatchable handle unboxing for pPresentModes;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPresentModes = (VkPresentModeKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pPresentModes)
                {
                    vkReadStream->alloc((void**)&pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                    vkReadStream->read((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPresentModes;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceSurfacePresentModesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)surface, (unsigned long long)pPresentModeCount, (unsigned long long)pPresentModes);
                }
                VkResult vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = vk->vkGetPhysicalDeviceSurfacePresentModesKHR(unboxed_physicalDevice, surface, pPresentModeCount, pPresentModes);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_436 = (uint64_t)(uintptr_t)pPresentModeCount;
                vkStream->putBe64(cgen_var_436);
                if (pPresentModeCount)
                {
                    vkStream->write((uint32_t*)pPresentModeCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_437 = (uint64_t)(uintptr_t)pPresentModes;
                vkStream->putBe64(cgen_var_437);
                if (pPresentModes)
                {
                    vkStream->write((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
                }
                vkStream->write(&vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfacePresentModesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, physicalDevice, surface, pPresentModeCount, pPresentModes);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_swapchain
            case OP_vkCreateSwapchainKHR:
            {
                VkDevice device;
                const VkSwapchainCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSwapchainKHR* pSwapchain;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_438;
                vkReadStream->read((uint64_t*)&cgen_var_438, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_438, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSwapchainCreateInfoKHR));
                unmarshal_VkSwapchainCreateInfoKHR(vkReadStream, (VkSwapchainCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSwapchain;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSwapchain, sizeof(VkSwapchainKHR));
                uint64_t cgen_var_440;
                vkReadStream->read((uint64_t*)&cgen_var_440, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_440, (VkSwapchainKHR*)pSwapchain, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSwapchain;
                if (pCreateInfo)
                {
                    transform_tohost_VkSwapchainCreateInfoKHR(m_state, (VkSwapchainCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateSwapchainKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSwapchain);
                }
                VkResult vkCreateSwapchainKHR_VkResult_return = (VkResult)0;
                vkCreateSwapchainKHR_VkResult_return = vk->vkCreateSwapchainKHR(unboxed_device, pCreateInfo, pAllocator, pSwapchain);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pSwapchain;
                if (vkCreateSwapchainKHR_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_441;
                static_assert(8 == sizeof(VkSwapchainKHR), "handle map overwrite requres VkSwapchainKHR to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)pSwapchain, 1);
                vkStream->write((VkSwapchainKHR*)pSwapchain, 8 * 1);
                // Begin auto non dispatchable handle create for pSwapchain;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSwapchainKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSwapchainKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSwapchainKHR_VkResult_return, device, pCreateInfo, pAllocator, pSwapchain);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroySwapchainKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_442;
                vkReadStream->read((uint64_t*)&cgen_var_442, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_442, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for swapchain;
                VkSwapchainKHR* boxed_swapchain_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_swapchain_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_443;
                vkReadStream->read((uint64_t*)&cgen_var_443, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_443, (VkSwapchainKHR*)&swapchain, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for swapchain;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroySwapchainKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)pAllocator);
                }
                vk->vkDestroySwapchainKHR(unboxed_device, swapchain, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySwapchainKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_swapchain_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetSwapchainImagesKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint32_t* pSwapchainImageCount;
                VkImage* pSwapchainImages;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_445;
                vkReadStream->read((uint64_t*)&cgen_var_445, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_445, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_446;
                vkReadStream->read((uint64_t*)&cgen_var_446, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_446, (VkSwapchainKHR*)&swapchain, 1);
                // Begin manual dispatchable handle unboxing for pSwapchainImageCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSwapchainImageCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSwapchainImageCount)
                {
                    vkReadStream->alloc((void**)&pSwapchainImageCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSwapchainImageCount;
                // Begin manual dispatchable handle unboxing for pSwapchainImages;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSwapchainImages = (VkImage*)(uintptr_t)vkReadStream->getBe64();
                if (pSwapchainImages)
                {
                    vkReadStream->alloc((void**)&pSwapchainImages, (*(pSwapchainImageCount)) * sizeof(VkImage));
                    if ((*(pSwapchainImageCount)))
                    {
                        uint64_t* cgen_var_449;
                        vkReadStream->alloc((void**)&cgen_var_449, (*(pSwapchainImageCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_449, (*(pSwapchainImageCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkImage(cgen_var_449, (VkImage*)pSwapchainImages, (*(pSwapchainImageCount)));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSwapchainImages;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetSwapchainImagesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)pSwapchainImageCount, (unsigned long long)pSwapchainImages);
                }
                VkResult vkGetSwapchainImagesKHR_VkResult_return = (VkResult)0;
                vkGetSwapchainImagesKHR_VkResult_return = vk->vkGetSwapchainImagesKHR(unboxed_device, swapchain, pSwapchainImageCount, pSwapchainImages);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_450 = (uint64_t)(uintptr_t)pSwapchainImageCount;
                vkStream->putBe64(cgen_var_450);
                if (pSwapchainImageCount)
                {
                    vkStream->write((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_451 = (uint64_t)(uintptr_t)pSwapchainImages;
                vkStream->putBe64(cgen_var_451);
                if (pSwapchainImages)
                {
                    if ((*(pSwapchainImageCount)))
                    {
                        uint64_t* cgen_var_452;
                        vkStream->alloc((void**)&cgen_var_452, (*(pSwapchainImageCount)) * 8);
                        vkStream->handleMapping()->mapHandles_VkImage_u64(pSwapchainImages, cgen_var_452, (*(pSwapchainImageCount)));
                        vkStream->write((uint64_t*)cgen_var_452, (*(pSwapchainImageCount)) * 8);
                    }
                }
                vkStream->write(&vkGetSwapchainImagesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSwapchainImagesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSwapchainImagesKHR_VkResult_return, device, swapchain, pSwapchainImageCount, pSwapchainImages);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkAcquireNextImageKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint64_t timeout;
                VkSemaphore semaphore;
                VkFence fence;
                uint32_t* pImageIndex;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_453;
                vkReadStream->read((uint64_t*)&cgen_var_453, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_453, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_454;
                vkReadStream->read((uint64_t*)&cgen_var_454, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_454, (VkSwapchainKHR*)&swapchain, 1);
                vkReadStream->read((uint64_t*)&timeout, sizeof(uint64_t));
                uint64_t cgen_var_455;
                vkReadStream->read((uint64_t*)&cgen_var_455, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_455, (VkSemaphore*)&semaphore, 1);
                uint64_t cgen_var_456;
                vkReadStream->read((uint64_t*)&cgen_var_456, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_456, (VkFence*)&fence, 1);
                // Begin manual dispatchable handle unboxing for pImageIndex;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pImageIndex;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkAcquireNextImageKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)timeout, (unsigned long long)semaphore, (unsigned long long)fence, (unsigned long long)pImageIndex);
                }
                VkResult vkAcquireNextImageKHR_VkResult_return = (VkResult)0;
                vkAcquireNextImageKHR_VkResult_return = vk->vkAcquireNextImageKHR(unboxed_device, swapchain, timeout, semaphore, fence, pImageIndex);
                vkStream->unsetHandleMapping();
                vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkStream->write(&vkAcquireNextImageKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAcquireNextImageKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAcquireNextImageKHR_VkResult_return, device, swapchain, timeout, semaphore, fence, pImageIndex);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkQueuePresentKHR:
            {
                VkQueue queue;
                const VkPresentInfoKHR* pPresentInfo;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_457;
                vkReadStream->read((uint64_t*)&cgen_var_457, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_457, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->alloc((void**)&pPresentInfo, sizeof(const VkPresentInfoKHR));
                unmarshal_VkPresentInfoKHR(vkReadStream, (VkPresentInfoKHR*)(pPresentInfo));
                if (pPresentInfo)
                {
                    transform_tohost_VkPresentInfoKHR(m_state, (VkPresentInfoKHR*)(pPresentInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkQueuePresentKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)pPresentInfo);
                }
                VkResult vkQueuePresentKHR_VkResult_return = (VkResult)0;
                vkQueuePresentKHR_VkResult_return = vk->vkQueuePresentKHR(unboxed_queue, pPresentInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkQueuePresentKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueuePresentKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueuePresentKHR_VkResult_return, queue, pPresentInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetDeviceGroupPresentCapabilitiesKHR:
            {
                VkDevice device;
                VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_458;
                vkReadStream->read((uint64_t*)&cgen_var_458, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_458, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual dispatchable handle unboxing for pDeviceGroupPresentCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDeviceGroupPresentCapabilities, sizeof(VkDeviceGroupPresentCapabilitiesKHR));
                unmarshal_VkDeviceGroupPresentCapabilitiesKHR(vkReadStream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDeviceGroupPresentCapabilities;
                if (pDeviceGroupPresentCapabilities)
                {
                    transform_tohost_VkDeviceGroupPresentCapabilitiesKHR(m_state, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetDeviceGroupPresentCapabilitiesKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pDeviceGroupPresentCapabilities);
                }
                VkResult vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = vk->vkGetDeviceGroupPresentCapabilitiesKHR(unboxed_device, pDeviceGroupPresentCapabilities);
                vkStream->unsetHandleMapping();
                if (pDeviceGroupPresentCapabilities)
                {
                    transform_fromhost_VkDeviceGroupPresentCapabilitiesKHR(m_state, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                }
                marshal_VkDeviceGroupPresentCapabilitiesKHR(vkStream, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
                vkStream->write(&vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceGroupPresentCapabilitiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, device, pDeviceGroupPresentCapabilities);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetDeviceGroupSurfacePresentModesKHR:
            {
                VkDevice device;
                VkSurfaceKHR surface;
                VkDeviceGroupPresentModeFlagsKHR* pModes;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_459;
                vkReadStream->read((uint64_t*)&cgen_var_459, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_459, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_460;
                vkReadStream->read((uint64_t*)&cgen_var_460, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_460, (VkSurfaceKHR*)&surface, 1);
                // Begin manual dispatchable handle unboxing for pModes;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pModes = (VkDeviceGroupPresentModeFlagsKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pModes)
                {
                    vkReadStream->alloc((void**)&pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                    vkReadStream->read((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pModes;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetDeviceGroupSurfacePresentModesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)surface, (unsigned long long)pModes);
                }
                VkResult vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = (VkResult)0;
                vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = vk->vkGetDeviceGroupSurfacePresentModesKHR(unboxed_device, surface, pModes);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_462 = (uint64_t)(uintptr_t)pModes;
                vkStream->putBe64(cgen_var_462);
                if (pModes)
                {
                    vkStream->write((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
                }
                vkStream->write(&vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceGroupSurfacePresentModesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, device, surface, pModes);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDevicePresentRectanglesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                uint32_t* pRectCount;
                VkRect2D* pRects;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_463;
                vkReadStream->read((uint64_t*)&cgen_var_463, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_463, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_464;
                vkReadStream->read((uint64_t*)&cgen_var_464, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_464, (VkSurfaceKHR*)&surface, 1);
                // Begin manual dispatchable handle unboxing for pRectCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pRectCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pRectCount)
                {
                    vkReadStream->alloc((void**)&pRectCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pRectCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pRectCount;
                // Begin manual dispatchable handle unboxing for pRects;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pRects = (VkRect2D*)(uintptr_t)vkReadStream->getBe64();
                if (pRects)
                {
                    vkReadStream->alloc((void**)&pRects, (*(pRectCount)) * sizeof(VkRect2D));
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        unmarshal_VkRect2D(vkReadStream, (VkRect2D*)(pRects + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pRects;
                if (pRects)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        transform_tohost_VkRect2D(m_state, (VkRect2D*)(pRects + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDevicePresentRectanglesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)surface, (unsigned long long)pRectCount, (unsigned long long)pRects);
                }
                VkResult vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = vk->vkGetPhysicalDevicePresentRectanglesKHR(unboxed_physicalDevice, surface, pRectCount, pRects);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_467 = (uint64_t)(uintptr_t)pRectCount;
                vkStream->putBe64(cgen_var_467);
                if (pRectCount)
                {
                    vkStream->write((uint32_t*)pRectCount, sizeof(uint32_t));
                }
                if (pRects)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        transform_fromhost_VkRect2D(m_state, (VkRect2D*)(pRects + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_468 = (uint64_t)(uintptr_t)pRects;
                vkStream->putBe64(cgen_var_468);
                if (pRects)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                    {
                        marshal_VkRect2D(vkStream, (VkRect2D*)(pRects + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDevicePresentRectanglesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, physicalDevice, surface, pRectCount, pRects);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkAcquireNextImage2KHR:
            {
                VkDevice device;
                const VkAcquireNextImageInfoKHR* pAcquireInfo;
                uint32_t* pImageIndex;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_469;
                vkReadStream->read((uint64_t*)&cgen_var_469, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_469, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pAcquireInfo, sizeof(const VkAcquireNextImageInfoKHR));
                unmarshal_VkAcquireNextImageInfoKHR(vkReadStream, (VkAcquireNextImageInfoKHR*)(pAcquireInfo));
                // Begin manual dispatchable handle unboxing for pImageIndex;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pImageIndex;
                if (pAcquireInfo)
                {
                    transform_tohost_VkAcquireNextImageInfoKHR(m_state, (VkAcquireNextImageInfoKHR*)(pAcquireInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkAcquireNextImage2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pAcquireInfo, (unsigned long long)pImageIndex);
                }
                VkResult vkAcquireNextImage2KHR_VkResult_return = (VkResult)0;
                vkAcquireNextImage2KHR_VkResult_return = vk->vkAcquireNextImage2KHR(unboxed_device, pAcquireInfo, pImageIndex);
                vkStream->unsetHandleMapping();
                vkStream->write((uint32_t*)pImageIndex, sizeof(uint32_t));
                vkStream->write(&vkAcquireNextImage2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAcquireNextImage2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAcquireNextImage2KHR_VkResult_return, device, pAcquireInfo, pImageIndex);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_display
            case OP_vkGetPhysicalDeviceDisplayPropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPropertiesKHR* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_470;
                vkReadStream->read((uint64_t*)&cgen_var_470, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_470, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkDisplayPropertiesKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayPropertiesKHR(vkReadStream, (VkDisplayPropertiesKHR*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayPropertiesKHR(m_state, (VkDisplayPropertiesKHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceDisplayPropertiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayPropertiesKHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_473 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_473);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayPropertiesKHR(m_state, (VkDisplayPropertiesKHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_474 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_474);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayPropertiesKHR(vkStream, (VkDisplayPropertiesKHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceDisplayPropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPlanePropertiesKHR* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_475;
                vkReadStream->read((uint64_t*)&cgen_var_475, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_475, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkDisplayPlanePropertiesKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPlanePropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayPlanePropertiesKHR(vkReadStream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayPlanePropertiesKHR(m_state, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceDisplayPlanePropertiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayPlanePropertiesKHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_478 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_478);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayPlanePropertiesKHR(m_state, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_479 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_479);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayPlanePropertiesKHR(vkStream, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceDisplayPlanePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetDisplayPlaneSupportedDisplaysKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t planeIndex;
                uint32_t* pDisplayCount;
                VkDisplayKHR* pDisplays;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_480;
                vkReadStream->read((uint64_t*)&cgen_var_480, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_480, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((uint32_t*)&planeIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for pDisplayCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pDisplayCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pDisplayCount)
                {
                    vkReadStream->alloc((void**)&pDisplayCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pDisplayCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDisplayCount;
                // Begin manual dispatchable handle unboxing for pDisplays;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pDisplays = (VkDisplayKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pDisplays)
                {
                    vkReadStream->alloc((void**)&pDisplays, (*(pDisplayCount)) * sizeof(VkDisplayKHR));
                    if ((*(pDisplayCount)))
                    {
                        uint64_t* cgen_var_483;
                        vkReadStream->alloc((void**)&cgen_var_483, (*(pDisplayCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_483, (*(pDisplayCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(cgen_var_483, (VkDisplayKHR*)pDisplays, (*(pDisplayCount)));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDisplays;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetDisplayPlaneSupportedDisplaysKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)planeIndex, (unsigned long long)pDisplayCount, (unsigned long long)pDisplays);
                }
                VkResult vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = vk->vkGetDisplayPlaneSupportedDisplaysKHR(unboxed_physicalDevice, planeIndex, pDisplayCount, pDisplays);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_484 = (uint64_t)(uintptr_t)pDisplayCount;
                vkStream->putBe64(cgen_var_484);
                if (pDisplayCount)
                {
                    vkStream->write((uint32_t*)pDisplayCount, sizeof(uint32_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_485 = (uint64_t)(uintptr_t)pDisplays;
                vkStream->putBe64(cgen_var_485);
                if (pDisplays)
                {
                    if ((*(pDisplayCount)))
                    {
                        uint64_t* cgen_var_486;
                        vkStream->alloc((void**)&cgen_var_486, (*(pDisplayCount)) * 8);
                        vkStream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplays, cgen_var_486, (*(pDisplayCount)));
                        vkStream->write((uint64_t*)cgen_var_486, (*(pDisplayCount)) * 8);
                    }
                }
                vkStream->write(&vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDisplayPlaneSupportedDisplaysKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, physicalDevice, planeIndex, pDisplayCount, pDisplays);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetDisplayModePropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                uint32_t* pPropertyCount;
                VkDisplayModePropertiesKHR* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_487;
                vkReadStream->read((uint64_t*)&cgen_var_487, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_487, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_488;
                vkReadStream->read((uint64_t*)&cgen_var_488, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_488, (VkDisplayKHR*)&display, 1);
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkDisplayModePropertiesKHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayModePropertiesKHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayModePropertiesKHR(vkReadStream, (VkDisplayModePropertiesKHR*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayModePropertiesKHR(m_state, (VkDisplayModePropertiesKHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetDisplayModePropertiesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)display, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetDisplayModePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetDisplayModePropertiesKHR_VkResult_return = vk->vkGetDisplayModePropertiesKHR(unboxed_physicalDevice, display, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_491 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_491);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayModePropertiesKHR(m_state, (VkDisplayModePropertiesKHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_492 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_492);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayModePropertiesKHR(vkStream, (VkDisplayModePropertiesKHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetDisplayModePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDisplayModePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDisplayModePropertiesKHR_VkResult_return, physicalDevice, display, pPropertyCount, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateDisplayModeKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                const VkDisplayModeCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDisplayModeKHR* pMode;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_493;
                vkReadStream->read((uint64_t*)&cgen_var_493, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_493, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_494;
                vkReadStream->read((uint64_t*)&cgen_var_494, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_494, (VkDisplayKHR*)&display, 1);
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDisplayModeCreateInfoKHR));
                unmarshal_VkDisplayModeCreateInfoKHR(vkReadStream, (VkDisplayModeCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pMode;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMode, sizeof(VkDisplayModeKHR));
                uint64_t cgen_var_496;
                vkReadStream->read((uint64_t*)&cgen_var_496, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_496, (VkDisplayModeKHR*)pMode, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMode;
                if (pCreateInfo)
                {
                    transform_tohost_VkDisplayModeCreateInfoKHR(m_state, (VkDisplayModeCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateDisplayModeKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)display, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pMode);
                }
                VkResult vkCreateDisplayModeKHR_VkResult_return = (VkResult)0;
                vkCreateDisplayModeKHR_VkResult_return = vk->vkCreateDisplayModeKHR(unboxed_physicalDevice, display, pCreateInfo, pAllocator, pMode);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pMode;
                if (vkCreateDisplayModeKHR_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_497;
                static_assert(8 == sizeof(VkDisplayModeKHR), "handle map overwrite requres VkDisplayModeKHR to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDisplayModeKHR((VkDisplayModeKHR*)pMode, 1);
                vkStream->write((VkDisplayModeKHR*)pMode, 8 * 1);
                // Begin auto non dispatchable handle create for pMode;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDisplayModeKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDisplayModeKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDisplayModeKHR_VkResult_return, physicalDevice, display, pCreateInfo, pAllocator, pMode);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetDisplayPlaneCapabilitiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayModeKHR mode;
                uint32_t planeIndex;
                VkDisplayPlaneCapabilitiesKHR* pCapabilities;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_498;
                vkReadStream->read((uint64_t*)&cgen_var_498, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_498, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_499;
                vkReadStream->read((uint64_t*)&cgen_var_499, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_499, (VkDisplayModeKHR*)&mode, 1);
                vkReadStream->read((uint32_t*)&planeIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for pCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCapabilities, sizeof(VkDisplayPlaneCapabilitiesKHR));
                unmarshal_VkDisplayPlaneCapabilitiesKHR(vkReadStream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCapabilities;
                if (pCapabilities)
                {
                    transform_tohost_VkDisplayPlaneCapabilitiesKHR(m_state, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetDisplayPlaneCapabilitiesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)mode, (unsigned long long)planeIndex, (unsigned long long)pCapabilities);
                }
                VkResult vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = vk->vkGetDisplayPlaneCapabilitiesKHR(unboxed_physicalDevice, mode, planeIndex, pCapabilities);
                vkStream->unsetHandleMapping();
                if (pCapabilities)
                {
                    transform_fromhost_VkDisplayPlaneCapabilitiesKHR(m_state, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                }
                marshal_VkDisplayPlaneCapabilitiesKHR(vkStream, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
                vkStream->write(&vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDisplayPlaneCapabilitiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, physicalDevice, mode, planeIndex, pCapabilities);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateDisplayPlaneSurfaceKHR:
            {
                VkInstance instance;
                const VkDisplaySurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_500;
                vkReadStream->read((uint64_t*)&cgen_var_500, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_500, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDisplaySurfaceCreateInfoKHR));
                unmarshal_VkDisplaySurfaceCreateInfoKHR(vkReadStream, (VkDisplaySurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_502;
                vkReadStream->read((uint64_t*)&cgen_var_502, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_502, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkDisplaySurfaceCreateInfoKHR(m_state, (VkDisplaySurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateDisplayPlaneSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateDisplayPlaneSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateDisplayPlaneSurfaceKHR_VkResult_return = vk->vkCreateDisplayPlaneSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_503;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_503, 1);
                vkStream->write((uint64_t*)&cgen_var_503, 8);
                vkStream->write(&vkCreateDisplayPlaneSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDisplayPlaneSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDisplayPlaneSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_display_swapchain
            case OP_vkCreateSharedSwapchainsKHR:
            {
                VkDevice device;
                uint32_t swapchainCount;
                const VkSwapchainCreateInfoKHR* pCreateInfos;
                const VkAllocationCallbacks* pAllocator;
                VkSwapchainKHR* pSwapchains;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_504;
                vkReadStream->read((uint64_t*)&cgen_var_504, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_504, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&swapchainCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pCreateInfos, ((swapchainCount)) * sizeof(const VkSwapchainCreateInfoKHR));
                for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                {
                    unmarshal_VkSwapchainCreateInfoKHR(vkReadStream, (VkSwapchainCreateInfoKHR*)(pCreateInfos + i));
                }
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSwapchains;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSwapchains, ((swapchainCount)) * sizeof(VkSwapchainKHR));
                if (((swapchainCount)))
                {
                    uint64_t* cgen_var_506;
                    vkReadStream->alloc((void**)&cgen_var_506, ((swapchainCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_506, ((swapchainCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(cgen_var_506, (VkSwapchainKHR*)pSwapchains, ((swapchainCount)));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSwapchains;
                if (pCreateInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                    {
                        transform_tohost_VkSwapchainCreateInfoKHR(m_state, (VkSwapchainCreateInfoKHR*)(pCreateInfos + i));
                    }
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateSharedSwapchainsKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchainCount, (unsigned long long)pCreateInfos, (unsigned long long)pAllocator, (unsigned long long)pSwapchains);
                }
                VkResult vkCreateSharedSwapchainsKHR_VkResult_return = (VkResult)0;
                vkCreateSharedSwapchainsKHR_VkResult_return = vk->vkCreateSharedSwapchainsKHR(unboxed_device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
                vkStream->unsetHandleMapping();
                if (((swapchainCount)))
                {
                    uint64_t* cgen_var_507;
                    vkStream->alloc((void**)&cgen_var_507, ((swapchainCount)) * 8);
                    vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(pSwapchains, cgen_var_507, ((swapchainCount)));
                    vkStream->write((uint64_t*)cgen_var_507, ((swapchainCount)) * 8);
                }
                vkStream->write(&vkCreateSharedSwapchainsKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSharedSwapchainsKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSharedSwapchainsKHR_VkResult_return, device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_xlib_surface
            case OP_vkCreateXlibSurfaceKHR:
            {
                VkInstance instance;
                const VkXlibSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_508;
                vkReadStream->read((uint64_t*)&cgen_var_508, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_508, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkXlibSurfaceCreateInfoKHR));
                unmarshal_VkXlibSurfaceCreateInfoKHR(vkReadStream, (VkXlibSurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_510;
                vkReadStream->read((uint64_t*)&cgen_var_510, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_510, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkXlibSurfaceCreateInfoKHR(m_state, (VkXlibSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateXlibSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateXlibSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateXlibSurfaceKHR_VkResult_return = vk->vkCreateXlibSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_511;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_511, 1);
                vkStream->write((uint64_t*)&cgen_var_511, 8);
                vkStream->write(&vkCreateXlibSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateXlibSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateXlibSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceXlibPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                Display* dpy;
                VisualID visualID;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_512;
                vkReadStream->read((uint64_t*)&cgen_var_512, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_512, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for dpy;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                vkReadStream->read((Display*)dpy, sizeof(Display));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for dpy;
                vkReadStream->read((VisualID*)&visualID, sizeof(VisualID));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceXlibPresentationSupportKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex, (unsigned long long)dpy, (unsigned long long)visualID);
                }
                VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceXlibPresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex, dpy, visualID);
                vkStream->unsetHandleMapping();
                vkStream->write((Display*)dpy, sizeof(Display));
                vkStream->write(&vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceXlibPresentationSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex, dpy, visualID);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_xcb_surface
            case OP_vkCreateXcbSurfaceKHR:
            {
                VkInstance instance;
                const VkXcbSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_513;
                vkReadStream->read((uint64_t*)&cgen_var_513, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_513, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkXcbSurfaceCreateInfoKHR));
                unmarshal_VkXcbSurfaceCreateInfoKHR(vkReadStream, (VkXcbSurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_515;
                vkReadStream->read((uint64_t*)&cgen_var_515, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_515, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkXcbSurfaceCreateInfoKHR(m_state, (VkXcbSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateXcbSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateXcbSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateXcbSurfaceKHR_VkResult_return = vk->vkCreateXcbSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_516;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_516, 1);
                vkStream->write((uint64_t*)&cgen_var_516, 8);
                vkStream->write(&vkCreateXcbSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateXcbSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateXcbSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceXcbPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                xcb_connection_t* connection;
                xcb_visualid_t visual_id;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_517;
                vkReadStream->read((uint64_t*)&cgen_var_517, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_517, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for connection;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&connection, sizeof(xcb_connection_t));
                vkReadStream->read((xcb_connection_t*)connection, sizeof(xcb_connection_t));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for connection;
                vkReadStream->read((xcb_visualid_t*)&visual_id, sizeof(xcb_visualid_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceXcbPresentationSupportKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex, (unsigned long long)connection, (unsigned long long)visual_id);
                }
                VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceXcbPresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex, connection, visual_id);
                vkStream->unsetHandleMapping();
                vkStream->write((xcb_connection_t*)connection, sizeof(xcb_connection_t));
                vkStream->write(&vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceXcbPresentationSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex, connection, visual_id);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_wayland_surface
            case OP_vkCreateWaylandSurfaceKHR:
            {
                VkInstance instance;
                const VkWaylandSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_518;
                vkReadStream->read((uint64_t*)&cgen_var_518, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_518, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkWaylandSurfaceCreateInfoKHR));
                unmarshal_VkWaylandSurfaceCreateInfoKHR(vkReadStream, (VkWaylandSurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_520;
                vkReadStream->read((uint64_t*)&cgen_var_520, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_520, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkWaylandSurfaceCreateInfoKHR(m_state, (VkWaylandSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateWaylandSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateWaylandSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateWaylandSurfaceKHR_VkResult_return = vk->vkCreateWaylandSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_521;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_521, 1);
                vkStream->write((uint64_t*)&cgen_var_521, 8);
                vkStream->write(&vkCreateWaylandSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateWaylandSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateWaylandSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceWaylandPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                wl_display* display;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_522;
                vkReadStream->read((uint64_t*)&cgen_var_522, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_522, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for display;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&display, sizeof(wl_display));
                vkReadStream->read((wl_display*)display, sizeof(wl_display));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for display;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceWaylandPresentationSupportKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex, (unsigned long long)display);
                }
                VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceWaylandPresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex, display);
                vkStream->unsetHandleMapping();
                vkStream->write((wl_display*)display, sizeof(wl_display));
                vkStream->write(&vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceWaylandPresentationSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex, display);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_mir_surface
            case OP_vkCreateMirSurfaceKHR:
            {
                VkInstance instance;
                const VkMirSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_523;
                vkReadStream->read((uint64_t*)&cgen_var_523, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_523, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkMirSurfaceCreateInfoKHR));
                unmarshal_VkMirSurfaceCreateInfoKHR(vkReadStream, (VkMirSurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_525;
                vkReadStream->read((uint64_t*)&cgen_var_525, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_525, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkMirSurfaceCreateInfoKHR(m_state, (VkMirSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateMirSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateMirSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateMirSurfaceKHR_VkResult_return = vk->vkCreateMirSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_526;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_526, 1);
                vkStream->write((uint64_t*)&cgen_var_526, 8);
                vkStream->write(&vkCreateMirSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateMirSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateMirSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceMirPresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                MirConnection* connection;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_527;
                vkReadStream->read((uint64_t*)&cgen_var_527, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_527, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for connection;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&connection, sizeof(MirConnection));
                vkReadStream->read((MirConnection*)connection, sizeof(MirConnection));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for connection;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceMirPresentationSupportKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex, (unsigned long long)connection);
                }
                VkBool32 vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceMirPresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex, connection);
                vkStream->unsetHandleMapping();
                vkStream->write((MirConnection*)connection, sizeof(MirConnection));
                vkStream->write(&vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceMirPresentationSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceMirPresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex, connection);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_android_surface
            case OP_vkCreateAndroidSurfaceKHR:
            {
                VkInstance instance;
                const VkAndroidSurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_528;
                vkReadStream->read((uint64_t*)&cgen_var_528, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_528, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkAndroidSurfaceCreateInfoKHR));
                unmarshal_VkAndroidSurfaceCreateInfoKHR(vkReadStream, (VkAndroidSurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_530;
                vkReadStream->read((uint64_t*)&cgen_var_530, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_530, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkAndroidSurfaceCreateInfoKHR(m_state, (VkAndroidSurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateAndroidSurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateAndroidSurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateAndroidSurfaceKHR_VkResult_return = vk->vkCreateAndroidSurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_531;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_531, 1);
                vkStream->write((uint64_t*)&cgen_var_531, 8);
                vkStream->write(&vkCreateAndroidSurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateAndroidSurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateAndroidSurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_win32_surface
            case OP_vkCreateWin32SurfaceKHR:
            {
                VkInstance instance;
                const VkWin32SurfaceCreateInfoKHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_532;
                vkReadStream->read((uint64_t*)&cgen_var_532, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_532, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkWin32SurfaceCreateInfoKHR));
                unmarshal_VkWin32SurfaceCreateInfoKHR(vkReadStream, (VkWin32SurfaceCreateInfoKHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_534;
                vkReadStream->read((uint64_t*)&cgen_var_534, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_534, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkWin32SurfaceCreateInfoKHR(m_state, (VkWin32SurfaceCreateInfoKHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateWin32SurfaceKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateWin32SurfaceKHR_VkResult_return = (VkResult)0;
                vkCreateWin32SurfaceKHR_VkResult_return = vk->vkCreateWin32SurfaceKHR(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_535;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_535, 1);
                vkStream->write((uint64_t*)&cgen_var_535, 8);
                vkStream->write(&vkCreateWin32SurfaceKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateWin32SurfaceKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateWin32SurfaceKHR_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceWin32PresentationSupportKHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t queueFamilyIndex;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_536;
                vkReadStream->read((uint64_t*)&cgen_var_536, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_536, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((uint32_t*)&queueFamilyIndex, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceWin32PresentationSupportKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)queueFamilyIndex);
                }
                VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = (VkBool32)0;
                vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = vk->vkGetPhysicalDeviceWin32PresentationSupportKHR(unboxed_physicalDevice, queueFamilyIndex);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceWin32PresentationSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, physicalDevice, queueFamilyIndex);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
            case OP_vkGetPhysicalDeviceFeatures2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceFeatures2* pFeatures;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_537;
                vkReadStream->read((uint64_t*)&cgen_var_537, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_537, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkPhysicalDeviceFeatures2));
                unmarshal_VkPhysicalDeviceFeatures2(vkReadStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFeatures;
                if (pFeatures)
                {
                    transform_tohost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceFeatures2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFeatures);
                }
                m_state->on_vkGetPhysicalDeviceFeatures2KHR(&m_pool, physicalDevice, pFeatures);
                vkStream->unsetHandleMapping();
                if (pFeatures)
                {
                    transform_fromhost_VkPhysicalDeviceFeatures2(m_state, (VkPhysicalDeviceFeatures2*)(pFeatures));
                }
                marshal_VkPhysicalDeviceFeatures2(vkStream, (VkPhysicalDeviceFeatures2*)(pFeatures));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFeatures2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFeatures);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceProperties2* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_538;
                vkReadStream->read((uint64_t*)&cgen_var_538, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_538, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkPhysicalDeviceProperties2));
                unmarshal_VkPhysicalDeviceProperties2(vkReadStream, (VkPhysicalDeviceProperties2*)(pProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    transform_tohost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceProperties2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pProperties);
                }
                m_state->on_vkGetPhysicalDeviceProperties2KHR(&m_pool, physicalDevice, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkPhysicalDeviceProperties2(m_state, (VkPhysicalDeviceProperties2*)(pProperties));
                }
                marshal_VkPhysicalDeviceProperties2(vkStream, (VkPhysicalDeviceProperties2*)(pProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceFormatProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkFormatProperties2* pFormatProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_539;
                vkReadStream->read((uint64_t*)&cgen_var_539, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_539, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                // Begin manual dispatchable handle unboxing for pFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFormatProperties, sizeof(VkFormatProperties2));
                unmarshal_VkFormatProperties2(vkReadStream, (VkFormatProperties2*)(pFormatProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFormatProperties;
                if (pFormatProperties)
                {
                    transform_tohost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceFormatProperties2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)pFormatProperties);
                }
                m_state->on_vkGetPhysicalDeviceFormatProperties2KHR(&m_pool, physicalDevice, format, pFormatProperties);
                vkStream->unsetHandleMapping();
                if (pFormatProperties)
                {
                    transform_fromhost_VkFormatProperties2(m_state, (VkFormatProperties2*)(pFormatProperties));
                }
                marshal_VkFormatProperties2(vkStream, (VkFormatProperties2*)(pFormatProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceFormatProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, format, pFormatProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceImageFormatProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo;
                VkImageFormatProperties2* pImageFormatProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_540;
                vkReadStream->read((uint64_t*)&cgen_var_540, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_540, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pImageFormatInfo, sizeof(const VkPhysicalDeviceImageFormatInfo2));
                unmarshal_VkPhysicalDeviceImageFormatInfo2(vkReadStream, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                // Begin manual dispatchable handle unboxing for pImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImageFormatProperties, sizeof(VkImageFormatProperties2));
                unmarshal_VkImageFormatProperties2(vkReadStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pImageFormatProperties;
                if (pImageFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceImageFormatInfo2(m_state, (VkPhysicalDeviceImageFormatInfo2*)(pImageFormatInfo));
                }
                if (pImageFormatProperties)
                {
                    transform_tohost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceImageFormatProperties2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pImageFormatInfo, (unsigned long long)pImageFormatProperties);
                }
                VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = m_state->on_vkGetPhysicalDeviceImageFormatProperties2KHR(&m_pool, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pImageFormatProperties)
                {
                    transform_fromhost_VkImageFormatProperties2(m_state, (VkImageFormatProperties2*)(pImageFormatProperties));
                }
                marshal_VkImageFormatProperties2(vkStream, (VkImageFormatProperties2*)(pImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceImageFormatProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, physicalDevice, pImageFormatInfo, pImageFormatProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceQueueFamilyProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pQueueFamilyPropertyCount;
                VkQueueFamilyProperties2* pQueueFamilyProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_541;
                vkReadStream->read((uint64_t*)&cgen_var_541, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_541, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyPropertyCount)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueueFamilyPropertyCount;
                // Begin manual dispatchable handle unboxing for pQueueFamilyProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pQueueFamilyProperties = (VkQueueFamilyProperties2*)(uintptr_t)vkReadStream->getBe64();
                if (pQueueFamilyProperties)
                {
                    vkReadStream->alloc((void**)&pQueueFamilyProperties, (*(pQueueFamilyPropertyCount)) * sizeof(VkQueueFamilyProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        unmarshal_VkQueueFamilyProperties2(vkReadStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pQueueFamilyProperties;
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_tohost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceQueueFamilyProperties2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pQueueFamilyPropertyCount, (unsigned long long)pQueueFamilyProperties);
                }
                vk->vkGetPhysicalDeviceQueueFamilyProperties2KHR(unboxed_physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_544 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
                vkStream->putBe64(cgen_var_544);
                if (pQueueFamilyPropertyCount)
                {
                    vkStream->write((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
                }
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        transform_fromhost_VkQueueFamilyProperties2(m_state, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_545 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
                vkStream->putBe64(cgen_var_545);
                if (pQueueFamilyProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                    {
                        marshal_VkQueueFamilyProperties2(vkStream, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
                    }
                }
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceQueueFamilyProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceMemoryProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkPhysicalDeviceMemoryProperties2* pMemoryProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_546;
                vkReadStream->read((uint64_t*)&cgen_var_546, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_546, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pMemoryProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryProperties, sizeof(VkPhysicalDeviceMemoryProperties2));
                unmarshal_VkPhysicalDeviceMemoryProperties2(vkReadStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryProperties;
                if (pMemoryProperties)
                {
                    transform_tohost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceMemoryProperties2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pMemoryProperties);
                }
                m_state->on_vkGetPhysicalDeviceMemoryProperties2KHR(&m_pool, physicalDevice, pMemoryProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryProperties)
                {
                    transform_fromhost_VkPhysicalDeviceMemoryProperties2(m_state, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                }
                marshal_VkPhysicalDeviceMemoryProperties2(vkStream, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceMemoryProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pMemoryProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo;
                uint32_t* pPropertyCount;
                VkSparseImageFormatProperties2* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_547;
                vkReadStream->read((uint64_t*)&cgen_var_547, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_547, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pFormatInfo, sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
                unmarshal_VkPhysicalDeviceSparseImageFormatInfo2(vkReadStream, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkSparseImageFormatProperties2*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkSparseImageFormatProperties2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkSparseImageFormatProperties2(vkReadStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pFormatInfo)
                {
                    transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(m_state, (VkPhysicalDeviceSparseImageFormatInfo2*)(pFormatInfo));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceSparseImageFormatProperties2KHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFormatInfo, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                vk->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(unboxed_physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_550 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_550);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageFormatProperties2(m_state, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_551 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_551);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkSparseImageFormatProperties2(vkStream, (VkSparseImageFormatProperties2*)(pProperties + i));
                    }
                }
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_device_group
            case OP_vkGetDeviceGroupPeerMemoryFeaturesKHR:
            {
                VkDevice device;
                uint32_t heapIndex;
                uint32_t localDeviceIndex;
                uint32_t remoteDeviceIndex;
                VkPeerMemoryFeatureFlags* pPeerMemoryFeatures;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_552;
                vkReadStream->read((uint64_t*)&cgen_var_552, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_552, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&heapIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&localDeviceIndex, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&remoteDeviceIndex, sizeof(uint32_t));
                // Begin manual dispatchable handle unboxing for pPeerMemoryFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPeerMemoryFeatures;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetDeviceGroupPeerMemoryFeaturesKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)heapIndex, (unsigned long long)localDeviceIndex, (unsigned long long)remoteDeviceIndex, (unsigned long long)pPeerMemoryFeatures);
                }
                vk->vkGetDeviceGroupPeerMemoryFeaturesKHR(unboxed_device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                vkStream->unsetHandleMapping();
                vkStream->write((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDeviceGroupPeerMemoryFeaturesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdSetDeviceMaskKHR:
            {
                VkCommandBuffer commandBuffer;
                uint32_t deviceMask;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_553;
                vkReadStream->read((uint64_t*)&cgen_var_553, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_553, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&deviceMask, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetDeviceMaskKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)deviceMask);
                }
                vk->vkCmdSetDeviceMaskKHR(unboxed_commandBuffer, deviceMask);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDeviceMaskKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, deviceMask);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdDispatchBaseKHR:
            {
                VkCommandBuffer commandBuffer;
                uint32_t baseGroupX;
                uint32_t baseGroupY;
                uint32_t baseGroupZ;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_554;
                vkReadStream->read((uint64_t*)&cgen_var_554, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_554, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&baseGroupX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&baseGroupZ, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountX, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountY, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&groupCountZ, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdDispatchBaseKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)baseGroupX, (unsigned long long)baseGroupY, (unsigned long long)baseGroupZ, (unsigned long long)groupCountX, (unsigned long long)groupCountY, (unsigned long long)groupCountZ);
                }
                vk->vkCmdDispatchBaseKHR(unboxed_commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDispatchBaseKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
            case OP_vkTrimCommandPoolKHR:
            {
                VkDevice device;
                VkCommandPool commandPool;
                VkCommandPoolTrimFlags flags;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_555;
                vkReadStream->read((uint64_t*)&cgen_var_555, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_555, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_556;
                vkReadStream->read((uint64_t*)&cgen_var_556, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_556, (VkCommandPool*)&commandPool, 1);
                vkReadStream->read((VkCommandPoolTrimFlags*)&flags, sizeof(VkCommandPoolTrimFlags));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkTrimCommandPoolKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)commandPool, (unsigned long long)flags);
                }
                vk->vkTrimCommandPoolKHR(unboxed_device, commandPool, flags);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkTrimCommandPoolKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, commandPool, flags);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_device_group_creation
            case OP_vkEnumeratePhysicalDeviceGroupsKHR:
            {
                VkInstance instance;
                uint32_t* pPhysicalDeviceGroupCount;
                VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_557;
                vkReadStream->read((uint64_t*)&cgen_var_557, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_557, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPhysicalDeviceGroupCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDeviceGroupCount)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPhysicalDeviceGroupCount;
                // Begin manual dispatchable handle unboxing for pPhysicalDeviceGroupProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPhysicalDeviceGroupProperties = (VkPhysicalDeviceGroupProperties*)(uintptr_t)vkReadStream->getBe64();
                if (pPhysicalDeviceGroupProperties)
                {
                    vkReadStream->alloc((void**)&pPhysicalDeviceGroupProperties, (*(pPhysicalDeviceGroupCount)) * sizeof(VkPhysicalDeviceGroupProperties));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        unmarshal_VkPhysicalDeviceGroupProperties(vkReadStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPhysicalDeviceGroupProperties;
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        transform_tohost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkEnumeratePhysicalDeviceGroupsKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pPhysicalDeviceGroupCount, (unsigned long long)pPhysicalDeviceGroupProperties);
                }
                VkResult vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = (VkResult)0;
                vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = vk->vkEnumeratePhysicalDeviceGroupsKHR(unboxed_instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_560 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
                vkStream->putBe64(cgen_var_560);
                if (pPhysicalDeviceGroupCount)
                {
                    vkStream->write((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
                }
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        transform_fromhost_VkPhysicalDeviceGroupProperties(m_state, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_561 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
                vkStream->putBe64(cgen_var_561);
                if (pPhysicalDeviceGroupProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                    {
                        marshal_VkPhysicalDeviceGroupProperties(vkStream, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
                    }
                }
                vkStream->write(&vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEnumeratePhysicalDeviceGroupsKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_external_memory_capabilities
            case OP_vkGetPhysicalDeviceExternalBufferPropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo;
                VkExternalBufferProperties* pExternalBufferProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_562;
                vkReadStream->read((uint64_t*)&cgen_var_562, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_562, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalBufferInfo, sizeof(const VkPhysicalDeviceExternalBufferInfo));
                unmarshal_VkPhysicalDeviceExternalBufferInfo(vkReadStream, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                // Begin manual dispatchable handle unboxing for pExternalBufferProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalBufferProperties, sizeof(VkExternalBufferProperties));
                unmarshal_VkExternalBufferProperties(vkReadStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pExternalBufferProperties;
                if (pExternalBufferInfo)
                {
                    m_state->transformImpl_VkPhysicalDeviceExternalBufferInfo_tohost(pExternalBufferInfo, 1);
                    transform_tohost_VkPhysicalDeviceExternalBufferInfo(m_state, (VkPhysicalDeviceExternalBufferInfo*)(pExternalBufferInfo));
                }
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_tohost(pExternalBufferProperties, 1);
                    transform_tohost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceExternalBufferPropertiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalBufferInfo, (unsigned long long)pExternalBufferProperties);
                }
                vk->vkGetPhysicalDeviceExternalBufferPropertiesKHR(unboxed_physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                vkStream->unsetHandleMapping();
                if (pExternalBufferProperties)
                {
                    m_state->transformImpl_VkExternalBufferProperties_fromhost(pExternalBufferProperties, 1);
                    transform_fromhost_VkExternalBufferProperties(m_state, (VkExternalBufferProperties*)(pExternalBufferProperties));
                }
                marshal_VkExternalBufferProperties(vkStream, (VkExternalBufferProperties*)(pExternalBufferProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalBufferPropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
            case OP_vkGetMemoryWin32HandleKHR:
            {
                VkDevice device;
                const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_563;
                vkReadStream->read((uint64_t*)&cgen_var_563, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_563, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkMemoryGetWin32HandleInfoKHR));
                unmarshal_VkMemoryGetWin32HandleInfoKHR(vkReadStream, (VkMemoryGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pHandle;
                if (pGetWin32HandleInfo)
                {
                    transform_tohost_VkMemoryGetWin32HandleInfoKHR(m_state, (VkMemoryGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetMemoryWin32HandleKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetWin32HandleInfo, (unsigned long long)pHandle);
                }
                VkResult vkGetMemoryWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandleKHR_VkResult_return = vk->vkGetMemoryWin32HandleKHR(unboxed_device, pGetWin32HandleInfo, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetMemoryWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryWin32HandleKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryWin32HandleKHR_VkResult_return, device, pGetWin32HandleInfo, pHandle);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetMemoryWin32HandlePropertiesKHR:
            {
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                HANDLE handle;
                VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_564;
                vkReadStream->read((uint64_t*)&cgen_var_564, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_564, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
                vkReadStream->read((HANDLE*)&handle, sizeof(HANDLE));
                // Begin manual dispatchable handle unboxing for pMemoryWin32HandleProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryWin32HandleProperties, sizeof(VkMemoryWin32HandlePropertiesKHR));
                unmarshal_VkMemoryWin32HandlePropertiesKHR(vkReadStream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryWin32HandleProperties;
                if (pMemoryWin32HandleProperties)
                {
                    transform_tohost_VkMemoryWin32HandlePropertiesKHR(m_state, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetMemoryWin32HandlePropertiesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)handleType, (unsigned long long)handle, (unsigned long long)pMemoryWin32HandleProperties);
                }
                VkResult vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = vk->vkGetMemoryWin32HandlePropertiesKHR(unboxed_device, handleType, handle, pMemoryWin32HandleProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryWin32HandleProperties)
                {
                    transform_fromhost_VkMemoryWin32HandlePropertiesKHR(m_state, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                }
                marshal_VkMemoryWin32HandlePropertiesKHR(vkStream, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
                vkStream->write(&vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryWin32HandlePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, device, handleType, handle, pMemoryWin32HandleProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_external_memory_fd
            case OP_vkGetMemoryFdKHR:
            {
                VkDevice device;
                const VkMemoryGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_565;
                vkReadStream->read((uint64_t*)&cgen_var_565, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_565, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkMemoryGetFdInfoKHR));
                unmarshal_VkMemoryGetFdInfoKHR(vkReadStream, (VkMemoryGetFdInfoKHR*)(pGetFdInfo));
                // Begin manual dispatchable handle unboxing for pFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                vkReadStream->read((int*)pFd, sizeof(int));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFd;
                if (pGetFdInfo)
                {
                    transform_tohost_VkMemoryGetFdInfoKHR(m_state, (VkMemoryGetFdInfoKHR*)(pGetFdInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetMemoryFdKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetFdInfo, (unsigned long long)pFd);
                }
                VkResult vkGetMemoryFdKHR_VkResult_return = (VkResult)0;
                vkGetMemoryFdKHR_VkResult_return = vk->vkGetMemoryFdKHR(unboxed_device, pGetFdInfo, pFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetMemoryFdKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryFdKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryFdKHR_VkResult_return, device, pGetFdInfo, pFd);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetMemoryFdPropertiesKHR:
            {
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                int fd;
                VkMemoryFdPropertiesKHR* pMemoryFdProperties;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_566;
                vkReadStream->read((uint64_t*)&cgen_var_566, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_566, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
                vkReadStream->read((int*)&fd, sizeof(int));
                // Begin manual dispatchable handle unboxing for pMemoryFdProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryFdProperties, sizeof(VkMemoryFdPropertiesKHR));
                unmarshal_VkMemoryFdPropertiesKHR(vkReadStream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryFdProperties;
                if (pMemoryFdProperties)
                {
                    transform_tohost_VkMemoryFdPropertiesKHR(m_state, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetMemoryFdPropertiesKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)handleType, (unsigned long long)fd, (unsigned long long)pMemoryFdProperties);
                }
                VkResult vkGetMemoryFdPropertiesKHR_VkResult_return = (VkResult)0;
                vkGetMemoryFdPropertiesKHR_VkResult_return = vk->vkGetMemoryFdPropertiesKHR(unboxed_device, handleType, fd, pMemoryFdProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryFdProperties)
                {
                    transform_fromhost_VkMemoryFdPropertiesKHR(m_state, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                }
                marshal_VkMemoryFdPropertiesKHR(vkStream, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
                vkStream->write(&vkGetMemoryFdPropertiesKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryFdPropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryFdPropertiesKHR_VkResult_return, device, handleType, fd, pMemoryFdProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_win32_keyed_mutex
#endif
#ifdef VK_KHR_external_semaphore_capabilities
            case OP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo;
                VkExternalSemaphoreProperties* pExternalSemaphoreProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_567;
                vkReadStream->read((uint64_t*)&cgen_var_567, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_567, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalSemaphoreInfo, sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
                unmarshal_VkPhysicalDeviceExternalSemaphoreInfo(vkReadStream, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                // Begin manual dispatchable handle unboxing for pExternalSemaphoreProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalSemaphoreProperties, sizeof(VkExternalSemaphoreProperties));
                unmarshal_VkExternalSemaphoreProperties(vkReadStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pExternalSemaphoreProperties;
                if (pExternalSemaphoreInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(m_state, (VkPhysicalDeviceExternalSemaphoreInfo*)(pExternalSemaphoreInfo));
                }
                if (pExternalSemaphoreProperties)
                {
                    transform_tohost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceExternalSemaphorePropertiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalSemaphoreInfo, (unsigned long long)pExternalSemaphoreProperties);
                }
                m_state->on_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(&m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                vkStream->unsetHandleMapping();
                if (pExternalSemaphoreProperties)
                {
                    transform_fromhost_VkExternalSemaphoreProperties(m_state, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                }
                marshal_VkExternalSemaphoreProperties(vkStream, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
            case OP_vkImportSemaphoreWin32HandleKHR:
            {
                VkDevice device;
                const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_568;
                vkReadStream->read((uint64_t*)&cgen_var_568, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_568, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pImportSemaphoreWin32HandleInfo, sizeof(const VkImportSemaphoreWin32HandleInfoKHR));
                unmarshal_VkImportSemaphoreWin32HandleInfoKHR(vkReadStream, (VkImportSemaphoreWin32HandleInfoKHR*)(pImportSemaphoreWin32HandleInfo));
                if (pImportSemaphoreWin32HandleInfo)
                {
                    transform_tohost_VkImportSemaphoreWin32HandleInfoKHR(m_state, (VkImportSemaphoreWin32HandleInfoKHR*)(pImportSemaphoreWin32HandleInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkImportSemaphoreWin32HandleKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pImportSemaphoreWin32HandleInfo);
                }
                VkResult vkImportSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
                vkImportSemaphoreWin32HandleKHR_VkResult_return = vk->vkImportSemaphoreWin32HandleKHR(unboxed_device, pImportSemaphoreWin32HandleInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkImportSemaphoreWin32HandleKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkImportSemaphoreWin32HandleKHR_VkResult_return, device, pImportSemaphoreWin32HandleInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetSemaphoreWin32HandleKHR:
            {
                VkDevice device;
                const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_569;
                vkReadStream->read((uint64_t*)&cgen_var_569, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_569, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkSemaphoreGetWin32HandleInfoKHR));
                unmarshal_VkSemaphoreGetWin32HandleInfoKHR(vkReadStream, (VkSemaphoreGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pHandle;
                if (pGetWin32HandleInfo)
                {
                    transform_tohost_VkSemaphoreGetWin32HandleInfoKHR(m_state, (VkSemaphoreGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetSemaphoreWin32HandleKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetWin32HandleInfo, (unsigned long long)pHandle);
                }
                VkResult vkGetSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetSemaphoreWin32HandleKHR_VkResult_return = vk->vkGetSemaphoreWin32HandleKHR(unboxed_device, pGetWin32HandleInfo, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSemaphoreWin32HandleKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSemaphoreWin32HandleKHR_VkResult_return, device, pGetWin32HandleInfo, pHandle);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_external_semaphore_fd
            case OP_vkImportSemaphoreFdKHR:
            {
                VkDevice device;
                const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_570;
                vkReadStream->read((uint64_t*)&cgen_var_570, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_570, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pImportSemaphoreFdInfo, sizeof(const VkImportSemaphoreFdInfoKHR));
                unmarshal_VkImportSemaphoreFdInfoKHR(vkReadStream, (VkImportSemaphoreFdInfoKHR*)(pImportSemaphoreFdInfo));
                if (pImportSemaphoreFdInfo)
                {
                    transform_tohost_VkImportSemaphoreFdInfoKHR(m_state, (VkImportSemaphoreFdInfoKHR*)(pImportSemaphoreFdInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkImportSemaphoreFdKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pImportSemaphoreFdInfo);
                }
                VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
                vkImportSemaphoreFdKHR_VkResult_return = m_state->on_vkImportSemaphoreFdKHR(&m_pool, device, pImportSemaphoreFdInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkImportSemaphoreFdKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkImportSemaphoreFdKHR_VkResult_return, device, pImportSemaphoreFdInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetSemaphoreFdKHR:
            {
                VkDevice device;
                const VkSemaphoreGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_571;
                vkReadStream->read((uint64_t*)&cgen_var_571, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_571, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkSemaphoreGetFdInfoKHR));
                unmarshal_VkSemaphoreGetFdInfoKHR(vkReadStream, (VkSemaphoreGetFdInfoKHR*)(pGetFdInfo));
                // Begin manual dispatchable handle unboxing for pFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                vkReadStream->read((int*)pFd, sizeof(int));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFd;
                if (pGetFdInfo)
                {
                    transform_tohost_VkSemaphoreGetFdInfoKHR(m_state, (VkSemaphoreGetFdInfoKHR*)(pGetFdInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetSemaphoreFdKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetFdInfo, (unsigned long long)pFd);
                }
                VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
                vkGetSemaphoreFdKHR_VkResult_return = m_state->on_vkGetSemaphoreFdKHR(&m_pool, device, pGetFdInfo, pFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSemaphoreFdKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSemaphoreFdKHR_VkResult_return, device, pGetFdInfo, pFd);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_push_descriptor
            case OP_vkCmdPushDescriptorSetKHR:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineBindPoint pipelineBindPoint;
                VkPipelineLayout layout;
                uint32_t set;
                uint32_t descriptorWriteCount;
                const VkWriteDescriptorSet* pDescriptorWrites;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_572;
                vkReadStream->read((uint64_t*)&cgen_var_572, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_572, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkPipelineBindPoint*)&pipelineBindPoint, sizeof(VkPipelineBindPoint));
                uint64_t cgen_var_573;
                vkReadStream->read((uint64_t*)&cgen_var_573, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_573, (VkPipelineLayout*)&layout, 1);
                vkReadStream->read((uint32_t*)&set, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&descriptorWriteCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDescriptorWrites, ((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
                for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                {
                    unmarshal_VkWriteDescriptorSet(vkReadStream, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                }
                if (pDescriptorWrites)
                {
                    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
                    {
                        transform_tohost_VkWriteDescriptorSet(m_state, (VkWriteDescriptorSet*)(pDescriptorWrites + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdPushDescriptorSetKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineBindPoint, (unsigned long long)layout, (unsigned long long)set, (unsigned long long)descriptorWriteCount, (unsigned long long)pDescriptorWrites);
                }
                vk->vkCmdPushDescriptorSetKHR(unboxed_commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdPushDescriptorSetKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdPushDescriptorSetWithTemplateKHR:
            {
                VkCommandBuffer commandBuffer;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                VkPipelineLayout layout;
                uint32_t set;
                const void* pData;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_574;
                vkReadStream->read((uint64_t*)&cgen_var_574, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_574, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_575;
                vkReadStream->read((uint64_t*)&cgen_var_575, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_575, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                uint64_t cgen_var_576;
                vkReadStream->read((uint64_t*)&cgen_var_576, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_576, (VkPipelineLayout*)&layout, 1);
                vkReadStream->read((uint32_t*)&set, sizeof(uint32_t));
                // WARNING PTR CHECK
                pData = (const void*)(uintptr_t)vkReadStream->getBe64();
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    vkReadStream->read((void*)pData, sizeof(const uint8_t));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdPushDescriptorSetWithTemplateKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)layout, (unsigned long long)set, (unsigned long long)pData);
                }
                vk->vkCmdPushDescriptorSetWithTemplateKHR(unboxed_commandBuffer, descriptorUpdateTemplate, layout, set, pData);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdPushDescriptorSetWithTemplateKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, descriptorUpdateTemplate, layout, set, pData);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
#endif
#ifdef VK_KHR_descriptor_update_template
            case OP_vkCreateDescriptorUpdateTemplateKHR:
            {
                VkDevice device;
                const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_578;
                vkReadStream->read((uint64_t*)&cgen_var_578, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_578, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorUpdateTemplateCreateInfo));
                unmarshal_VkDescriptorUpdateTemplateCreateInfo(vkReadStream, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pDescriptorUpdateTemplate;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDescriptorUpdateTemplate, sizeof(VkDescriptorUpdateTemplate));
                uint64_t cgen_var_580;
                vkReadStream->read((uint64_t*)&cgen_var_580, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_580, (VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDescriptorUpdateTemplate;
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorUpdateTemplateCreateInfo(m_state, (VkDescriptorUpdateTemplateCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateDescriptorUpdateTemplateKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pDescriptorUpdateTemplate);
                }
                VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
                vkCreateDescriptorUpdateTemplateKHR_VkResult_return = m_state->on_vkCreateDescriptorUpdateTemplateKHR(&m_pool, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_581;
                static_assert(8 == sizeof(VkDescriptorUpdateTemplate), "handle map overwrite requres VkDescriptorUpdateTemplate to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
                vkStream->write((VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 8 * 1);
                // Begin manual non dispatchable handle create for pDescriptorUpdateTemplate;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDescriptorUpdateTemplateKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDescriptorUpdateTemplateKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDescriptorUpdateTemplateKHR_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyDescriptorUpdateTemplateKHR:
            {
                VkDevice device;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_582;
                vkReadStream->read((uint64_t*)&cgen_var_582, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_582, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for descriptorUpdateTemplate;
                VkDescriptorUpdateTemplate* boxed_descriptorUpdateTemplate_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_descriptorUpdateTemplate_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_583;
                vkReadStream->read((uint64_t*)&cgen_var_583, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_583, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for descriptorUpdateTemplate;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyDescriptorUpdateTemplateKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)pAllocator);
                }
                m_state->on_vkDestroyDescriptorUpdateTemplateKHR(&m_pool, device, descriptorUpdateTemplate, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDescriptorUpdateTemplateKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_descriptorUpdateTemplate_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkUpdateDescriptorSetWithTemplateKHR:
            {
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                const void* pData;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_585;
                vkReadStream->read((uint64_t*)&cgen_var_585, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_585, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_586;
                vkReadStream->read((uint64_t*)&cgen_var_586, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(&cgen_var_586, (VkDescriptorSet*)&descriptorSet, 1);
                uint64_t cgen_var_587;
                vkReadStream->read((uint64_t*)&cgen_var_587, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_587, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                // WARNING PTR CHECK
                pData = (const void*)(uintptr_t)vkReadStream->getBe64();
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, sizeof(const uint8_t));
                    vkReadStream->read((void*)pData, sizeof(const uint8_t));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkUpdateDescriptorSetWithTemplateKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorSet, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)pData);
                }
                vk->vkUpdateDescriptorSetWithTemplateKHR(unboxed_device, descriptorSet, descriptorUpdateTemplate, pData);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUpdateDescriptorSetWithTemplateKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorSet, descriptorUpdateTemplate, pData);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_create_renderpass2
            case OP_vkCreateRenderPass2KHR:
            {
                VkDevice device;
                const VkRenderPassCreateInfo2KHR* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkRenderPass* pRenderPass;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_589;
                vkReadStream->read((uint64_t*)&cgen_var_589, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_589, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkRenderPassCreateInfo2KHR));
                unmarshal_VkRenderPassCreateInfo2KHR(vkReadStream, (VkRenderPassCreateInfo2KHR*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pRenderPass;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pRenderPass, sizeof(VkRenderPass));
                uint64_t cgen_var_591;
                vkReadStream->read((uint64_t*)&cgen_var_591, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_591, (VkRenderPass*)pRenderPass, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pRenderPass;
                if (pCreateInfo)
                {
                    transform_tohost_VkRenderPassCreateInfo2KHR(m_state, (VkRenderPassCreateInfo2KHR*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateRenderPass2KHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pRenderPass);
                }
                VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
                vkCreateRenderPass2KHR_VkResult_return = vk->vkCreateRenderPass2KHR(unboxed_device, pCreateInfo, pAllocator, pRenderPass);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_592;
                vkStream->handleMapping()->mapHandles_VkRenderPass_u64(pRenderPass, &cgen_var_592, 1);
                vkStream->write((uint64_t*)&cgen_var_592, 8);
                vkStream->write(&vkCreateRenderPass2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateRenderPass2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateRenderPass2KHR_VkResult_return, device, pCreateInfo, pAllocator, pRenderPass);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdBeginRenderPass2KHR:
            {
                VkCommandBuffer commandBuffer;
                const VkRenderPassBeginInfo* pRenderPassBegin;
                const VkSubpassBeginInfoKHR* pSubpassBeginInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_593;
                vkReadStream->read((uint64_t*)&cgen_var_593, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_593, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pRenderPassBegin, sizeof(const VkRenderPassBeginInfo));
                unmarshal_VkRenderPassBeginInfo(vkReadStream, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                vkReadStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfoKHR));
                unmarshal_VkSubpassBeginInfoKHR(vkReadStream, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
                if (pRenderPassBegin)
                {
                    transform_tohost_VkRenderPassBeginInfo(m_state, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                }
                if (pSubpassBeginInfo)
                {
                    transform_tohost_VkSubpassBeginInfoKHR(m_state, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdBeginRenderPass2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pRenderPassBegin, (unsigned long long)pSubpassBeginInfo);
                }
                vk->vkCmdBeginRenderPass2KHR(unboxed_commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginRenderPass2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdNextSubpass2KHR:
            {
                VkCommandBuffer commandBuffer;
                const VkSubpassBeginInfoKHR* pSubpassBeginInfo;
                const VkSubpassEndInfoKHR* pSubpassEndInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_594;
                vkReadStream->read((uint64_t*)&cgen_var_594, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_594, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pSubpassBeginInfo, sizeof(const VkSubpassBeginInfoKHR));
                unmarshal_VkSubpassBeginInfoKHR(vkReadStream, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
                vkReadStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfoKHR));
                unmarshal_VkSubpassEndInfoKHR(vkReadStream, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
                if (pSubpassBeginInfo)
                {
                    transform_tohost_VkSubpassBeginInfoKHR(m_state, (VkSubpassBeginInfoKHR*)(pSubpassBeginInfo));
                }
                if (pSubpassEndInfo)
                {
                    transform_tohost_VkSubpassEndInfoKHR(m_state, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdNextSubpass2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pSubpassBeginInfo, (unsigned long long)pSubpassEndInfo);
                }
                vk->vkCmdNextSubpass2KHR(unboxed_commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdNextSubpass2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdEndRenderPass2KHR:
            {
                VkCommandBuffer commandBuffer;
                const VkSubpassEndInfoKHR* pSubpassEndInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_595;
                vkReadStream->read((uint64_t*)&cgen_var_595, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_595, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pSubpassEndInfo, sizeof(const VkSubpassEndInfoKHR));
                unmarshal_VkSubpassEndInfoKHR(vkReadStream, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
                if (pSubpassEndInfo)
                {
                    transform_tohost_VkSubpassEndInfoKHR(m_state, (VkSubpassEndInfoKHR*)(pSubpassEndInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdEndRenderPass2KHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pSubpassEndInfo);
                }
                vk->vkCmdEndRenderPass2KHR(unboxed_commandBuffer, pSubpassEndInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndRenderPass2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pSubpassEndInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_shared_presentable_image
            case OP_vkGetSwapchainStatusKHR:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_596;
                vkReadStream->read((uint64_t*)&cgen_var_596, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_596, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_597;
                vkReadStream->read((uint64_t*)&cgen_var_597, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_597, (VkSwapchainKHR*)&swapchain, 1);
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetSwapchainStatusKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain);
                }
                VkResult vkGetSwapchainStatusKHR_VkResult_return = (VkResult)0;
                vkGetSwapchainStatusKHR_VkResult_return = vk->vkGetSwapchainStatusKHR(unboxed_device, swapchain);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkGetSwapchainStatusKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSwapchainStatusKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSwapchainStatusKHR_VkResult_return, device, swapchain);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_external_fence_capabilities
            case OP_vkGetPhysicalDeviceExternalFencePropertiesKHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo;
                VkExternalFenceProperties* pExternalFenceProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_598;
                vkReadStream->read((uint64_t*)&cgen_var_598, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_598, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pExternalFenceInfo, sizeof(const VkPhysicalDeviceExternalFenceInfo));
                unmarshal_VkPhysicalDeviceExternalFenceInfo(vkReadStream, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                // Begin manual dispatchable handle unboxing for pExternalFenceProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalFenceProperties, sizeof(VkExternalFenceProperties));
                unmarshal_VkExternalFenceProperties(vkReadStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pExternalFenceProperties;
                if (pExternalFenceInfo)
                {
                    transform_tohost_VkPhysicalDeviceExternalFenceInfo(m_state, (VkPhysicalDeviceExternalFenceInfo*)(pExternalFenceInfo));
                }
                if (pExternalFenceProperties)
                {
                    transform_tohost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceExternalFencePropertiesKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pExternalFenceInfo, (unsigned long long)pExternalFenceProperties);
                }
                vk->vkGetPhysicalDeviceExternalFencePropertiesKHR(unboxed_physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                vkStream->unsetHandleMapping();
                if (pExternalFenceProperties)
                {
                    transform_fromhost_VkExternalFenceProperties(m_state, (VkExternalFenceProperties*)(pExternalFenceProperties));
                }
                marshal_VkExternalFenceProperties(vkStream, (VkExternalFenceProperties*)(pExternalFenceProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalFencePropertiesKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
            case OP_vkImportFenceWin32HandleKHR:
            {
                VkDevice device;
                const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_599;
                vkReadStream->read((uint64_t*)&cgen_var_599, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_599, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pImportFenceWin32HandleInfo, sizeof(const VkImportFenceWin32HandleInfoKHR));
                unmarshal_VkImportFenceWin32HandleInfoKHR(vkReadStream, (VkImportFenceWin32HandleInfoKHR*)(pImportFenceWin32HandleInfo));
                if (pImportFenceWin32HandleInfo)
                {
                    transform_tohost_VkImportFenceWin32HandleInfoKHR(m_state, (VkImportFenceWin32HandleInfoKHR*)(pImportFenceWin32HandleInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkImportFenceWin32HandleKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pImportFenceWin32HandleInfo);
                }
                VkResult vkImportFenceWin32HandleKHR_VkResult_return = (VkResult)0;
                vkImportFenceWin32HandleKHR_VkResult_return = vk->vkImportFenceWin32HandleKHR(unboxed_device, pImportFenceWin32HandleInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkImportFenceWin32HandleKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkImportFenceWin32HandleKHR_VkResult_return, device, pImportFenceWin32HandleInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetFenceWin32HandleKHR:
            {
                VkDevice device;
                const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo;
                HANDLE* pHandle;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_600;
                vkReadStream->read((uint64_t*)&cgen_var_600, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_600, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetWin32HandleInfo, sizeof(const VkFenceGetWin32HandleInfoKHR));
                unmarshal_VkFenceGetWin32HandleInfoKHR(vkReadStream, (VkFenceGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pHandle;
                if (pGetWin32HandleInfo)
                {
                    transform_tohost_VkFenceGetWin32HandleInfoKHR(m_state, (VkFenceGetWin32HandleInfoKHR*)(pGetWin32HandleInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetFenceWin32HandleKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetWin32HandleInfo, (unsigned long long)pHandle);
                }
                VkResult vkGetFenceWin32HandleKHR_VkResult_return = (VkResult)0;
                vkGetFenceWin32HandleKHR_VkResult_return = vk->vkGetFenceWin32HandleKHR(unboxed_device, pGetWin32HandleInfo, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetFenceWin32HandleKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetFenceWin32HandleKHR_VkResult_return, device, pGetWin32HandleInfo, pHandle);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_external_fence_fd
            case OP_vkImportFenceFdKHR:
            {
                VkDevice device;
                const VkImportFenceFdInfoKHR* pImportFenceFdInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_601;
                vkReadStream->read((uint64_t*)&cgen_var_601, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_601, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pImportFenceFdInfo, sizeof(const VkImportFenceFdInfoKHR));
                unmarshal_VkImportFenceFdInfoKHR(vkReadStream, (VkImportFenceFdInfoKHR*)(pImportFenceFdInfo));
                if (pImportFenceFdInfo)
                {
                    transform_tohost_VkImportFenceFdInfoKHR(m_state, (VkImportFenceFdInfoKHR*)(pImportFenceFdInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkImportFenceFdKHR 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pImportFenceFdInfo);
                }
                VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
                vkImportFenceFdKHR_VkResult_return = vk->vkImportFenceFdKHR(unboxed_device, pImportFenceFdInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkImportFenceFdKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkImportFenceFdKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkImportFenceFdKHR_VkResult_return, device, pImportFenceFdInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetFenceFdKHR:
            {
                VkDevice device;
                const VkFenceGetFdInfoKHR* pGetFdInfo;
                int* pFd;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_602;
                vkReadStream->read((uint64_t*)&cgen_var_602, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_602, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pGetFdInfo, sizeof(const VkFenceGetFdInfoKHR));
                unmarshal_VkFenceGetFdInfoKHR(vkReadStream, (VkFenceGetFdInfoKHR*)(pGetFdInfo));
                // Begin manual dispatchable handle unboxing for pFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFd, sizeof(int));
                vkReadStream->read((int*)pFd, sizeof(int));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFd;
                if (pGetFdInfo)
                {
                    transform_tohost_VkFenceGetFdInfoKHR(m_state, (VkFenceGetFdInfoKHR*)(pGetFdInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetFenceFdKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pGetFdInfo, (unsigned long long)pFd);
                }
                VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
                vkGetFenceFdKHR_VkResult_return = vk->vkGetFenceFdKHR(unboxed_device, pGetFdInfo, pFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pFd, sizeof(int));
                vkStream->write(&vkGetFenceFdKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetFenceFdKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetFenceFdKHR_VkResult_return, device, pGetFdInfo, pFd);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
            case OP_vkGetPhysicalDeviceSurfaceCapabilities2KHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
                VkSurfaceCapabilities2KHR* pSurfaceCapabilities;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_603;
                vkReadStream->read((uint64_t*)&cgen_var_603, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_603, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
                unmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkReadStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                // Begin manual dispatchable handle unboxing for pSurfaceCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilities2KHR));
                unmarshal_VkSurfaceCapabilities2KHR(vkReadStream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurfaceCapabilities;
                if (pSurfaceInfo)
                {
                    transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(m_state, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                }
                if (pSurfaceCapabilities)
                {
                    transform_tohost_VkSurfaceCapabilities2KHR(m_state, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceSurfaceCapabilities2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pSurfaceInfo, (unsigned long long)pSurfaceCapabilities);
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceCapabilities2KHR(unboxed_physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
                vkStream->unsetHandleMapping();
                if (pSurfaceCapabilities)
                {
                    transform_fromhost_VkSurfaceCapabilities2KHR(m_state, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                }
                marshal_VkSurfaceCapabilities2KHR(vkStream, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceCapabilities2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceSurfaceFormats2KHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
                uint32_t* pSurfaceFormatCount;
                VkSurfaceFormat2KHR* pSurfaceFormats;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_604;
                vkReadStream->read((uint64_t*)&cgen_var_604, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_604, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pSurfaceInfo, sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
                unmarshal_VkPhysicalDeviceSurfaceInfo2KHR(vkReadStream, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                // Begin manual dispatchable handle unboxing for pSurfaceFormatCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSurfaceFormatCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSurfaceFormatCount)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormatCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurfaceFormatCount;
                // Begin manual dispatchable handle unboxing for pSurfaceFormats;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSurfaceFormats = (VkSurfaceFormat2KHR*)(uintptr_t)vkReadStream->getBe64();
                if (pSurfaceFormats)
                {
                    vkReadStream->alloc((void**)&pSurfaceFormats, (*(pSurfaceFormatCount)) * sizeof(VkSurfaceFormat2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        unmarshal_VkSurfaceFormat2KHR(vkReadStream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurfaceFormats;
                if (pSurfaceInfo)
                {
                    transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(m_state, (VkPhysicalDeviceSurfaceInfo2KHR*)(pSurfaceInfo));
                }
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        transform_tohost_VkSurfaceFormat2KHR(m_state, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceSurfaceFormats2KHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pSurfaceInfo, (unsigned long long)pSurfaceFormatCount, (unsigned long long)pSurfaceFormats);
                }
                VkResult vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = vk->vkGetPhysicalDeviceSurfaceFormats2KHR(unboxed_physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_607 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
                vkStream->putBe64(cgen_var_607);
                if (pSurfaceFormatCount)
                {
                    vkStream->write((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
                }
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        transform_fromhost_VkSurfaceFormat2KHR(m_state, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_608 = (uint64_t)(uintptr_t)pSurfaceFormats;
                vkStream->putBe64(cgen_var_608);
                if (pSurfaceFormats)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                    {
                        marshal_VkSurfaceFormat2KHR(vkStream, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceFormats2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
            case OP_vkGetPhysicalDeviceDisplayProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayProperties2KHR* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_609;
                vkReadStream->read((uint64_t*)&cgen_var_609, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_609, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkDisplayProperties2KHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayProperties2KHR(vkReadStream, (VkDisplayProperties2KHR*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayProperties2KHR(m_state, (VkDisplayProperties2KHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceDisplayProperties2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayProperties2KHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_612 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_612);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayProperties2KHR(m_state, (VkDisplayProperties2KHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_613 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_613);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayProperties2KHR(vkStream, (VkDisplayProperties2KHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceDisplayProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                uint32_t* pPropertyCount;
                VkDisplayPlaneProperties2KHR* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_614;
                vkReadStream->read((uint64_t*)&cgen_var_614, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_614, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkDisplayPlaneProperties2KHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayPlaneProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayPlaneProperties2KHR(vkReadStream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayPlaneProperties2KHR(m_state, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceDisplayPlaneProperties2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = vk->vkGetPhysicalDeviceDisplayPlaneProperties2KHR(unboxed_physicalDevice, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_617 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_617);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayPlaneProperties2KHR(m_state, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_618 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_618);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayPlaneProperties2KHR(vkStream, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceDisplayPlaneProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, physicalDevice, pPropertyCount, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetDisplayModeProperties2KHR:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                uint32_t* pPropertyCount;
                VkDisplayModeProperties2KHR* pProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_619;
                vkReadStream->read((uint64_t*)&cgen_var_619, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_619, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_620;
                vkReadStream->read((uint64_t*)&cgen_var_620, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_620, (VkDisplayKHR*)&display, 1);
                // Begin manual dispatchable handle unboxing for pPropertyCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPropertyCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPropertyCount)
                {
                    vkReadStream->alloc((void**)&pPropertyCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPropertyCount;
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pProperties = (VkDisplayModeProperties2KHR*)(uintptr_t)vkReadStream->getBe64();
                if (pProperties)
                {
                    vkReadStream->alloc((void**)&pProperties, (*(pPropertyCount)) * sizeof(VkDisplayModeProperties2KHR));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        unmarshal_VkDisplayModeProperties2KHR(vkReadStream, (VkDisplayModeProperties2KHR*)(pProperties + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_tohost_VkDisplayModeProperties2KHR(m_state, (VkDisplayModeProperties2KHR*)(pProperties + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetDisplayModeProperties2KHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)display, (unsigned long long)pPropertyCount, (unsigned long long)pProperties);
                }
                VkResult vkGetDisplayModeProperties2KHR_VkResult_return = (VkResult)0;
                vkGetDisplayModeProperties2KHR_VkResult_return = vk->vkGetDisplayModeProperties2KHR(unboxed_physicalDevice, display, pPropertyCount, pProperties);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_623 = (uint64_t)(uintptr_t)pPropertyCount;
                vkStream->putBe64(cgen_var_623);
                if (pPropertyCount)
                {
                    vkStream->write((uint32_t*)pPropertyCount, sizeof(uint32_t));
                }
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        transform_fromhost_VkDisplayModeProperties2KHR(m_state, (VkDisplayModeProperties2KHR*)(pProperties + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_624 = (uint64_t)(uintptr_t)pProperties;
                vkStream->putBe64(cgen_var_624);
                if (pProperties)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                    {
                        marshal_VkDisplayModeProperties2KHR(vkStream, (VkDisplayModeProperties2KHR*)(pProperties + i));
                    }
                }
                vkStream->write(&vkGetDisplayModeProperties2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDisplayModeProperties2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDisplayModeProperties2KHR_VkResult_return, physicalDevice, display, pPropertyCount, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetDisplayPlaneCapabilities2KHR:
            {
                VkPhysicalDevice physicalDevice;
                const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo;
                VkDisplayPlaneCapabilities2KHR* pCapabilities;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_625;
                vkReadStream->read((uint64_t*)&cgen_var_625, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_625, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->alloc((void**)&pDisplayPlaneInfo, sizeof(const VkDisplayPlaneInfo2KHR));
                unmarshal_VkDisplayPlaneInfo2KHR(vkReadStream, (VkDisplayPlaneInfo2KHR*)(pDisplayPlaneInfo));
                // Begin manual dispatchable handle unboxing for pCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCapabilities, sizeof(VkDisplayPlaneCapabilities2KHR));
                unmarshal_VkDisplayPlaneCapabilities2KHR(vkReadStream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCapabilities;
                if (pDisplayPlaneInfo)
                {
                    transform_tohost_VkDisplayPlaneInfo2KHR(m_state, (VkDisplayPlaneInfo2KHR*)(pDisplayPlaneInfo));
                }
                if (pCapabilities)
                {
                    transform_tohost_VkDisplayPlaneCapabilities2KHR(m_state, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetDisplayPlaneCapabilities2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pDisplayPlaneInfo, (unsigned long long)pCapabilities);
                }
                VkResult vkGetDisplayPlaneCapabilities2KHR_VkResult_return = (VkResult)0;
                vkGetDisplayPlaneCapabilities2KHR_VkResult_return = vk->vkGetDisplayPlaneCapabilities2KHR(unboxed_physicalDevice, pDisplayPlaneInfo, pCapabilities);
                vkStream->unsetHandleMapping();
                if (pCapabilities)
                {
                    transform_fromhost_VkDisplayPlaneCapabilities2KHR(m_state, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                }
                marshal_VkDisplayPlaneCapabilities2KHR(vkStream, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
                vkStream->write(&vkGetDisplayPlaneCapabilities2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDisplayPlaneCapabilities2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetDisplayPlaneCapabilities2KHR_VkResult_return, physicalDevice, pDisplayPlaneInfo, pCapabilities);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
            case OP_vkGetImageMemoryRequirements2KHR:
            {
                VkDevice device;
                const VkImageMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_626;
                vkReadStream->read((uint64_t*)&cgen_var_626, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_626, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageMemoryRequirementsInfo2));
                unmarshal_VkImageMemoryRequirementsInfo2(vkReadStream, (VkImageMemoryRequirementsInfo2*)(pInfo));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryRequirements;
                if (pInfo)
                {
                    transform_tohost_VkImageMemoryRequirementsInfo2(m_state, (VkImageMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetImageMemoryRequirements2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pMemoryRequirements);
                }
                m_state->on_vkGetImageMemoryRequirements2KHR(&m_pool, device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageMemoryRequirements2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pMemoryRequirements);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetBufferMemoryRequirements2KHR:
            {
                VkDevice device;
                const VkBufferMemoryRequirementsInfo2* pInfo;
                VkMemoryRequirements2* pMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_627;
                vkReadStream->read((uint64_t*)&cgen_var_627, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_627, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkBufferMemoryRequirementsInfo2));
                unmarshal_VkBufferMemoryRequirementsInfo2(vkReadStream, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements2));
                unmarshal_VkMemoryRequirements2(vkReadStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryRequirements;
                if (pInfo)
                {
                    transform_tohost_VkBufferMemoryRequirementsInfo2(m_state, (VkBufferMemoryRequirementsInfo2*)(pInfo));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetBufferMemoryRequirements2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pMemoryRequirements);
                }
                vk->vkGetBufferMemoryRequirements2KHR(unboxed_device, pInfo, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements2(m_state, (VkMemoryRequirements2*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements2(vkStream, (VkMemoryRequirements2*)(pMemoryRequirements));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetBufferMemoryRequirements2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pMemoryRequirements);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetImageSparseMemoryRequirements2KHR:
            {
                VkDevice device;
                const VkImageSparseMemoryRequirementsInfo2* pInfo;
                uint32_t* pSparseMemoryRequirementCount;
                VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_628;
                vkReadStream->read((uint64_t*)&cgen_var_628, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_628, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkImageSparseMemoryRequirementsInfo2));
                unmarshal_VkImageSparseMemoryRequirementsInfo2(vkReadStream, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirementCount)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirementCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSparseMemoryRequirementCount;
                // Begin manual dispatchable handle unboxing for pSparseMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)(uintptr_t)vkReadStream->getBe64();
                if (pSparseMemoryRequirements)
                {
                    vkReadStream->alloc((void**)&pSparseMemoryRequirements, (*(pSparseMemoryRequirementCount)) * sizeof(VkSparseImageMemoryRequirements2));
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        unmarshal_VkSparseImageMemoryRequirements2(vkReadStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSparseMemoryRequirements;
                if (pInfo)
                {
                    transform_tohost_VkImageSparseMemoryRequirementsInfo2(m_state, (VkImageSparseMemoryRequirementsInfo2*)(pInfo));
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_tohost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetImageSparseMemoryRequirements2KHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pSparseMemoryRequirementCount, (unsigned long long)pSparseMemoryRequirements);
                }
                vk->vkGetImageSparseMemoryRequirements2KHR(unboxed_device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_631 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
                vkStream->putBe64(cgen_var_631);
                if (pSparseMemoryRequirementCount)
                {
                    vkStream->write((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
                }
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        transform_fromhost_VkSparseImageMemoryRequirements2(m_state, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_632 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
                vkStream->putBe64(cgen_var_632);
                if (pSparseMemoryRequirements)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                    {
                        marshal_VkSparseImageMemoryRequirements2(vkStream, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
                    }
                }
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetImageSparseMemoryRequirements2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
            case OP_vkCreateSamplerYcbcrConversionKHR:
            {
                VkDevice device;
                const VkSamplerYcbcrConversionCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSamplerYcbcrConversion* pYcbcrConversion;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_633;
                vkReadStream->read((uint64_t*)&cgen_var_633, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_633, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkSamplerYcbcrConversionCreateInfo));
                unmarshal_VkSamplerYcbcrConversionCreateInfo(vkReadStream, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pYcbcrConversion;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pYcbcrConversion, sizeof(VkSamplerYcbcrConversion));
                uint64_t cgen_var_635;
                vkReadStream->read((uint64_t*)&cgen_var_635, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_635, (VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pYcbcrConversion;
                if (pCreateInfo)
                {
                    transform_tohost_VkSamplerYcbcrConversionCreateInfo(m_state, (VkSamplerYcbcrConversionCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateSamplerYcbcrConversionKHR 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pYcbcrConversion);
                }
                VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
                vkCreateSamplerYcbcrConversionKHR_VkResult_return = vk->vkCreateSamplerYcbcrConversionKHR(unboxed_device, pCreateInfo, pAllocator, pYcbcrConversion);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                if (vkCreateSamplerYcbcrConversionKHR_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_636;
                static_assert(8 == sizeof(VkSamplerYcbcrConversion), "handle map overwrite requres VkSamplerYcbcrConversion to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
                vkStream->write((VkSamplerYcbcrConversion*)pYcbcrConversion, 8 * 1);
                // Begin auto non dispatchable handle create for pYcbcrConversion;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateSamplerYcbcrConversionKHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateSamplerYcbcrConversionKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateSamplerYcbcrConversionKHR_VkResult_return, device, pCreateInfo, pAllocator, pYcbcrConversion);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroySamplerYcbcrConversionKHR:
            {
                VkDevice device;
                VkSamplerYcbcrConversion ycbcrConversion;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_637;
                vkReadStream->read((uint64_t*)&cgen_var_637, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_637, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for ycbcrConversion;
                VkSamplerYcbcrConversion* boxed_ycbcrConversion_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_ycbcrConversion_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_638;
                vkReadStream->read((uint64_t*)&cgen_var_638, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_638, (VkSamplerYcbcrConversion*)&ycbcrConversion, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for ycbcrConversion;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroySamplerYcbcrConversionKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)ycbcrConversion, (unsigned long long)pAllocator);
                }
                vk->vkDestroySamplerYcbcrConversionKHR(unboxed_device, ycbcrConversion, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroySamplerYcbcrConversionKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_ycbcrConversion_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_bind_memory2
            case OP_vkBindBufferMemory2KHR:
            {
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindBufferMemoryInfo* pBindInfos;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_640;
                vkReadStream->read((uint64_t*)&cgen_var_640, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_640, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindBufferMemoryInfo(vkReadStream, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindBufferMemoryInfo(m_state, (VkBindBufferMemoryInfo*)(pBindInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkBindBufferMemory2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfos);
                }
                VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
                vkBindBufferMemory2KHR_VkResult_return = m_state->on_vkBindBufferMemory2KHR(&m_pool, device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindBufferMemory2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindBufferMemory2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindBufferMemory2KHR_VkResult_return, device, bindInfoCount, pBindInfos);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkBindImageMemory2KHR:
            {
                VkDevice device;
                uint32_t bindInfoCount;
                const VkBindImageMemoryInfo* pBindInfos;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_641;
                vkReadStream->read((uint64_t*)&cgen_var_641, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_641, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&bindInfoCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pBindInfos, ((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
                for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                {
                    unmarshal_VkBindImageMemoryInfo(vkReadStream, (VkBindImageMemoryInfo*)(pBindInfos + i));
                }
                if (pBindInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
                    {
                        transform_tohost_VkBindImageMemoryInfo(m_state, (VkBindImageMemoryInfo*)(pBindInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkBindImageMemory2KHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)bindInfoCount, (unsigned long long)pBindInfos);
                }
                VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
                vkBindImageMemory2KHR_VkResult_return = vk->vkBindImageMemory2KHR(unboxed_device, bindInfoCount, pBindInfos);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkBindImageMemory2KHR_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBindImageMemory2KHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkBindImageMemory2KHR_VkResult_return, device, bindInfoCount, pBindInfos);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_maintenance3
            case OP_vkGetDescriptorSetLayoutSupportKHR:
            {
                VkDevice device;
                const VkDescriptorSetLayoutCreateInfo* pCreateInfo;
                VkDescriptorSetLayoutSupport* pSupport;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_642;
                vkReadStream->read((uint64_t*)&cgen_var_642, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_642, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDescriptorSetLayoutCreateInfo));
                unmarshal_VkDescriptorSetLayoutCreateInfo(vkReadStream, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                // Begin manual dispatchable handle unboxing for pSupport;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSupport, sizeof(VkDescriptorSetLayoutSupport));
                unmarshal_VkDescriptorSetLayoutSupport(vkReadStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSupport;
                if (pCreateInfo)
                {
                    transform_tohost_VkDescriptorSetLayoutCreateInfo(m_state, (VkDescriptorSetLayoutCreateInfo*)(pCreateInfo));
                }
                if (pSupport)
                {
                    transform_tohost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetDescriptorSetLayoutSupportKHR 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pSupport);
                }
                vk->vkGetDescriptorSetLayoutSupportKHR(unboxed_device, pCreateInfo, pSupport);
                vkStream->unsetHandleMapping();
                if (pSupport)
                {
                    transform_fromhost_VkDescriptorSetLayoutSupport(m_state, (VkDescriptorSetLayoutSupport*)(pSupport));
                }
                marshal_VkDescriptorSetLayoutSupport(vkStream, (VkDescriptorSetLayoutSupport*)(pSupport));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetDescriptorSetLayoutSupportKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, pCreateInfo, pSupport);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_draw_indirect_count
            case OP_vkCmdDrawIndirectCountKHR:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_643;
                vkReadStream->read((uint64_t*)&cgen_var_643, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_643, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_644;
                vkReadStream->read((uint64_t*)&cgen_var_644, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_644, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                uint64_t cgen_var_645;
                vkReadStream->read((uint64_t*)&cgen_var_645, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_645, (VkBuffer*)&countBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdDrawIndirectCountKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)countBuffer, (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndirectCountKHR(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndirectCountKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdDrawIndexedIndirectCountKHR:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_646;
                vkReadStream->read((uint64_t*)&cgen_var_646, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_646, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_647;
                vkReadStream->read((uint64_t*)&cgen_var_647, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_647, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                uint64_t cgen_var_648;
                vkReadStream->read((uint64_t*)&cgen_var_648, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_648, (VkBuffer*)&countBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdDrawIndexedIndirectCountKHR 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)countBuffer, (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndexedIndirectCountKHR(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndexedIndirectCountKHR(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_ANDROID_native_buffer
            case OP_vkGetSwapchainGrallocUsageANDROID:
            {
                VkDevice device;
                VkFormat format;
                VkImageUsageFlags imageUsage;
                int* grallocUsage;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_649;
                vkReadStream->read((uint64_t*)&cgen_var_649, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_649, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->read((VkImageUsageFlags*)&imageUsage, sizeof(VkImageUsageFlags));
                // Begin manual dispatchable handle unboxing for grallocUsage;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&grallocUsage, sizeof(int));
                vkReadStream->read((int*)grallocUsage, sizeof(int));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for grallocUsage;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetSwapchainGrallocUsageANDROID 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)format, (unsigned long long)imageUsage, (unsigned long long)grallocUsage);
                }
                VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return = (VkResult)0;
                vkGetSwapchainGrallocUsageANDROID_VkResult_return = m_state->on_vkGetSwapchainGrallocUsageANDROID(&m_pool, device, format, imageUsage, grallocUsage);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)grallocUsage, sizeof(int));
                vkStream->write(&vkGetSwapchainGrallocUsageANDROID_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSwapchainGrallocUsageANDROID(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSwapchainGrallocUsageANDROID_VkResult_return, device, format, imageUsage, grallocUsage);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkAcquireImageANDROID:
            {
                VkDevice device;
                VkImage image;
                int nativeFenceFd;
                VkSemaphore semaphore;
                VkFence fence;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_650;
                vkReadStream->read((uint64_t*)&cgen_var_650, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_650, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_651;
                vkReadStream->read((uint64_t*)&cgen_var_651, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_651, (VkImage*)&image, 1);
                vkReadStream->read((int*)&nativeFenceFd, sizeof(int));
                uint64_t cgen_var_652;
                vkReadStream->read((uint64_t*)&cgen_var_652, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_652, (VkSemaphore*)&semaphore, 1);
                uint64_t cgen_var_653;
                vkReadStream->read((uint64_t*)&cgen_var_653, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_653, (VkFence*)&fence, 1);
                if (m_logCalls)
                {
                    INFO("stream %p: call vkAcquireImageANDROID 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)nativeFenceFd, (unsigned long long)semaphore, (unsigned long long)fence);
                }
                VkResult vkAcquireImageANDROID_VkResult_return = (VkResult)0;
                vkAcquireImageANDROID_VkResult_return = m_state->on_vkAcquireImageANDROID(&m_pool, device, image, nativeFenceFd, semaphore, fence);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkAcquireImageANDROID_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAcquireImageANDROID(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAcquireImageANDROID_VkResult_return, device, image, nativeFenceFd, semaphore, fence);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkQueueSignalReleaseImageANDROID:
            {
                VkQueue queue;
                uint32_t waitSemaphoreCount;
                const VkSemaphore* pWaitSemaphores;
                VkImage image;
                int* pNativeFenceFd;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_654;
                vkReadStream->read((uint64_t*)&cgen_var_654, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_654, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->read((uint32_t*)&waitSemaphoreCount, sizeof(uint32_t));
                // WARNING PTR CHECK
                pWaitSemaphores = (const VkSemaphore*)(uintptr_t)vkReadStream->getBe64();
                if (pWaitSemaphores)
                {
                    vkReadStream->alloc((void**)&pWaitSemaphores, ((waitSemaphoreCount)) * sizeof(const VkSemaphore));
                    if (((waitSemaphoreCount)))
                    {
                        uint64_t* cgen_var_656;
                        vkReadStream->alloc((void**)&cgen_var_656, ((waitSemaphoreCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_656, ((waitSemaphoreCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkSemaphore(cgen_var_656, (VkSemaphore*)pWaitSemaphores, ((waitSemaphoreCount)));
                    }
                }
                uint64_t cgen_var_657;
                vkReadStream->read((uint64_t*)&cgen_var_657, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_657, (VkImage*)&image, 1);
                // Begin manual dispatchable handle unboxing for pNativeFenceFd;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pNativeFenceFd, sizeof(int));
                vkReadStream->read((int*)pNativeFenceFd, sizeof(int));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pNativeFenceFd;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkQueueSignalReleaseImageANDROID 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)waitSemaphoreCount, (unsigned long long)pWaitSemaphores, (unsigned long long)image, (unsigned long long)pNativeFenceFd);
                }
                VkResult vkQueueSignalReleaseImageANDROID_VkResult_return = (VkResult)0;
                vkQueueSignalReleaseImageANDROID_VkResult_return = m_state->on_vkQueueSignalReleaseImageANDROID(&m_pool, queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
                vkStream->unsetHandleMapping();
                vkStream->write((int*)pNativeFenceFd, sizeof(int));
                vkStream->write(&vkQueueSignalReleaseImageANDROID_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueSignalReleaseImageANDROID(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkQueueSignalReleaseImageANDROID_VkResult_return, queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_EXT_debug_report
            case OP_vkCreateDebugReportCallbackEXT:
            {
                VkInstance instance;
                const VkDebugReportCallbackCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDebugReportCallbackEXT* pCallback;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_658;
                vkReadStream->read((uint64_t*)&cgen_var_658, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_658, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDebugReportCallbackCreateInfoEXT));
                unmarshal_VkDebugReportCallbackCreateInfoEXT(vkReadStream, (VkDebugReportCallbackCreateInfoEXT*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pCallback;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCallback, sizeof(VkDebugReportCallbackEXT));
                uint64_t cgen_var_660;
                vkReadStream->read((uint64_t*)&cgen_var_660, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDebugReportCallbackEXT(&cgen_var_660, (VkDebugReportCallbackEXT*)pCallback, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCallback;
                if (pCreateInfo)
                {
                    transform_tohost_VkDebugReportCallbackCreateInfoEXT(m_state, (VkDebugReportCallbackCreateInfoEXT*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateDebugReportCallbackEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pCallback);
                }
                VkResult vkCreateDebugReportCallbackEXT_VkResult_return = (VkResult)0;
                vkCreateDebugReportCallbackEXT_VkResult_return = vk->vkCreateDebugReportCallbackEXT(unboxed_instance, pCreateInfo, pAllocator, pCallback);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pCallback;
                if (vkCreateDebugReportCallbackEXT_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_661;
                static_assert(8 == sizeof(VkDebugReportCallbackEXT), "handle map overwrite requres VkDebugReportCallbackEXT to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDebugReportCallbackEXT((VkDebugReportCallbackEXT*)pCallback, 1);
                vkStream->write((VkDebugReportCallbackEXT*)pCallback, 8 * 1);
                // Begin auto non dispatchable handle create for pCallback;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDebugReportCallbackEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDebugReportCallbackEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDebugReportCallbackEXT_VkResult_return, instance, pCreateInfo, pAllocator, pCallback);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyDebugReportCallbackEXT:
            {
                VkInstance instance;
                VkDebugReportCallbackEXT callback;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_662;
                vkReadStream->read((uint64_t*)&cgen_var_662, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_662, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual non dispatchable handle destroy unboxing for callback;
                VkDebugReportCallbackEXT* boxed_callback_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_callback_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_663;
                vkReadStream->read((uint64_t*)&cgen_var_663, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDebugReportCallbackEXT(&cgen_var_663, (VkDebugReportCallbackEXT*)&callback, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for callback;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyDebugReportCallbackEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)callback, (unsigned long long)pAllocator);
                }
                vk->vkDestroyDebugReportCallbackEXT(unboxed_instance, callback, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDebugReportCallbackEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, *boxed_callback_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDebugReportMessageEXT:
            {
                VkInstance instance;
                VkDebugReportFlagsEXT flags;
                VkDebugReportObjectTypeEXT objectType;
                uint64_t object;
                size_t location;
                int32_t messageCode;
                const char* pLayerPrefix;
                const char* pMessage;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_665;
                vkReadStream->read((uint64_t*)&cgen_var_665, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_665, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->read((VkDebugReportFlagsEXT*)&flags, sizeof(VkDebugReportFlagsEXT));
                vkReadStream->read((VkDebugReportObjectTypeEXT*)&objectType, sizeof(VkDebugReportObjectTypeEXT));
                vkReadStream->read((uint64_t*)&object, sizeof(uint64_t));
                location = (size_t)vkReadStream->getBe64();
                vkReadStream->read((int32_t*)&messageCode, sizeof(int32_t));
                vkReadStream->loadStringInPlace((char**)&pLayerPrefix);
                vkReadStream->loadStringInPlace((char**)&pMessage);
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDebugReportMessageEXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)flags, (unsigned long long)objectType, (unsigned long long)object, (unsigned long long)location, (unsigned long long)messageCode, (unsigned long long)pLayerPrefix, (unsigned long long)pMessage);
                }
                vk->vkDebugReportMessageEXT(unboxed_instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDebugReportMessageEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
            case OP_vkDebugMarkerSetObjectTagEXT:
            {
                VkDevice device;
                const VkDebugMarkerObjectTagInfoEXT* pTagInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_667;
                vkReadStream->read((uint64_t*)&cgen_var_667, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_667, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pTagInfo, sizeof(const VkDebugMarkerObjectTagInfoEXT));
                unmarshal_VkDebugMarkerObjectTagInfoEXT(vkReadStream, (VkDebugMarkerObjectTagInfoEXT*)(pTagInfo));
                if (pTagInfo)
                {
                    transform_tohost_VkDebugMarkerObjectTagInfoEXT(m_state, (VkDebugMarkerObjectTagInfoEXT*)(pTagInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDebugMarkerSetObjectTagEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pTagInfo);
                }
                VkResult vkDebugMarkerSetObjectTagEXT_VkResult_return = (VkResult)0;
                vkDebugMarkerSetObjectTagEXT_VkResult_return = vk->vkDebugMarkerSetObjectTagEXT(unboxed_device, pTagInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDebugMarkerSetObjectTagEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDebugMarkerSetObjectTagEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkDebugMarkerSetObjectTagEXT_VkResult_return, device, pTagInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDebugMarkerSetObjectNameEXT:
            {
                VkDevice device;
                const VkDebugMarkerObjectNameInfoEXT* pNameInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_668;
                vkReadStream->read((uint64_t*)&cgen_var_668, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_668, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pNameInfo, sizeof(const VkDebugMarkerObjectNameInfoEXT));
                unmarshal_VkDebugMarkerObjectNameInfoEXT(vkReadStream, (VkDebugMarkerObjectNameInfoEXT*)(pNameInfo));
                if (pNameInfo)
                {
                    transform_tohost_VkDebugMarkerObjectNameInfoEXT(m_state, (VkDebugMarkerObjectNameInfoEXT*)(pNameInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDebugMarkerSetObjectNameEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pNameInfo);
                }
                VkResult vkDebugMarkerSetObjectNameEXT_VkResult_return = (VkResult)0;
                vkDebugMarkerSetObjectNameEXT_VkResult_return = vk->vkDebugMarkerSetObjectNameEXT(unboxed_device, pNameInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDebugMarkerSetObjectNameEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDebugMarkerSetObjectNameEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkDebugMarkerSetObjectNameEXT_VkResult_return, device, pNameInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdDebugMarkerBeginEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_669;
                vkReadStream->read((uint64_t*)&cgen_var_669, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_669, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pMarkerInfo, sizeof(const VkDebugMarkerMarkerInfoEXT));
                unmarshal_VkDebugMarkerMarkerInfoEXT(vkReadStream, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                if (pMarkerInfo)
                {
                    transform_tohost_VkDebugMarkerMarkerInfoEXT(m_state, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdDebugMarkerBeginEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pMarkerInfo);
                }
                vk->vkCmdDebugMarkerBeginEXT(unboxed_commandBuffer, pMarkerInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDebugMarkerBeginEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pMarkerInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdDebugMarkerEndEXT:
            {
                VkCommandBuffer commandBuffer;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_670;
                vkReadStream->read((uint64_t*)&cgen_var_670, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_670, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdDebugMarkerEndEXT 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                vk->vkCmdDebugMarkerEndEXT(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDebugMarkerEndEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdDebugMarkerInsertEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_671;
                vkReadStream->read((uint64_t*)&cgen_var_671, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_671, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pMarkerInfo, sizeof(const VkDebugMarkerMarkerInfoEXT));
                unmarshal_VkDebugMarkerMarkerInfoEXT(vkReadStream, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                if (pMarkerInfo)
                {
                    transform_tohost_VkDebugMarkerMarkerInfoEXT(m_state, (VkDebugMarkerMarkerInfoEXT*)(pMarkerInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdDebugMarkerInsertEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pMarkerInfo);
                }
                vk->vkCmdDebugMarkerInsertEXT(unboxed_commandBuffer, pMarkerInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDebugMarkerInsertEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pMarkerInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
#endif
#ifdef VK_AMD_draw_indirect_count
            case OP_vkCmdDrawIndirectCountAMD:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_672;
                vkReadStream->read((uint64_t*)&cgen_var_672, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_672, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_673;
                vkReadStream->read((uint64_t*)&cgen_var_673, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_673, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                uint64_t cgen_var_674;
                vkReadStream->read((uint64_t*)&cgen_var_674, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_674, (VkBuffer*)&countBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdDrawIndirectCountAMD 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)countBuffer, (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndirectCountAMD(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndirectCountAMD(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdDrawIndexedIndirectCountAMD:
            {
                VkCommandBuffer commandBuffer;
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_675;
                vkReadStream->read((uint64_t*)&cgen_var_675, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_675, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                uint64_t cgen_var_676;
                vkReadStream->read((uint64_t*)&cgen_var_676, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_676, (VkBuffer*)&buffer, 1);
                vkReadStream->read((VkDeviceSize*)&offset, sizeof(VkDeviceSize));
                uint64_t cgen_var_677;
                vkReadStream->read((uint64_t*)&cgen_var_677, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_677, (VkBuffer*)&countBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&countBufferOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&maxDrawCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&stride, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdDrawIndexedIndirectCountAMD 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)buffer, (unsigned long long)offset, (unsigned long long)countBuffer, (unsigned long long)countBufferOffset, (unsigned long long)maxDrawCount, (unsigned long long)stride);
                }
                vk->vkCmdDrawIndexedIndirectCountAMD(unboxed_commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdDrawIndexedIndirectCountAMD(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
#endif
#ifdef VK_AMD_shader_info
            case OP_vkGetShaderInfoAMD:
            {
                VkDevice device;
                VkPipeline pipeline;
                VkShaderStageFlagBits shaderStage;
                VkShaderInfoTypeAMD infoType;
                size_t* pInfoSize;
                void* pInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_678;
                vkReadStream->read((uint64_t*)&cgen_var_678, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_678, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_679;
                vkReadStream->read((uint64_t*)&cgen_var_679, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_679, (VkPipeline*)&pipeline, 1);
                vkReadStream->read((VkShaderStageFlagBits*)&shaderStage, sizeof(VkShaderStageFlagBits));
                vkReadStream->read((VkShaderInfoTypeAMD*)&infoType, sizeof(VkShaderInfoTypeAMD));
                // Begin manual dispatchable handle unboxing for pInfoSize;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pInfoSize = (size_t*)(uintptr_t)vkReadStream->getBe64();
                if (pInfoSize)
                {
                    vkReadStream->alloc((void**)&pInfoSize, sizeof(size_t));
                    (*pInfoSize) = (size_t)vkReadStream->getBe64();
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pInfoSize;
                // Begin manual dispatchable handle unboxing for pInfo;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pInfo = (void*)(uintptr_t)vkReadStream->getBe64();
                if (pInfo)
                {
                    vkReadStream->alloc((void**)&pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                    vkReadStream->read((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pInfo;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetShaderInfoAMD 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pipeline, (unsigned long long)shaderStage, (unsigned long long)infoType, (unsigned long long)pInfoSize, (unsigned long long)pInfo);
                }
                VkResult vkGetShaderInfoAMD_VkResult_return = (VkResult)0;
                vkGetShaderInfoAMD_VkResult_return = vk->vkGetShaderInfoAMD(unboxed_device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_683 = (uint64_t)(uintptr_t)pInfoSize;
                vkStream->putBe64(cgen_var_683);
                if (pInfoSize)
                {
                    uint64_t cgen_var_684 = (uint64_t)(*pInfoSize);
                    vkStream->putBe64(cgen_var_684);
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_685 = (uint64_t)(uintptr_t)pInfo;
                vkStream->putBe64(cgen_var_685);
                if (pInfo)
                {
                    vkStream->write((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetShaderInfoAMD_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetShaderInfoAMD(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetShaderInfoAMD_VkResult_return, device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
            case OP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV:
            {
                VkPhysicalDevice physicalDevice;
                VkFormat format;
                VkImageType type;
                VkImageTiling tiling;
                VkImageUsageFlags usage;
                VkImageCreateFlags flags;
                VkExternalMemoryHandleTypeFlagsNV externalHandleType;
                VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_686;
                vkReadStream->read((uint64_t*)&cgen_var_686, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_686, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((VkFormat*)&format, sizeof(VkFormat));
                vkReadStream->read((VkImageType*)&type, sizeof(VkImageType));
                vkReadStream->read((VkImageTiling*)&tiling, sizeof(VkImageTiling));
                vkReadStream->read((VkImageUsageFlags*)&usage, sizeof(VkImageUsageFlags));
                vkReadStream->read((VkImageCreateFlags*)&flags, sizeof(VkImageCreateFlags));
                vkReadStream->read((VkExternalMemoryHandleTypeFlagsNV*)&externalHandleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
                // Begin manual dispatchable handle unboxing for pExternalImageFormatProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pExternalImageFormatProperties, sizeof(VkExternalImageFormatPropertiesNV));
                unmarshal_VkExternalImageFormatPropertiesNV(vkReadStream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pExternalImageFormatProperties;
                if (pExternalImageFormatProperties)
                {
                    transform_tohost_VkExternalImageFormatPropertiesNV(m_state, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceExternalImageFormatPropertiesNV 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)format, (unsigned long long)type, (unsigned long long)tiling, (unsigned long long)usage, (unsigned long long)flags, (unsigned long long)externalHandleType, (unsigned long long)pExternalImageFormatProperties);
                }
                VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = vk->vkGetPhysicalDeviceExternalImageFormatPropertiesNV(unboxed_physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
                vkStream->unsetHandleMapping();
                if (pExternalImageFormatProperties)
                {
                    transform_fromhost_VkExternalImageFormatPropertiesNV(m_state, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                }
                marshal_VkExternalImageFormatPropertiesNV(vkStream, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
                vkStream->write(&vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceExternalImageFormatPropertiesNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_NV_external_memory
#endif
#ifdef VK_NV_external_memory_win32
            case OP_vkGetMemoryWin32HandleNV:
            {
                VkDevice device;
                VkDeviceMemory memory;
                VkExternalMemoryHandleTypeFlagsNV handleType;
                HANDLE* pHandle;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_687;
                vkReadStream->read((uint64_t*)&cgen_var_687, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_687, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_688;
                vkReadStream->read((uint64_t*)&cgen_var_688, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_688, (VkDeviceMemory*)&memory, 1);
                vkReadStream->read((VkExternalMemoryHandleTypeFlagsNV*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
                // Begin manual dispatchable handle unboxing for pHandle;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pHandle, sizeof(HANDLE));
                vkReadStream->read((HANDLE*)pHandle, sizeof(HANDLE));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pHandle;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetMemoryWin32HandleNV 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)handleType, (unsigned long long)pHandle);
                }
                VkResult vkGetMemoryWin32HandleNV_VkResult_return = (VkResult)0;
                vkGetMemoryWin32HandleNV_VkResult_return = vk->vkGetMemoryWin32HandleNV(unboxed_device, memory, handleType, pHandle);
                vkStream->unsetHandleMapping();
                vkStream->write((HANDLE*)pHandle, sizeof(HANDLE));
                vkStream->write(&vkGetMemoryWin32HandleNV_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryWin32HandleNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryWin32HandleNV_VkResult_return, device, memory, handleType, pHandle);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_NV_win32_keyed_mutex
#endif
#ifdef VK_EXT_validation_flags
#endif
#ifdef VK_NN_vi_surface
            case OP_vkCreateViSurfaceNN:
            {
                VkInstance instance;
                const VkViSurfaceCreateInfoNN* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_689;
                vkReadStream->read((uint64_t*)&cgen_var_689, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_689, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkViSurfaceCreateInfoNN));
                unmarshal_VkViSurfaceCreateInfoNN(vkReadStream, (VkViSurfaceCreateInfoNN*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_691;
                vkReadStream->read((uint64_t*)&cgen_var_691, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_691, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkViSurfaceCreateInfoNN(m_state, (VkViSurfaceCreateInfoNN*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateViSurfaceNN 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateViSurfaceNN_VkResult_return = (VkResult)0;
                vkCreateViSurfaceNN_VkResult_return = vk->vkCreateViSurfaceNN(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_692;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_692, 1);
                vkStream->write((uint64_t*)&cgen_var_692, 8);
                vkStream->write(&vkCreateViSurfaceNN_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateViSurfaceNN(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateViSurfaceNN_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
            case OP_vkCmdBeginConditionalRenderingEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_693;
                vkReadStream->read((uint64_t*)&cgen_var_693, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_693, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pConditionalRenderingBegin, sizeof(const VkConditionalRenderingBeginInfoEXT));
                unmarshal_VkConditionalRenderingBeginInfoEXT(vkReadStream, (VkConditionalRenderingBeginInfoEXT*)(pConditionalRenderingBegin));
                if (pConditionalRenderingBegin)
                {
                    transform_tohost_VkConditionalRenderingBeginInfoEXT(m_state, (VkConditionalRenderingBeginInfoEXT*)(pConditionalRenderingBegin));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdBeginConditionalRenderingEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pConditionalRenderingBegin);
                }
                vk->vkCmdBeginConditionalRenderingEXT(unboxed_commandBuffer, pConditionalRenderingBegin);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginConditionalRenderingEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pConditionalRenderingBegin);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdEndConditionalRenderingEXT:
            {
                VkCommandBuffer commandBuffer;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_694;
                vkReadStream->read((uint64_t*)&cgen_var_694, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_694, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdEndConditionalRenderingEXT 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                vk->vkCmdEndConditionalRenderingEXT(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndConditionalRenderingEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_NVX_device_generated_commands
            case OP_vkCmdProcessCommandsNVX:
            {
                VkCommandBuffer commandBuffer;
                const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_695;
                vkReadStream->read((uint64_t*)&cgen_var_695, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_695, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pProcessCommandsInfo, sizeof(const VkCmdProcessCommandsInfoNVX));
                unmarshal_VkCmdProcessCommandsInfoNVX(vkReadStream, (VkCmdProcessCommandsInfoNVX*)(pProcessCommandsInfo));
                if (pProcessCommandsInfo)
                {
                    transform_tohost_VkCmdProcessCommandsInfoNVX(m_state, (VkCmdProcessCommandsInfoNVX*)(pProcessCommandsInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdProcessCommandsNVX 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pProcessCommandsInfo);
                }
                vk->vkCmdProcessCommandsNVX(unboxed_commandBuffer, pProcessCommandsInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdProcessCommandsNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pProcessCommandsInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdReserveSpaceForCommandsNVX:
            {
                VkCommandBuffer commandBuffer;
                const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_696;
                vkReadStream->read((uint64_t*)&cgen_var_696, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_696, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pReserveSpaceInfo, sizeof(const VkCmdReserveSpaceForCommandsInfoNVX));
                unmarshal_VkCmdReserveSpaceForCommandsInfoNVX(vkReadStream, (VkCmdReserveSpaceForCommandsInfoNVX*)(pReserveSpaceInfo));
                if (pReserveSpaceInfo)
                {
                    transform_tohost_VkCmdReserveSpaceForCommandsInfoNVX(m_state, (VkCmdReserveSpaceForCommandsInfoNVX*)(pReserveSpaceInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdReserveSpaceForCommandsNVX 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pReserveSpaceInfo);
                }
                vk->vkCmdReserveSpaceForCommandsNVX(unboxed_commandBuffer, pReserveSpaceInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdReserveSpaceForCommandsNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pReserveSpaceInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateIndirectCommandsLayoutNVX:
            {
                VkDevice device;
                const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_697;
                vkReadStream->read((uint64_t*)&cgen_var_697, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_697, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkIndirectCommandsLayoutCreateInfoNVX));
                unmarshal_VkIndirectCommandsLayoutCreateInfoNVX(vkReadStream, (VkIndirectCommandsLayoutCreateInfoNVX*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pIndirectCommandsLayout;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pIndirectCommandsLayout, sizeof(VkIndirectCommandsLayoutNVX));
                uint64_t cgen_var_699;
                vkReadStream->read((uint64_t*)&cgen_var_699, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkIndirectCommandsLayoutNVX(&cgen_var_699, (VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pIndirectCommandsLayout;
                if (pCreateInfo)
                {
                    transform_tohost_VkIndirectCommandsLayoutCreateInfoNVX(m_state, (VkIndirectCommandsLayoutCreateInfoNVX*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateIndirectCommandsLayoutNVX 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pIndirectCommandsLayout);
                }
                VkResult vkCreateIndirectCommandsLayoutNVX_VkResult_return = (VkResult)0;
                vkCreateIndirectCommandsLayoutNVX_VkResult_return = vk->vkCreateIndirectCommandsLayoutNVX(unboxed_device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pIndirectCommandsLayout;
                if (vkCreateIndirectCommandsLayoutNVX_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_700;
                static_assert(8 == sizeof(VkIndirectCommandsLayoutNVX), "handle map overwrite requres VkIndirectCommandsLayoutNVX to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNVX((VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, 1);
                vkStream->write((VkIndirectCommandsLayoutNVX*)pIndirectCommandsLayout, 8 * 1);
                // Begin auto non dispatchable handle create for pIndirectCommandsLayout;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateIndirectCommandsLayoutNVX_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateIndirectCommandsLayoutNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateIndirectCommandsLayoutNVX_VkResult_return, device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyIndirectCommandsLayoutNVX:
            {
                VkDevice device;
                VkIndirectCommandsLayoutNVX indirectCommandsLayout;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_701;
                vkReadStream->read((uint64_t*)&cgen_var_701, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_701, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for indirectCommandsLayout;
                VkIndirectCommandsLayoutNVX* boxed_indirectCommandsLayout_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_indirectCommandsLayout_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_702;
                vkReadStream->read((uint64_t*)&cgen_var_702, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkIndirectCommandsLayoutNVX(&cgen_var_702, (VkIndirectCommandsLayoutNVX*)&indirectCommandsLayout, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for indirectCommandsLayout;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyIndirectCommandsLayoutNVX 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)indirectCommandsLayout, (unsigned long long)pAllocator);
                }
                vk->vkDestroyIndirectCommandsLayoutNVX(unboxed_device, indirectCommandsLayout, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyIndirectCommandsLayoutNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_indirectCommandsLayout_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateObjectTableNVX:
            {
                VkDevice device;
                const VkObjectTableCreateInfoNVX* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkObjectTableNVX* pObjectTable;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_704;
                vkReadStream->read((uint64_t*)&cgen_var_704, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_704, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkObjectTableCreateInfoNVX));
                unmarshal_VkObjectTableCreateInfoNVX(vkReadStream, (VkObjectTableCreateInfoNVX*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pObjectTable;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pObjectTable, sizeof(VkObjectTableNVX));
                uint64_t cgen_var_706;
                vkReadStream->read((uint64_t*)&cgen_var_706, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_706, (VkObjectTableNVX*)pObjectTable, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pObjectTable;
                if (pCreateInfo)
                {
                    transform_tohost_VkObjectTableCreateInfoNVX(m_state, (VkObjectTableCreateInfoNVX*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateObjectTableNVX 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pObjectTable);
                }
                VkResult vkCreateObjectTableNVX_VkResult_return = (VkResult)0;
                vkCreateObjectTableNVX_VkResult_return = vk->vkCreateObjectTableNVX(unboxed_device, pCreateInfo, pAllocator, pObjectTable);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pObjectTable;
                if (vkCreateObjectTableNVX_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_707;
                static_assert(8 == sizeof(VkObjectTableNVX), "handle map overwrite requres VkObjectTableNVX to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkObjectTableNVX((VkObjectTableNVX*)pObjectTable, 1);
                vkStream->write((VkObjectTableNVX*)pObjectTable, 8 * 1);
                // Begin auto non dispatchable handle create for pObjectTable;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateObjectTableNVX_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateObjectTableNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateObjectTableNVX_VkResult_return, device, pCreateInfo, pAllocator, pObjectTable);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyObjectTableNVX:
            {
                VkDevice device;
                VkObjectTableNVX objectTable;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_708;
                vkReadStream->read((uint64_t*)&cgen_var_708, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_708, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for objectTable;
                VkObjectTableNVX* boxed_objectTable_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_objectTable_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_709;
                vkReadStream->read((uint64_t*)&cgen_var_709, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_709, (VkObjectTableNVX*)&objectTable, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for objectTable;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyObjectTableNVX 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)objectTable, (unsigned long long)pAllocator);
                }
                vk->vkDestroyObjectTableNVX(unboxed_device, objectTable, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyObjectTableNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_objectTable_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkRegisterObjectsNVX:
            {
                VkDevice device;
                VkObjectTableNVX objectTable;
                uint32_t objectCount;
                const VkObjectTableEntryNVX* const* ppObjectTableEntries;
                const uint32_t* pObjectIndices;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_711;
                vkReadStream->read((uint64_t*)&cgen_var_711, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_711, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_712;
                vkReadStream->read((uint64_t*)&cgen_var_712, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_712, (VkObjectTableNVX*)&objectTable, 1);
                vkReadStream->read((uint32_t*)&objectCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                vkReadStream->read((uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                (void)ppObjectTableEntries;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkRegisterObjectsNVX 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)objectTable, (unsigned long long)objectCount, (unsigned long long)ppObjectTableEntries, (unsigned long long)pObjectIndices);
                }
                VkResult vkRegisterObjectsNVX_VkResult_return = (VkResult)0;
                vkRegisterObjectsNVX_VkResult_return = vk->vkRegisterObjectsNVX(unboxed_device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkRegisterObjectsNVX_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkRegisterObjectsNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkRegisterObjectsNVX_VkResult_return, device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkUnregisterObjectsNVX:
            {
                VkDevice device;
                VkObjectTableNVX objectTable;
                uint32_t objectCount;
                const VkObjectEntryTypeNVX* pObjectEntryTypes;
                const uint32_t* pObjectIndices;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_713;
                vkReadStream->read((uint64_t*)&cgen_var_713, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_713, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_714;
                vkReadStream->read((uint64_t*)&cgen_var_714, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_714, (VkObjectTableNVX*)&objectTable, 1);
                vkReadStream->read((uint32_t*)&objectCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
                vkReadStream->read((VkObjectEntryTypeNVX*)pObjectEntryTypes, ((objectCount)) * sizeof(const VkObjectEntryTypeNVX));
                vkReadStream->alloc((void**)&pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                vkReadStream->read((uint32_t*)pObjectIndices, ((objectCount)) * sizeof(const uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkUnregisterObjectsNVX 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)objectTable, (unsigned long long)objectCount, (unsigned long long)pObjectEntryTypes, (unsigned long long)pObjectIndices);
                }
                VkResult vkUnregisterObjectsNVX_VkResult_return = (VkResult)0;
                vkUnregisterObjectsNVX_VkResult_return = vk->vkUnregisterObjectsNVX(unboxed_device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkUnregisterObjectsNVX_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUnregisterObjectsNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkUnregisterObjectsNVX_VkResult_return, device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX:
            {
                VkPhysicalDevice physicalDevice;
                VkDeviceGeneratedCommandsFeaturesNVX* pFeatures;
                VkDeviceGeneratedCommandsLimitsNVX* pLimits;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_715;
                vkReadStream->read((uint64_t*)&cgen_var_715, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_715, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for pFeatures;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFeatures, sizeof(VkDeviceGeneratedCommandsFeaturesNVX));
                unmarshal_VkDeviceGeneratedCommandsFeaturesNVX(vkReadStream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFeatures;
                // Begin manual dispatchable handle unboxing for pLimits;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pLimits, sizeof(VkDeviceGeneratedCommandsLimitsNVX));
                unmarshal_VkDeviceGeneratedCommandsLimitsNVX(vkReadStream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pLimits;
                if (pFeatures)
                {
                    transform_tohost_VkDeviceGeneratedCommandsFeaturesNVX(m_state, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
                }
                if (pLimits)
                {
                    transform_tohost_VkDeviceGeneratedCommandsLimitsNVX(m_state, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)pFeatures, (unsigned long long)pLimits);
                }
                vk->vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(unboxed_physicalDevice, pFeatures, pLimits);
                vkStream->unsetHandleMapping();
                if (pFeatures)
                {
                    transform_fromhost_VkDeviceGeneratedCommandsFeaturesNVX(m_state, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
                }
                marshal_VkDeviceGeneratedCommandsFeaturesNVX(vkStream, (VkDeviceGeneratedCommandsFeaturesNVX*)(pFeatures));
                if (pLimits)
                {
                    transform_fromhost_VkDeviceGeneratedCommandsLimitsNVX(m_state, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
                }
                marshal_VkDeviceGeneratedCommandsLimitsNVX(vkStream, (VkDeviceGeneratedCommandsLimitsNVX*)(pLimits));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, pFeatures, pLimits);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_NV_clip_space_w_scaling
            case OP_vkCmdSetViewportWScalingNV:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstViewport;
                uint32_t viewportCount;
                const VkViewportWScalingNV* pViewportWScalings;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_716;
                vkReadStream->read((uint64_t*)&cgen_var_716, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_716, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&firstViewport, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&viewportCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pViewportWScalings, ((viewportCount)) * sizeof(const VkViewportWScalingNV));
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                {
                    unmarshal_VkViewportWScalingNV(vkReadStream, (VkViewportWScalingNV*)(pViewportWScalings + i));
                }
                if (pViewportWScalings)
                {
                    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
                    {
                        transform_tohost_VkViewportWScalingNV(m_state, (VkViewportWScalingNV*)(pViewportWScalings + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetViewportWScalingNV 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstViewport, (unsigned long long)viewportCount, (unsigned long long)pViewportWScalings);
                }
                vk->vkCmdSetViewportWScalingNV(unboxed_commandBuffer, firstViewport, viewportCount, pViewportWScalings);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetViewportWScalingNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstViewport, viewportCount, pViewportWScalings);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_EXT_direct_mode_display
            case OP_vkReleaseDisplayEXT:
            {
                VkPhysicalDevice physicalDevice;
                VkDisplayKHR display;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_717;
                vkReadStream->read((uint64_t*)&cgen_var_717, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_717, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_718;
                vkReadStream->read((uint64_t*)&cgen_var_718, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_718, (VkDisplayKHR*)&display, 1);
                if (m_logCalls)
                {
                    INFO("stream %p: call vkReleaseDisplayEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)display);
                }
                VkResult vkReleaseDisplayEXT_VkResult_return = (VkResult)0;
                vkReleaseDisplayEXT_VkResult_return = vk->vkReleaseDisplayEXT(unboxed_physicalDevice, display);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkReleaseDisplayEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkReleaseDisplayEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkReleaseDisplayEXT_VkResult_return, physicalDevice, display);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_EXT_acquire_xlib_display
            case OP_vkAcquireXlibDisplayEXT:
            {
                VkPhysicalDevice physicalDevice;
                Display* dpy;
                VkDisplayKHR display;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_719;
                vkReadStream->read((uint64_t*)&cgen_var_719, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_719, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for dpy;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                vkReadStream->read((Display*)dpy, sizeof(Display));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for dpy;
                uint64_t cgen_var_720;
                vkReadStream->read((uint64_t*)&cgen_var_720, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_720, (VkDisplayKHR*)&display, 1);
                if (m_logCalls)
                {
                    INFO("stream %p: call vkAcquireXlibDisplayEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)dpy, (unsigned long long)display);
                }
                VkResult vkAcquireXlibDisplayEXT_VkResult_return = (VkResult)0;
                vkAcquireXlibDisplayEXT_VkResult_return = vk->vkAcquireXlibDisplayEXT(unboxed_physicalDevice, dpy, display);
                vkStream->unsetHandleMapping();
                vkStream->write((Display*)dpy, sizeof(Display));
                vkStream->write(&vkAcquireXlibDisplayEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkAcquireXlibDisplayEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkAcquireXlibDisplayEXT_VkResult_return, physicalDevice, dpy, display);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetRandROutputDisplayEXT:
            {
                VkPhysicalDevice physicalDevice;
                Display* dpy;
                RROutput rrOutput;
                VkDisplayKHR* pDisplay;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_721;
                vkReadStream->read((uint64_t*)&cgen_var_721, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_721, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                // Begin manual dispatchable handle unboxing for dpy;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&dpy, sizeof(Display));
                vkReadStream->read((Display*)dpy, sizeof(Display));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for dpy;
                vkReadStream->read((RROutput*)&rrOutput, sizeof(RROutput));
                // Begin manual dispatchable handle unboxing for pDisplay;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDisplay, sizeof(VkDisplayKHR));
                uint64_t cgen_var_722;
                vkReadStream->read((uint64_t*)&cgen_var_722, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_722, (VkDisplayKHR*)pDisplay, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDisplay;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetRandROutputDisplayEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)dpy, (unsigned long long)rrOutput, (unsigned long long)pDisplay);
                }
                VkResult vkGetRandROutputDisplayEXT_VkResult_return = (VkResult)0;
                vkGetRandROutputDisplayEXT_VkResult_return = vk->vkGetRandROutputDisplayEXT(unboxed_physicalDevice, dpy, rrOutput, pDisplay);
                vkStream->unsetHandleMapping();
                vkStream->write((Display*)dpy, sizeof(Display));
                uint64_t cgen_var_723;
                vkStream->handleMapping()->mapHandles_VkDisplayKHR_u64(pDisplay, &cgen_var_723, 1);
                vkStream->write((uint64_t*)&cgen_var_723, 8);
                vkStream->write(&vkGetRandROutputDisplayEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetRandROutputDisplayEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetRandROutputDisplayEXT_VkResult_return, physicalDevice, dpy, rrOutput, pDisplay);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_EXT_display_surface_counter
            case OP_vkGetPhysicalDeviceSurfaceCapabilities2EXT:
            {
                VkPhysicalDevice physicalDevice;
                VkSurfaceKHR surface;
                VkSurfaceCapabilities2EXT* pSurfaceCapabilities;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_724;
                vkReadStream->read((uint64_t*)&cgen_var_724, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_724, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                uint64_t cgen_var_725;
                vkReadStream->read((uint64_t*)&cgen_var_725, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_725, (VkSurfaceKHR*)&surface, 1);
                // Begin manual dispatchable handle unboxing for pSurfaceCapabilities;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurfaceCapabilities, sizeof(VkSurfaceCapabilities2EXT));
                unmarshal_VkSurfaceCapabilities2EXT(vkReadStream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurfaceCapabilities;
                if (pSurfaceCapabilities)
                {
                    transform_tohost_VkSurfaceCapabilities2EXT(m_state, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceSurfaceCapabilities2EXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)surface, (unsigned long long)pSurfaceCapabilities);
                }
                VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = (VkResult)0;
                vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = vk->vkGetPhysicalDeviceSurfaceCapabilities2EXT(unboxed_physicalDevice, surface, pSurfaceCapabilities);
                vkStream->unsetHandleMapping();
                if (pSurfaceCapabilities)
                {
                    transform_fromhost_VkSurfaceCapabilities2EXT(m_state, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                }
                marshal_VkSurfaceCapabilities2EXT(vkStream, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
                vkStream->write(&vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceSurfaceCapabilities2EXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, physicalDevice, surface, pSurfaceCapabilities);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_EXT_display_control
            case OP_vkDisplayPowerControlEXT:
            {
                VkDevice device;
                VkDisplayKHR display;
                const VkDisplayPowerInfoEXT* pDisplayPowerInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_726;
                vkReadStream->read((uint64_t*)&cgen_var_726, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_726, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_727;
                vkReadStream->read((uint64_t*)&cgen_var_727, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_727, (VkDisplayKHR*)&display, 1);
                vkReadStream->alloc((void**)&pDisplayPowerInfo, sizeof(const VkDisplayPowerInfoEXT));
                unmarshal_VkDisplayPowerInfoEXT(vkReadStream, (VkDisplayPowerInfoEXT*)(pDisplayPowerInfo));
                if (pDisplayPowerInfo)
                {
                    transform_tohost_VkDisplayPowerInfoEXT(m_state, (VkDisplayPowerInfoEXT*)(pDisplayPowerInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDisplayPowerControlEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)display, (unsigned long long)pDisplayPowerInfo);
                }
                VkResult vkDisplayPowerControlEXT_VkResult_return = (VkResult)0;
                vkDisplayPowerControlEXT_VkResult_return = vk->vkDisplayPowerControlEXT(unboxed_device, display, pDisplayPowerInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkDisplayPowerControlEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDisplayPowerControlEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkDisplayPowerControlEXT_VkResult_return, device, display, pDisplayPowerInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkRegisterDeviceEventEXT:
            {
                VkDevice device;
                const VkDeviceEventInfoEXT* pDeviceEventInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_728;
                vkReadStream->read((uint64_t*)&cgen_var_728, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_728, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pDeviceEventInfo, sizeof(const VkDeviceEventInfoEXT));
                unmarshal_VkDeviceEventInfoEXT(vkReadStream, (VkDeviceEventInfoEXT*)(pDeviceEventInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pFence;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                uint64_t cgen_var_730;
                vkReadStream->read((uint64_t*)&cgen_var_730, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_730, (VkFence*)pFence, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFence;
                if (pDeviceEventInfo)
                {
                    transform_tohost_VkDeviceEventInfoEXT(m_state, (VkDeviceEventInfoEXT*)(pDeviceEventInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkRegisterDeviceEventEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pDeviceEventInfo, (unsigned long long)pAllocator, (unsigned long long)pFence);
                }
                VkResult vkRegisterDeviceEventEXT_VkResult_return = (VkResult)0;
                vkRegisterDeviceEventEXT_VkResult_return = vk->vkRegisterDeviceEventEXT(unboxed_device, pDeviceEventInfo, pAllocator, pFence);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_731;
                vkStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_731, 1);
                vkStream->write((uint64_t*)&cgen_var_731, 8);
                vkStream->write(&vkRegisterDeviceEventEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkRegisterDeviceEventEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkRegisterDeviceEventEXT_VkResult_return, device, pDeviceEventInfo, pAllocator, pFence);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkRegisterDisplayEventEXT:
            {
                VkDevice device;
                VkDisplayKHR display;
                const VkDisplayEventInfoEXT* pDisplayEventInfo;
                const VkAllocationCallbacks* pAllocator;
                VkFence* pFence;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_732;
                vkReadStream->read((uint64_t*)&cgen_var_732, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_732, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_733;
                vkReadStream->read((uint64_t*)&cgen_var_733, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_733, (VkDisplayKHR*)&display, 1);
                vkReadStream->alloc((void**)&pDisplayEventInfo, sizeof(const VkDisplayEventInfoEXT));
                unmarshal_VkDisplayEventInfoEXT(vkReadStream, (VkDisplayEventInfoEXT*)(pDisplayEventInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pFence;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pFence, sizeof(VkFence));
                uint64_t cgen_var_735;
                vkReadStream->read((uint64_t*)&cgen_var_735, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_735, (VkFence*)pFence, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pFence;
                if (pDisplayEventInfo)
                {
                    transform_tohost_VkDisplayEventInfoEXT(m_state, (VkDisplayEventInfoEXT*)(pDisplayEventInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkRegisterDisplayEventEXT 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)display, (unsigned long long)pDisplayEventInfo, (unsigned long long)pAllocator, (unsigned long long)pFence);
                }
                VkResult vkRegisterDisplayEventEXT_VkResult_return = (VkResult)0;
                vkRegisterDisplayEventEXT_VkResult_return = vk->vkRegisterDisplayEventEXT(unboxed_device, display, pDisplayEventInfo, pAllocator, pFence);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_736;
                vkStream->handleMapping()->mapHandles_VkFence_u64(pFence, &cgen_var_736, 1);
                vkStream->write((uint64_t*)&cgen_var_736, 8);
                vkStream->write(&vkRegisterDisplayEventEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkRegisterDisplayEventEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkRegisterDisplayEventEXT_VkResult_return, device, display, pDisplayEventInfo, pAllocator, pFence);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetSwapchainCounterEXT:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                VkSurfaceCounterFlagBitsEXT counter;
                uint64_t* pCounterValue;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_737;
                vkReadStream->read((uint64_t*)&cgen_var_737, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_737, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_738;
                vkReadStream->read((uint64_t*)&cgen_var_738, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_738, (VkSwapchainKHR*)&swapchain, 1);
                vkReadStream->read((VkSurfaceCounterFlagBitsEXT*)&counter, sizeof(VkSurfaceCounterFlagBitsEXT));
                // Begin manual dispatchable handle unboxing for pCounterValue;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pCounterValue, sizeof(uint64_t));
                vkReadStream->read((uint64_t*)pCounterValue, sizeof(uint64_t));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCounterValue;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetSwapchainCounterEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)counter, (unsigned long long)pCounterValue);
                }
                VkResult vkGetSwapchainCounterEXT_VkResult_return = (VkResult)0;
                vkGetSwapchainCounterEXT_VkResult_return = vk->vkGetSwapchainCounterEXT(unboxed_device, swapchain, counter, pCounterValue);
                vkStream->unsetHandleMapping();
                vkStream->write((uint64_t*)pCounterValue, sizeof(uint64_t));
                vkStream->write(&vkGetSwapchainCounterEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetSwapchainCounterEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetSwapchainCounterEXT_VkResult_return, device, swapchain, counter, pCounterValue);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_GOOGLE_display_timing
            case OP_vkGetRefreshCycleDurationGOOGLE:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_739;
                vkReadStream->read((uint64_t*)&cgen_var_739, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_739, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_740;
                vkReadStream->read((uint64_t*)&cgen_var_740, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_740, (VkSwapchainKHR*)&swapchain, 1);
                // Begin manual dispatchable handle unboxing for pDisplayTimingProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pDisplayTimingProperties, sizeof(VkRefreshCycleDurationGOOGLE));
                unmarshal_VkRefreshCycleDurationGOOGLE(vkReadStream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDisplayTimingProperties;
                if (pDisplayTimingProperties)
                {
                    transform_tohost_VkRefreshCycleDurationGOOGLE(m_state, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetRefreshCycleDurationGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)pDisplayTimingProperties);
                }
                VkResult vkGetRefreshCycleDurationGOOGLE_VkResult_return = (VkResult)0;
                vkGetRefreshCycleDurationGOOGLE_VkResult_return = vk->vkGetRefreshCycleDurationGOOGLE(unboxed_device, swapchain, pDisplayTimingProperties);
                vkStream->unsetHandleMapping();
                if (pDisplayTimingProperties)
                {
                    transform_fromhost_VkRefreshCycleDurationGOOGLE(m_state, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                }
                marshal_VkRefreshCycleDurationGOOGLE(vkStream, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
                vkStream->write(&vkGetRefreshCycleDurationGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetRefreshCycleDurationGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetRefreshCycleDurationGOOGLE_VkResult_return, device, swapchain, pDisplayTimingProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPastPresentationTimingGOOGLE:
            {
                VkDevice device;
                VkSwapchainKHR swapchain;
                uint32_t* pPresentationTimingCount;
                VkPastPresentationTimingGOOGLE* pPresentationTimings;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_741;
                vkReadStream->read((uint64_t*)&cgen_var_741, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_741, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_742;
                vkReadStream->read((uint64_t*)&cgen_var_742, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_742, (VkSwapchainKHR*)&swapchain, 1);
                // Begin manual dispatchable handle unboxing for pPresentationTimingCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPresentationTimingCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pPresentationTimingCount)
                {
                    vkReadStream->alloc((void**)&pPresentationTimingCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPresentationTimingCount;
                // Begin manual dispatchable handle unboxing for pPresentationTimings;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pPresentationTimings = (VkPastPresentationTimingGOOGLE*)(uintptr_t)vkReadStream->getBe64();
                if (pPresentationTimings)
                {
                    vkReadStream->alloc((void**)&pPresentationTimings, (*(pPresentationTimingCount)) * sizeof(VkPastPresentationTimingGOOGLE));
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        unmarshal_VkPastPresentationTimingGOOGLE(vkReadStream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pPresentationTimings;
                if (pPresentationTimings)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        transform_tohost_VkPastPresentationTimingGOOGLE(m_state, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPastPresentationTimingGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchain, (unsigned long long)pPresentationTimingCount, (unsigned long long)pPresentationTimings);
                }
                VkResult vkGetPastPresentationTimingGOOGLE_VkResult_return = (VkResult)0;
                vkGetPastPresentationTimingGOOGLE_VkResult_return = vk->vkGetPastPresentationTimingGOOGLE(unboxed_device, swapchain, pPresentationTimingCount, pPresentationTimings);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_745 = (uint64_t)(uintptr_t)pPresentationTimingCount;
                vkStream->putBe64(cgen_var_745);
                if (pPresentationTimingCount)
                {
                    vkStream->write((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
                }
                if (pPresentationTimings)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        transform_fromhost_VkPastPresentationTimingGOOGLE(m_state, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_746 = (uint64_t)(uintptr_t)pPresentationTimings;
                vkStream->putBe64(cgen_var_746);
                if (pPresentationTimings)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                    {
                        marshal_VkPastPresentationTimingGOOGLE(vkStream, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
                    }
                }
                vkStream->write(&vkGetPastPresentationTimingGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPastPresentationTimingGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetPastPresentationTimingGOOGLE_VkResult_return, device, swapchain, pPresentationTimingCount, pPresentationTimings);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
#endif
#ifdef VK_NV_viewport_swizzle
#endif
#ifdef VK_EXT_discard_rectangles
            case OP_vkCmdSetDiscardRectangleEXT:
            {
                VkCommandBuffer commandBuffer;
                uint32_t firstDiscardRectangle;
                uint32_t discardRectangleCount;
                const VkRect2D* pDiscardRectangles;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_747;
                vkReadStream->read((uint64_t*)&cgen_var_747, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_747, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&firstDiscardRectangle, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&discardRectangleCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pDiscardRectangles, ((discardRectangleCount)) * sizeof(const VkRect2D));
                for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
                {
                    unmarshal_VkRect2D(vkReadStream, (VkRect2D*)(pDiscardRectangles + i));
                }
                if (pDiscardRectangles)
                {
                    for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
                    {
                        transform_tohost_VkRect2D(m_state, (VkRect2D*)(pDiscardRectangles + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetDiscardRectangleEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)firstDiscardRectangle, (unsigned long long)discardRectangleCount, (unsigned long long)pDiscardRectangles);
                }
                vk->vkCmdSetDiscardRectangleEXT(unboxed_commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetDiscardRectangleEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_EXT_conservative_rasterization
#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
            case OP_vkSetHdrMetadataEXT:
            {
                VkDevice device;
                uint32_t swapchainCount;
                const VkSwapchainKHR* pSwapchains;
                const VkHdrMetadataEXT* pMetadata;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_748;
                vkReadStream->read((uint64_t*)&cgen_var_748, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_748, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((uint32_t*)&swapchainCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSwapchains, ((swapchainCount)) * sizeof(const VkSwapchainKHR));
                if (((swapchainCount)))
                {
                    uint64_t* cgen_var_749;
                    vkReadStream->alloc((void**)&cgen_var_749, ((swapchainCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_749, ((swapchainCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(cgen_var_749, (VkSwapchainKHR*)pSwapchains, ((swapchainCount)));
                }
                vkReadStream->alloc((void**)&pMetadata, ((swapchainCount)) * sizeof(const VkHdrMetadataEXT));
                for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                {
                    unmarshal_VkHdrMetadataEXT(vkReadStream, (VkHdrMetadataEXT*)(pMetadata + i));
                }
                if (pMetadata)
                {
                    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
                    {
                        transform_tohost_VkHdrMetadataEXT(m_state, (VkHdrMetadataEXT*)(pMetadata + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkSetHdrMetadataEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)swapchainCount, (unsigned long long)pSwapchains, (unsigned long long)pMetadata);
                }
                vk->vkSetHdrMetadataEXT(unboxed_device, swapchainCount, pSwapchains, pMetadata);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetHdrMetadataEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, swapchainCount, pSwapchains, pMetadata);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_MVK_ios_surface
            case OP_vkCreateIOSSurfaceMVK:
            {
                VkInstance instance;
                const VkIOSSurfaceCreateInfoMVK* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_750;
                vkReadStream->read((uint64_t*)&cgen_var_750, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_750, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkIOSSurfaceCreateInfoMVK));
                unmarshal_VkIOSSurfaceCreateInfoMVK(vkReadStream, (VkIOSSurfaceCreateInfoMVK*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_752;
                vkReadStream->read((uint64_t*)&cgen_var_752, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_752, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkIOSSurfaceCreateInfoMVK(m_state, (VkIOSSurfaceCreateInfoMVK*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateIOSSurfaceMVK 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateIOSSurfaceMVK_VkResult_return = (VkResult)0;
                vkCreateIOSSurfaceMVK_VkResult_return = vk->vkCreateIOSSurfaceMVK(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_753;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_753, 1);
                vkStream->write((uint64_t*)&cgen_var_753, 8);
                vkStream->write(&vkCreateIOSSurfaceMVK_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateIOSSurfaceMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateIOSSurfaceMVK_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_MVK_macos_surface
            case OP_vkCreateMacOSSurfaceMVK:
            {
                VkInstance instance;
                const VkMacOSSurfaceCreateInfoMVK* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkSurfaceKHR* pSurface;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_754;
                vkReadStream->read((uint64_t*)&cgen_var_754, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_754, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkMacOSSurfaceCreateInfoMVK));
                unmarshal_VkMacOSSurfaceCreateInfoMVK(vkReadStream, (VkMacOSSurfaceCreateInfoMVK*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pSurface;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pSurface, sizeof(VkSurfaceKHR));
                uint64_t cgen_var_756;
                vkReadStream->read((uint64_t*)&cgen_var_756, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_756, (VkSurfaceKHR*)pSurface, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSurface;
                if (pCreateInfo)
                {
                    transform_tohost_VkMacOSSurfaceCreateInfoMVK(m_state, (VkMacOSSurfaceCreateInfoMVK*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateMacOSSurfaceMVK 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pSurface);
                }
                VkResult vkCreateMacOSSurfaceMVK_VkResult_return = (VkResult)0;
                vkCreateMacOSSurfaceMVK_VkResult_return = vk->vkCreateMacOSSurfaceMVK(unboxed_instance, pCreateInfo, pAllocator, pSurface);
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_757;
                vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(pSurface, &cgen_var_757, 1);
                vkStream->write((uint64_t*)&cgen_var_757, 8);
                vkStream->write(&vkCreateMacOSSurfaceMVK_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateMacOSSurfaceMVK(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateMacOSSurfaceMVK_VkResult_return, instance, pCreateInfo, pAllocator, pSurface);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
            case OP_vkSetDebugUtilsObjectNameEXT:
            {
                VkDevice device;
                const VkDebugUtilsObjectNameInfoEXT* pNameInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_758;
                vkReadStream->read((uint64_t*)&cgen_var_758, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_758, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pNameInfo, sizeof(const VkDebugUtilsObjectNameInfoEXT));
                unmarshal_VkDebugUtilsObjectNameInfoEXT(vkReadStream, (VkDebugUtilsObjectNameInfoEXT*)(pNameInfo));
                if (pNameInfo)
                {
                    transform_tohost_VkDebugUtilsObjectNameInfoEXT(m_state, (VkDebugUtilsObjectNameInfoEXT*)(pNameInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkSetDebugUtilsObjectNameEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pNameInfo);
                }
                VkResult vkSetDebugUtilsObjectNameEXT_VkResult_return = (VkResult)0;
                vkSetDebugUtilsObjectNameEXT_VkResult_return = vk->vkSetDebugUtilsObjectNameEXT(unboxed_device, pNameInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkSetDebugUtilsObjectNameEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetDebugUtilsObjectNameEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkSetDebugUtilsObjectNameEXT_VkResult_return, device, pNameInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkSetDebugUtilsObjectTagEXT:
            {
                VkDevice device;
                const VkDebugUtilsObjectTagInfoEXT* pTagInfo;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_759;
                vkReadStream->read((uint64_t*)&cgen_var_759, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_759, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pTagInfo, sizeof(const VkDebugUtilsObjectTagInfoEXT));
                unmarshal_VkDebugUtilsObjectTagInfoEXT(vkReadStream, (VkDebugUtilsObjectTagInfoEXT*)(pTagInfo));
                if (pTagInfo)
                {
                    transform_tohost_VkDebugUtilsObjectTagInfoEXT(m_state, (VkDebugUtilsObjectTagInfoEXT*)(pTagInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkSetDebugUtilsObjectTagEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pTagInfo);
                }
                VkResult vkSetDebugUtilsObjectTagEXT_VkResult_return = (VkResult)0;
                vkSetDebugUtilsObjectTagEXT_VkResult_return = vk->vkSetDebugUtilsObjectTagEXT(unboxed_device, pTagInfo);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkSetDebugUtilsObjectTagEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSetDebugUtilsObjectTagEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkSetDebugUtilsObjectTagEXT_VkResult_return, device, pTagInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkQueueBeginDebugUtilsLabelEXT:
            {
                VkQueue queue;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_760;
                vkReadStream->read((uint64_t*)&cgen_var_760, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_760, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkQueueBeginDebugUtilsLabelEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)pLabelInfo);
                }
                vk->vkQueueBeginDebugUtilsLabelEXT(unboxed_queue, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueBeginDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, pLabelInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkQueueEndDebugUtilsLabelEXT:
            {
                VkQueue queue;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_761;
                vkReadStream->read((uint64_t*)&cgen_var_761, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_761, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkQueueEndDebugUtilsLabelEXT 0x%llx \n", ioStream, (unsigned long long)queue);
                }
                vk->vkQueueEndDebugUtilsLabelEXT(unboxed_queue);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueEndDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkQueueInsertDebugUtilsLabelEXT:
            {
                VkQueue queue;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_762;
                vkReadStream->read((uint64_t*)&cgen_var_762, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_762, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkQueueInsertDebugUtilsLabelEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)pLabelInfo);
                }
                vk->vkQueueInsertDebugUtilsLabelEXT(unboxed_queue, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkQueueInsertDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, pLabelInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdBeginDebugUtilsLabelEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_763;
                vkReadStream->read((uint64_t*)&cgen_var_763, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_763, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdBeginDebugUtilsLabelEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pLabelInfo);
                }
                vk->vkCmdBeginDebugUtilsLabelEXT(unboxed_commandBuffer, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdBeginDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pLabelInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdEndDebugUtilsLabelEXT:
            {
                VkCommandBuffer commandBuffer;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_764;
                vkReadStream->read((uint64_t*)&cgen_var_764, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_764, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdEndDebugUtilsLabelEXT 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                vk->vkCmdEndDebugUtilsLabelEXT(unboxed_commandBuffer);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdEndDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCmdInsertDebugUtilsLabelEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkDebugUtilsLabelEXT* pLabelInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_765;
                vkReadStream->read((uint64_t*)&cgen_var_765, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_765, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pLabelInfo, sizeof(const VkDebugUtilsLabelEXT));
                unmarshal_VkDebugUtilsLabelEXT(vkReadStream, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                if (pLabelInfo)
                {
                    transform_tohost_VkDebugUtilsLabelEXT(m_state, (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdInsertDebugUtilsLabelEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pLabelInfo);
                }
                vk->vkCmdInsertDebugUtilsLabelEXT(unboxed_commandBuffer, pLabelInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdInsertDebugUtilsLabelEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pLabelInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateDebugUtilsMessengerEXT:
            {
                VkInstance instance;
                const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkDebugUtilsMessengerEXT* pMessenger;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_766;
                vkReadStream->read((uint64_t*)&cgen_var_766, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_766, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkDebugUtilsMessengerCreateInfoEXT));
                unmarshal_VkDebugUtilsMessengerCreateInfoEXT(vkReadStream, (VkDebugUtilsMessengerCreateInfoEXT*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pMessenger;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMessenger, sizeof(VkDebugUtilsMessengerEXT));
                uint64_t cgen_var_768;
                vkReadStream->read((uint64_t*)&cgen_var_768, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDebugUtilsMessengerEXT(&cgen_var_768, (VkDebugUtilsMessengerEXT*)pMessenger, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMessenger;
                if (pCreateInfo)
                {
                    transform_tohost_VkDebugUtilsMessengerCreateInfoEXT(m_state, (VkDebugUtilsMessengerCreateInfoEXT*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateDebugUtilsMessengerEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pMessenger);
                }
                VkResult vkCreateDebugUtilsMessengerEXT_VkResult_return = (VkResult)0;
                vkCreateDebugUtilsMessengerEXT_VkResult_return = vk->vkCreateDebugUtilsMessengerEXT(unboxed_instance, pCreateInfo, pAllocator, pMessenger);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pMessenger;
                if (vkCreateDebugUtilsMessengerEXT_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_769;
                static_assert(8 == sizeof(VkDebugUtilsMessengerEXT), "handle map overwrite requres VkDebugUtilsMessengerEXT to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkDebugUtilsMessengerEXT((VkDebugUtilsMessengerEXT*)pMessenger, 1);
                vkStream->write((VkDebugUtilsMessengerEXT*)pMessenger, 8 * 1);
                // Begin auto non dispatchable handle create for pMessenger;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateDebugUtilsMessengerEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateDebugUtilsMessengerEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateDebugUtilsMessengerEXT_VkResult_return, instance, pCreateInfo, pAllocator, pMessenger);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyDebugUtilsMessengerEXT:
            {
                VkInstance instance;
                VkDebugUtilsMessengerEXT messenger;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_770;
                vkReadStream->read((uint64_t*)&cgen_var_770, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_770, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                // Begin manual non dispatchable handle destroy unboxing for messenger;
                VkDebugUtilsMessengerEXT* boxed_messenger_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_messenger_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_771;
                vkReadStream->read((uint64_t*)&cgen_var_771, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDebugUtilsMessengerEXT(&cgen_var_771, (VkDebugUtilsMessengerEXT*)&messenger, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for messenger;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyDebugUtilsMessengerEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)messenger, (unsigned long long)pAllocator);
                }
                vk->vkDestroyDebugUtilsMessengerEXT(unboxed_instance, messenger, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyDebugUtilsMessengerEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, *boxed_messenger_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkSubmitDebugUtilsMessageEXT:
            {
                VkInstance instance;
                VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity;
                VkDebugUtilsMessageTypeFlagsEXT messageTypes;
                const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData;
                // Begin manual dispatchable handle unboxing for instance;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_773;
                vkReadStream->read((uint64_t*)&cgen_var_773, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_773, (VkInstance*)&instance, 1);
                auto unboxed_instance = unbox_VkInstance(instance);
                auto vk = dispatch_VkInstance(instance);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for instance;
                vkReadStream->read((VkDebugUtilsMessageSeverityFlagBitsEXT*)&messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
                vkReadStream->read((VkDebugUtilsMessageTypeFlagsEXT*)&messageTypes, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
                vkReadStream->alloc((void**)&pCallbackData, sizeof(const VkDebugUtilsMessengerCallbackDataEXT));
                unmarshal_VkDebugUtilsMessengerCallbackDataEXT(vkReadStream, (VkDebugUtilsMessengerCallbackDataEXT*)(pCallbackData));
                if (pCallbackData)
                {
                    transform_tohost_VkDebugUtilsMessengerCallbackDataEXT(m_state, (VkDebugUtilsMessengerCallbackDataEXT*)(pCallbackData));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkSubmitDebugUtilsMessageEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)instance, (unsigned long long)messageSeverity, (unsigned long long)messageTypes, (unsigned long long)pCallbackData);
                }
                vk->vkSubmitDebugUtilsMessageEXT(unboxed_instance, messageSeverity, messageTypes, pCallbackData);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkSubmitDebugUtilsMessageEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, instance, messageSeverity, messageTypes, pCallbackData);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
            case OP_vkGetAndroidHardwareBufferPropertiesANDROID:
            {
                VkDevice device;
                const AHardwareBuffer* buffer;
                VkAndroidHardwareBufferPropertiesANDROID* pProperties;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_774;
                vkReadStream->read((uint64_t*)&cgen_var_774, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_774, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&buffer, sizeof(const AHardwareBuffer));
                vkReadStream->read((AHardwareBuffer*)buffer, sizeof(const AHardwareBuffer));
                // Begin manual dispatchable handle unboxing for pProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pProperties, sizeof(VkAndroidHardwareBufferPropertiesANDROID));
                unmarshal_VkAndroidHardwareBufferPropertiesANDROID(vkReadStream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pProperties;
                if (pProperties)
                {
                    transform_tohost_VkAndroidHardwareBufferPropertiesANDROID(m_state, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetAndroidHardwareBufferPropertiesANDROID 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buffer, (unsigned long long)pProperties);
                }
                VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
                vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = vk->vkGetAndroidHardwareBufferPropertiesANDROID(unboxed_device, buffer, pProperties);
                vkStream->unsetHandleMapping();
                if (pProperties)
                {
                    transform_fromhost_VkAndroidHardwareBufferPropertiesANDROID(m_state, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                }
                marshal_VkAndroidHardwareBufferPropertiesANDROID(vkStream, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
                vkStream->write(&vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetAndroidHardwareBufferPropertiesANDROID(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, device, buffer, pProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetMemoryAndroidHardwareBufferANDROID:
            {
                VkDevice device;
                const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo;
                AHardwareBuffer** pBuffer;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_775;
                vkReadStream->read((uint64_t*)&cgen_var_775, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_775, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pInfo, sizeof(const VkMemoryGetAndroidHardwareBufferInfoANDROID));
                unmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(vkReadStream, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(pInfo));
                // Begin manual dispatchable handle unboxing for pBuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pBuffer, sizeof(AHardwareBuffer*));
                vkReadStream->read((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pBuffer;
                if (pInfo)
                {
                    transform_tohost_VkMemoryGetAndroidHardwareBufferInfoANDROID(m_state, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(pInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetMemoryAndroidHardwareBufferANDROID 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pInfo, (unsigned long long)pBuffer);
                }
                VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
                vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = vk->vkGetMemoryAndroidHardwareBufferANDROID(unboxed_device, pInfo, pBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
                vkStream->write(&vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryAndroidHardwareBufferANDROID(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, device, pInfo, pBuffer);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
            case OP_vkCmdSetSampleLocationsEXT:
            {
                VkCommandBuffer commandBuffer;
                const VkSampleLocationsInfoEXT* pSampleLocationsInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_776;
                vkReadStream->read((uint64_t*)&cgen_var_776, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_776, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pSampleLocationsInfo, sizeof(const VkSampleLocationsInfoEXT));
                unmarshal_VkSampleLocationsInfoEXT(vkReadStream, (VkSampleLocationsInfoEXT*)(pSampleLocationsInfo));
                if (pSampleLocationsInfo)
                {
                    transform_tohost_VkSampleLocationsInfoEXT(m_state, (VkSampleLocationsInfoEXT*)(pSampleLocationsInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetSampleLocationsEXT 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pSampleLocationsInfo);
                }
                vk->vkCmdSetSampleLocationsEXT(unboxed_commandBuffer, pSampleLocationsInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetSampleLocationsEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pSampleLocationsInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetPhysicalDeviceMultisamplePropertiesEXT:
            {
                VkPhysicalDevice physicalDevice;
                VkSampleCountFlagBits samples;
                VkMultisamplePropertiesEXT* pMultisampleProperties;
                // Begin manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_777;
                vkReadStream->read((uint64_t*)&cgen_var_777, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(&cgen_var_777, (VkPhysicalDevice*)&physicalDevice, 1);
                auto unboxed_physicalDevice = unbox_VkPhysicalDevice(physicalDevice);
                auto vk = dispatch_VkPhysicalDevice(physicalDevice);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for physicalDevice;
                vkReadStream->read((VkSampleCountFlagBits*)&samples, sizeof(VkSampleCountFlagBits));
                // Begin manual dispatchable handle unboxing for pMultisampleProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMultisampleProperties, sizeof(VkMultisamplePropertiesEXT));
                unmarshal_VkMultisamplePropertiesEXT(vkReadStream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMultisampleProperties;
                if (pMultisampleProperties)
                {
                    transform_tohost_VkMultisamplePropertiesEXT(m_state, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetPhysicalDeviceMultisamplePropertiesEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)physicalDevice, (unsigned long long)samples, (unsigned long long)pMultisampleProperties);
                }
                vk->vkGetPhysicalDeviceMultisamplePropertiesEXT(unboxed_physicalDevice, samples, pMultisampleProperties);
                vkStream->unsetHandleMapping();
                if (pMultisampleProperties)
                {
                    transform_fromhost_VkMultisamplePropertiesEXT(m_state, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                }
                marshal_VkMultisamplePropertiesEXT(vkStream, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetPhysicalDeviceMultisamplePropertiesEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, physicalDevice, samples, pMultisampleProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_EXT_blend_operation_advanced
#endif
#ifdef VK_NV_fragment_coverage_to_color
#endif
#ifdef VK_NV_framebuffer_mixed_samples
#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
            case OP_vkCreateValidationCacheEXT:
            {
                VkDevice device;
                const VkValidationCacheCreateInfoEXT* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkValidationCacheEXT* pValidationCache;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_778;
                vkReadStream->read((uint64_t*)&cgen_var_778, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_778, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkValidationCacheCreateInfoEXT));
                unmarshal_VkValidationCacheCreateInfoEXT(vkReadStream, (VkValidationCacheCreateInfoEXT*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pValidationCache;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pValidationCache, sizeof(VkValidationCacheEXT));
                uint64_t cgen_var_780;
                vkReadStream->read((uint64_t*)&cgen_var_780, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_780, (VkValidationCacheEXT*)pValidationCache, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pValidationCache;
                if (pCreateInfo)
                {
                    transform_tohost_VkValidationCacheCreateInfoEXT(m_state, (VkValidationCacheCreateInfoEXT*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateValidationCacheEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pValidationCache);
                }
                VkResult vkCreateValidationCacheEXT_VkResult_return = (VkResult)0;
                vkCreateValidationCacheEXT_VkResult_return = vk->vkCreateValidationCacheEXT(unboxed_device, pCreateInfo, pAllocator, pValidationCache);
                vkStream->unsetHandleMapping();
                // Begin auto non dispatchable handle create for pValidationCache;
                if (vkCreateValidationCacheEXT_VkResult_return == VK_SUCCESS) vkStream->setHandleMapping(&m_boxedHandleCreateMapping);
                uint64_t cgen_var_781;
                static_assert(8 == sizeof(VkValidationCacheEXT), "handle map overwrite requres VkValidationCacheEXT to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkValidationCacheEXT((VkValidationCacheEXT*)pValidationCache, 1);
                vkStream->write((VkValidationCacheEXT*)pValidationCache, 8 * 1);
                // Begin auto non dispatchable handle create for pValidationCache;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                vkStream->write(&vkCreateValidationCacheEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateValidationCacheEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateValidationCacheEXT_VkResult_return, device, pCreateInfo, pAllocator, pValidationCache);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkDestroyValidationCacheEXT:
            {
                VkDevice device;
                VkValidationCacheEXT validationCache;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_782;
                vkReadStream->read((uint64_t*)&cgen_var_782, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_782, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for validationCache;
                VkValidationCacheEXT* boxed_validationCache_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_validationCache_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_783;
                vkReadStream->read((uint64_t*)&cgen_var_783, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_783, (VkValidationCacheEXT*)&validationCache, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for validationCache;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkDestroyValidationCacheEXT 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)validationCache, (unsigned long long)pAllocator);
                }
                vk->vkDestroyValidationCacheEXT(unboxed_device, validationCache, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkDestroyValidationCacheEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, *boxed_validationCache_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkMergeValidationCachesEXT:
            {
                VkDevice device;
                VkValidationCacheEXT dstCache;
                uint32_t srcCacheCount;
                const VkValidationCacheEXT* pSrcCaches;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_785;
                vkReadStream->read((uint64_t*)&cgen_var_785, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_785, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_786;
                vkReadStream->read((uint64_t*)&cgen_var_786, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_786, (VkValidationCacheEXT*)&dstCache, 1);
                vkReadStream->read((uint32_t*)&srcCacheCount, sizeof(uint32_t));
                vkReadStream->alloc((void**)&pSrcCaches, ((srcCacheCount)) * sizeof(const VkValidationCacheEXT));
                if (((srcCacheCount)))
                {
                    uint64_t* cgen_var_787;
                    vkReadStream->alloc((void**)&cgen_var_787, ((srcCacheCount)) * 8);
                    vkReadStream->read((uint64_t*)cgen_var_787, ((srcCacheCount)) * 8);
                    vkReadStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(cgen_var_787, (VkValidationCacheEXT*)pSrcCaches, ((srcCacheCount)));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkMergeValidationCachesEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)dstCache, (unsigned long long)srcCacheCount, (unsigned long long)pSrcCaches);
                }
                VkResult vkMergeValidationCachesEXT_VkResult_return = (VkResult)0;
                vkMergeValidationCachesEXT_VkResult_return = vk->vkMergeValidationCachesEXT(unboxed_device, dstCache, srcCacheCount, pSrcCaches);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkMergeValidationCachesEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkMergeValidationCachesEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkMergeValidationCachesEXT_VkResult_return, device, dstCache, srcCacheCount, pSrcCaches);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetValidationCacheDataEXT:
            {
                VkDevice device;
                VkValidationCacheEXT validationCache;
                size_t* pDataSize;
                void* pData;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_788;
                vkReadStream->read((uint64_t*)&cgen_var_788, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_788, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_789;
                vkReadStream->read((uint64_t*)&cgen_var_789, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_789, (VkValidationCacheEXT*)&validationCache, 1);
                // Begin manual dispatchable handle unboxing for pDataSize;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pDataSize = (size_t*)(uintptr_t)vkReadStream->getBe64();
                if (pDataSize)
                {
                    vkReadStream->alloc((void**)&pDataSize, sizeof(size_t));
                    (*pDataSize) = (size_t)vkReadStream->getBe64();
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pDataSize;
                // Begin manual dispatchable handle unboxing for pData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pData = (void*)(uintptr_t)vkReadStream->getBe64();
                if (pData)
                {
                    vkReadStream->alloc((void**)&pData, (*(pDataSize)) * sizeof(uint8_t));
                    vkReadStream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pData;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetValidationCacheDataEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)validationCache, (unsigned long long)pDataSize, (unsigned long long)pData);
                }
                VkResult vkGetValidationCacheDataEXT_VkResult_return = (VkResult)0;
                vkGetValidationCacheDataEXT_VkResult_return = vk->vkGetValidationCacheDataEXT(unboxed_device, validationCache, pDataSize, pData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_793 = (uint64_t)(uintptr_t)pDataSize;
                vkStream->putBe64(cgen_var_793);
                if (pDataSize)
                {
                    uint64_t cgen_var_794 = (uint64_t)(*pDataSize);
                    vkStream->putBe64(cgen_var_794);
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_795 = (uint64_t)(uintptr_t)pData;
                vkStream->putBe64(cgen_var_795);
                if (pData)
                {
                    vkStream->write((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
                }
                vkStream->write(&vkGetValidationCacheDataEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetValidationCacheDataEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetValidationCacheDataEXT_VkResult_return, device, validationCache, pDataSize, pData);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
#endif
#ifdef VK_EXT_external_memory_host
            case OP_vkGetMemoryHostPointerPropertiesEXT:
            {
                VkDevice device;
                VkExternalMemoryHandleTypeFlagBits handleType;
                const void* pHostPointer;
                VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_796;
                vkReadStream->read((uint64_t*)&cgen_var_796, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_796, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->read((VkExternalMemoryHandleTypeFlagBits*)&handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
                // WARNING PTR CHECK
                pHostPointer = (const void*)(uintptr_t)vkReadStream->getBe64();
                if (pHostPointer)
                {
                    vkReadStream->alloc((void**)&pHostPointer, sizeof(const uint8_t));
                    vkReadStream->read((void*)pHostPointer, sizeof(const uint8_t));
                }
                // Begin manual dispatchable handle unboxing for pMemoryHostPointerProperties;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryHostPointerProperties, sizeof(VkMemoryHostPointerPropertiesEXT));
                unmarshal_VkMemoryHostPointerPropertiesEXT(vkReadStream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryHostPointerProperties;
                if (pMemoryHostPointerProperties)
                {
                    transform_tohost_VkMemoryHostPointerPropertiesEXT(m_state, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetMemoryHostPointerPropertiesEXT 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)handleType, (unsigned long long)pHostPointer, (unsigned long long)pMemoryHostPointerProperties);
                }
                VkResult vkGetMemoryHostPointerPropertiesEXT_VkResult_return = (VkResult)0;
                vkGetMemoryHostPointerPropertiesEXT_VkResult_return = vk->vkGetMemoryHostPointerPropertiesEXT(unboxed_device, handleType, pHostPointer, pMemoryHostPointerProperties);
                vkStream->unsetHandleMapping();
                if (pMemoryHostPointerProperties)
                {
                    transform_fromhost_VkMemoryHostPointerPropertiesEXT(m_state, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                }
                marshal_VkMemoryHostPointerPropertiesEXT(vkStream, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
                vkStream->write(&vkGetMemoryHostPointerPropertiesEXT_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryHostPointerPropertiesEXT(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryHostPointerPropertiesEXT_VkResult_return, device, handleType, pHostPointer, pMemoryHostPointerProperties);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_AMD_buffer_marker
            case OP_vkCmdWriteBufferMarkerAMD:
            {
                VkCommandBuffer commandBuffer;
                VkPipelineStageFlagBits pipelineStage;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                uint32_t marker;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_798;
                vkReadStream->read((uint64_t*)&cgen_var_798, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_798, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkPipelineStageFlagBits*)&pipelineStage, sizeof(VkPipelineStageFlagBits));
                uint64_t cgen_var_799;
                vkReadStream->read((uint64_t*)&cgen_var_799, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_799, (VkBuffer*)&dstBuffer, 1);
                vkReadStream->read((VkDeviceSize*)&dstOffset, sizeof(VkDeviceSize));
                vkReadStream->read((uint32_t*)&marker, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdWriteBufferMarkerAMD 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pipelineStage, (unsigned long long)dstBuffer, (unsigned long long)dstOffset, (unsigned long long)marker);
                }
                vk->vkCmdWriteBufferMarkerAMD(unboxed_commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdWriteBufferMarkerAMD(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_AMD_shader_core_properties
#endif
#ifdef VK_EXT_vertex_attribute_divisor
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
            case OP_vkCmdSetCheckpointNV:
            {
                VkCommandBuffer commandBuffer;
                const void* pCheckpointMarker;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_800;
                vkReadStream->read((uint64_t*)&cgen_var_800, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_800, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                // WARNING PTR CHECK
                pCheckpointMarker = (const void*)(uintptr_t)vkReadStream->getBe64();
                if (pCheckpointMarker)
                {
                    vkReadStream->alloc((void**)&pCheckpointMarker, sizeof(const uint8_t));
                    vkReadStream->read((void*)pCheckpointMarker, sizeof(const uint8_t));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCmdSetCheckpointNV 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pCheckpointMarker);
                }
                vk->vkCmdSetCheckpointNV(unboxed_commandBuffer, pCheckpointMarker);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCmdSetCheckpointNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pCheckpointMarker);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkGetQueueCheckpointDataNV:
            {
                VkQueue queue;
                uint32_t* pCheckpointDataCount;
                VkCheckpointDataNV* pCheckpointData;
                // Begin manual dispatchable handle unboxing for queue;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_802;
                vkReadStream->read((uint64_t*)&cgen_var_802, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_802, (VkQueue*)&queue, 1);
                auto unboxed_queue = unbox_VkQueue(queue);
                auto vk = dispatch_VkQueue(queue);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for queue;
                // Begin manual dispatchable handle unboxing for pCheckpointDataCount;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pCheckpointDataCount = (uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pCheckpointDataCount)
                {
                    vkReadStream->alloc((void**)&pCheckpointDataCount, sizeof(uint32_t));
                    vkReadStream->read((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCheckpointDataCount;
                // Begin manual dispatchable handle unboxing for pCheckpointData;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pCheckpointData = (VkCheckpointDataNV*)(uintptr_t)vkReadStream->getBe64();
                if (pCheckpointData)
                {
                    vkReadStream->alloc((void**)&pCheckpointData, (*(pCheckpointDataCount)) * sizeof(VkCheckpointDataNV));
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        unmarshal_VkCheckpointDataNV(vkReadStream, (VkCheckpointDataNV*)(pCheckpointData + i));
                    }
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pCheckpointData;
                if (pCheckpointData)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        transform_tohost_VkCheckpointDataNV(m_state, (VkCheckpointDataNV*)(pCheckpointData + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetQueueCheckpointDataNV 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)queue, (unsigned long long)pCheckpointDataCount, (unsigned long long)pCheckpointData);
                }
                vk->vkGetQueueCheckpointDataNV(unboxed_queue, pCheckpointDataCount, pCheckpointData);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_805 = (uint64_t)(uintptr_t)pCheckpointDataCount;
                vkStream->putBe64(cgen_var_805);
                if (pCheckpointDataCount)
                {
                    vkStream->write((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
                }
                if (pCheckpointData)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        transform_fromhost_VkCheckpointDataNV(m_state, (VkCheckpointDataNV*)(pCheckpointData + i));
                    }
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_806 = (uint64_t)(uintptr_t)pCheckpointData;
                vkStream->putBe64(cgen_var_806);
                if (pCheckpointData)
                {
                    for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                    {
                        marshal_VkCheckpointDataNV(vkStream, (VkCheckpointDataNV*)(pCheckpointData + i));
                    }
                }
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetQueueCheckpointDataNV(snapshotTraceBegin, snapshotTraceBytes, &m_pool, queue, pCheckpointDataCount, pCheckpointData);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_GOOGLE_address_space
            case OP_vkMapMemoryIntoAddressSpaceGOOGLE:
            {
                VkDevice device;
                VkDeviceMemory memory;
                uint64_t* pAddress;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_807;
                vkReadStream->read((uint64_t*)&cgen_var_807, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_807, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_808;
                vkReadStream->read((uint64_t*)&cgen_var_808, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_808, (VkDeviceMemory*)&memory, 1);
                // Begin manual dispatchable handle unboxing for pAddress;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pAddress = (uint64_t*)(uintptr_t)vkReadStream->getBe64();
                if (pAddress)
                {
                    vkReadStream->alloc((void**)&pAddress, sizeof(uint64_t));
                    vkReadStream->read((uint64_t*)pAddress, sizeof(uint64_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pAddress;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkMapMemoryIntoAddressSpaceGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)pAddress);
                }
                VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = (VkResult)0;
                vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = m_state->on_vkMapMemoryIntoAddressSpaceGOOGLE(&m_pool, device, memory, pAddress);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_810 = (uint64_t)(uintptr_t)pAddress;
                vkStream->putBe64(cgen_var_810);
                if (pAddress)
                {
                    vkStream->write((uint64_t*)pAddress, sizeof(uint64_t));
                }
                vkStream->write(&vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkMapMemoryIntoAddressSpaceGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, device, memory, pAddress);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_GOOGLE_color_buffer
            case OP_vkRegisterImageColorBufferGOOGLE:
            {
                VkDevice device;
                VkImage image;
                uint32_t colorBuffer;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_811;
                vkReadStream->read((uint64_t*)&cgen_var_811, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_811, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_812;
                vkReadStream->read((uint64_t*)&cgen_var_812, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_812, (VkImage*)&image, 1);
                vkReadStream->read((uint32_t*)&colorBuffer, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkRegisterImageColorBufferGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)image, (unsigned long long)colorBuffer);
                }
                VkResult vkRegisterImageColorBufferGOOGLE_VkResult_return = (VkResult)0;
                vkRegisterImageColorBufferGOOGLE_VkResult_return = m_state->on_vkRegisterImageColorBufferGOOGLE(&m_pool, device, image, colorBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkRegisterImageColorBufferGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkRegisterImageColorBufferGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkRegisterImageColorBufferGOOGLE_VkResult_return, device, image, colorBuffer);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkRegisterBufferColorBufferGOOGLE:
            {
                VkDevice device;
                VkBuffer buffer;
                uint32_t colorBuffer;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_813;
                vkReadStream->read((uint64_t*)&cgen_var_813, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_813, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_814;
                vkReadStream->read((uint64_t*)&cgen_var_814, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_814, (VkBuffer*)&buffer, 1);
                vkReadStream->read((uint32_t*)&colorBuffer, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkRegisterBufferColorBufferGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)buffer, (unsigned long long)colorBuffer);
                }
                VkResult vkRegisterBufferColorBufferGOOGLE_VkResult_return = (VkResult)0;
                vkRegisterBufferColorBufferGOOGLE_VkResult_return = m_state->on_vkRegisterBufferColorBufferGOOGLE(&m_pool, device, buffer, colorBuffer);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkRegisterBufferColorBufferGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkRegisterBufferColorBufferGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkRegisterBufferColorBufferGOOGLE_VkResult_return, device, buffer, colorBuffer);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_GOOGLE_sized_descriptor_update_template
            case OP_vkUpdateDescriptorSetWithTemplateSizedGOOGLE:
            {
                VkDevice device;
                VkDescriptorSet descriptorSet;
                VkDescriptorUpdateTemplate descriptorUpdateTemplate;
                uint32_t imageInfoCount;
                uint32_t bufferInfoCount;
                uint32_t bufferViewCount;
                const uint32_t* pImageInfoEntryIndices;
                const uint32_t* pBufferInfoEntryIndices;
                const uint32_t* pBufferViewEntryIndices;
                const VkDescriptorImageInfo* pImageInfos;
                const VkDescriptorBufferInfo* pBufferInfos;
                const VkBufferView* pBufferViews;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_815;
                vkReadStream->read((uint64_t*)&cgen_var_815, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_815, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_816;
                vkReadStream->read((uint64_t*)&cgen_var_816, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorSet(&cgen_var_816, (VkDescriptorSet*)&descriptorSet, 1);
                uint64_t cgen_var_817;
                vkReadStream->read((uint64_t*)&cgen_var_817, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_817, (VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate, 1);
                vkReadStream->read((uint32_t*)&imageInfoCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&bufferInfoCount, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&bufferViewCount, sizeof(uint32_t));
                // WARNING PTR CHECK
                pImageInfoEntryIndices = (const uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pImageInfoEntryIndices)
                {
                    vkReadStream->alloc((void**)&pImageInfoEntryIndices, ((imageInfoCount)) * sizeof(const uint32_t));
                    vkReadStream->read((uint32_t*)pImageInfoEntryIndices, ((imageInfoCount)) * sizeof(const uint32_t));
                }
                // WARNING PTR CHECK
                pBufferInfoEntryIndices = (const uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pBufferInfoEntryIndices)
                {
                    vkReadStream->alloc((void**)&pBufferInfoEntryIndices, ((bufferInfoCount)) * sizeof(const uint32_t));
                    vkReadStream->read((uint32_t*)pBufferInfoEntryIndices, ((bufferInfoCount)) * sizeof(const uint32_t));
                }
                // WARNING PTR CHECK
                pBufferViewEntryIndices = (const uint32_t*)(uintptr_t)vkReadStream->getBe64();
                if (pBufferViewEntryIndices)
                {
                    vkReadStream->alloc((void**)&pBufferViewEntryIndices, ((bufferViewCount)) * sizeof(const uint32_t));
                    vkReadStream->read((uint32_t*)pBufferViewEntryIndices, ((bufferViewCount)) * sizeof(const uint32_t));
                }
                // WARNING PTR CHECK
                pImageInfos = (const VkDescriptorImageInfo*)(uintptr_t)vkReadStream->getBe64();
                if (pImageInfos)
                {
                    vkReadStream->alloc((void**)&pImageInfos, ((imageInfoCount)) * sizeof(const VkDescriptorImageInfo));
                    for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
                    {
                        unmarshal_VkDescriptorImageInfo(vkReadStream, (VkDescriptorImageInfo*)(pImageInfos + i));
                    }
                }
                // WARNING PTR CHECK
                pBufferInfos = (const VkDescriptorBufferInfo*)(uintptr_t)vkReadStream->getBe64();
                if (pBufferInfos)
                {
                    vkReadStream->alloc((void**)&pBufferInfos, ((bufferInfoCount)) * sizeof(const VkDescriptorBufferInfo));
                    for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
                    {
                        unmarshal_VkDescriptorBufferInfo(vkReadStream, (VkDescriptorBufferInfo*)(pBufferInfos + i));
                    }
                }
                // WARNING PTR CHECK
                pBufferViews = (const VkBufferView*)(uintptr_t)vkReadStream->getBe64();
                if (pBufferViews)
                {
                    vkReadStream->alloc((void**)&pBufferViews, ((bufferViewCount)) * sizeof(const VkBufferView));
                    if (((bufferViewCount)))
                    {
                        uint64_t* cgen_var_824;
                        vkReadStream->alloc((void**)&cgen_var_824, ((bufferViewCount)) * 8);
                        vkReadStream->read((uint64_t*)cgen_var_824, ((bufferViewCount)) * 8);
                        vkReadStream->handleMapping()->mapHandles_u64_VkBufferView(cgen_var_824, (VkBufferView*)pBufferViews, ((bufferViewCount)));
                    }
                }
                if (pImageInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
                    {
                        transform_tohost_VkDescriptorImageInfo(m_state, (VkDescriptorImageInfo*)(pImageInfos + i));
                    }
                }
                if (pBufferInfos)
                {
                    for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
                    {
                        transform_tohost_VkDescriptorBufferInfo(m_state, (VkDescriptorBufferInfo*)(pBufferInfos + i));
                    }
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkUpdateDescriptorSetWithTemplateSizedGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)descriptorSet, (unsigned long long)descriptorUpdateTemplate, (unsigned long long)imageInfoCount, (unsigned long long)bufferInfoCount, (unsigned long long)bufferViewCount, (unsigned long long)pImageInfoEntryIndices, (unsigned long long)pBufferInfoEntryIndices, (unsigned long long)pBufferViewEntryIndices, (unsigned long long)pImageInfos, (unsigned long long)pBufferInfos, (unsigned long long)pBufferViews);
                }
                m_state->on_vkUpdateDescriptorSetWithTemplateSizedGOOGLE(&m_pool, device, descriptorSet, descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount, pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkUpdateDescriptorSetWithTemplateSizedGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, device, descriptorSet, descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount, pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_GOOGLE_async_command_buffers
            case OP_vkBeginCommandBufferAsyncGOOGLE:
            {
                VkCommandBuffer commandBuffer;
                const VkCommandBufferBeginInfo* pBeginInfo;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_825;
                vkReadStream->read((uint64_t*)&cgen_var_825, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_825, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->alloc((void**)&pBeginInfo, sizeof(const VkCommandBufferBeginInfo));
                unmarshal_VkCommandBufferBeginInfo(vkReadStream, (VkCommandBufferBeginInfo*)(pBeginInfo));
                if (pBeginInfo)
                {
                    transform_tohost_VkCommandBufferBeginInfo(m_state, (VkCommandBufferBeginInfo*)(pBeginInfo));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkBeginCommandBufferAsyncGOOGLE 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)pBeginInfo);
                }
                m_state->on_vkBeginCommandBufferAsyncGOOGLE(&m_pool, commandBuffer, pBeginInfo);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkBeginCommandBufferAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, pBeginInfo);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkEndCommandBufferAsyncGOOGLE:
            {
                VkCommandBuffer commandBuffer;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_826;
                vkReadStream->read((uint64_t*)&cgen_var_826, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_826, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkEndCommandBufferAsyncGOOGLE 0x%llx \n", ioStream, (unsigned long long)commandBuffer);
                }
                m_state->on_vkEndCommandBufferAsyncGOOGLE(&m_pool, commandBuffer);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkEndCommandBufferAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkResetCommandBufferAsyncGOOGLE:
            {
                VkCommandBuffer commandBuffer;
                VkCommandBufferResetFlags flags;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_827;
                vkReadStream->read((uint64_t*)&cgen_var_827, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_827, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((VkCommandBufferResetFlags*)&flags, sizeof(VkCommandBufferResetFlags));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkResetCommandBufferAsyncGOOGLE 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)flags);
                }
                m_state->on_vkResetCommandBufferAsyncGOOGLE(&m_pool, commandBuffer, flags);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkResetCommandBufferAsyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, flags);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCommandBufferHostSyncGOOGLE:
            {
                VkCommandBuffer commandBuffer;
                uint32_t needHostSync;
                uint32_t sequenceNumber;
                // Begin manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_828;
                vkReadStream->read((uint64_t*)&cgen_var_828, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_828, (VkCommandBuffer*)&commandBuffer, 1);
                auto unboxed_commandBuffer = unbox_VkCommandBuffer(commandBuffer);
                auto vk = dispatch_VkCommandBuffer(commandBuffer);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for commandBuffer;
                vkReadStream->read((uint32_t*)&needHostSync, sizeof(uint32_t));
                vkReadStream->read((uint32_t*)&sequenceNumber, sizeof(uint32_t));
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCommandBufferHostSyncGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)commandBuffer, (unsigned long long)needHostSync, (unsigned long long)sequenceNumber);
                }
                m_state->on_vkCommandBufferHostSyncGOOGLE(&m_pool, commandBuffer, needHostSync, sequenceNumber);
                vkStream->unsetHandleMapping();
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCommandBufferHostSyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, commandBuffer, needHostSync, sequenceNumber);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_GOOGLE_create_resources_with_requirements
            case OP_vkCreateImageWithRequirementsGOOGLE:
            {
                VkDevice device;
                const VkImageCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkImage* pImage;
                VkMemoryRequirements* pMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_829;
                vkReadStream->read((uint64_t*)&cgen_var_829, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_829, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkImageCreateInfo));
                unmarshal_VkImageCreateInfo(vkReadStream, (VkImageCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pImage;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pImage, sizeof(VkImage));
                uint64_t cgen_var_831;
                vkReadStream->read((uint64_t*)&cgen_var_831, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_831, (VkImage*)pImage, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pImage;
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                unmarshal_VkMemoryRequirements(vkReadStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryRequirements;
                if (pCreateInfo)
                {
                    transform_tohost_VkImageCreateInfo(m_state, (VkImageCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateImageWithRequirementsGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pImage, (unsigned long long)pMemoryRequirements);
                }
                VkResult vkCreateImageWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
                vkCreateImageWithRequirementsGOOGLE_VkResult_return = m_state->on_vkCreateImageWithRequirementsGOOGLE(&m_pool, device, pCreateInfo, pAllocator, pImage, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pImage;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_832;
                static_assert(8 == sizeof(VkImage), "handle map overwrite requres VkImage to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkImage((VkImage*)pImage, 1);
                vkStream->write((VkImage*)pImage, 8 * 1);
                // Begin manual non dispatchable handle create for pImage;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkStream->write(&vkCreateImageWithRequirementsGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateImageWithRequirementsGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateImageWithRequirementsGOOGLE_VkResult_return, device, pCreateInfo, pAllocator, pImage, pMemoryRequirements);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
            case OP_vkCreateBufferWithRequirementsGOOGLE:
            {
                VkDevice device;
                const VkBufferCreateInfo* pCreateInfo;
                const VkAllocationCallbacks* pAllocator;
                VkBuffer* pBuffer;
                VkMemoryRequirements* pMemoryRequirements;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_833;
                vkReadStream->read((uint64_t*)&cgen_var_833, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_833, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                vkReadStream->alloc((void**)&pCreateInfo, sizeof(const VkBufferCreateInfo));
                unmarshal_VkBufferCreateInfo(vkReadStream, (VkBufferCreateInfo*)(pCreateInfo));
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                // Begin manual dispatchable handle unboxing for pBuffer;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pBuffer, sizeof(VkBuffer));
                uint64_t cgen_var_835;
                vkReadStream->read((uint64_t*)&cgen_var_835, 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_835, (VkBuffer*)pBuffer, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pBuffer;
                // Begin manual dispatchable handle unboxing for pMemoryRequirements;
                vkReadStream->unsetHandleMapping();
                vkReadStream->alloc((void**)&pMemoryRequirements, sizeof(VkMemoryRequirements));
                unmarshal_VkMemoryRequirements(vkReadStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pMemoryRequirements;
                if (pCreateInfo)
                {
                    transform_tohost_VkBufferCreateInfo(m_state, (VkBufferCreateInfo*)(pCreateInfo));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pMemoryRequirements)
                {
                    transform_tohost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkCreateBufferWithRequirementsGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)pCreateInfo, (unsigned long long)pAllocator, (unsigned long long)pBuffer, (unsigned long long)pMemoryRequirements);
                }
                VkResult vkCreateBufferWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
                vkCreateBufferWithRequirementsGOOGLE_VkResult_return = m_state->on_vkCreateBufferWithRequirementsGOOGLE(&m_pool, device, pCreateInfo, pAllocator, pBuffer, pMemoryRequirements);
                vkStream->unsetHandleMapping();
                // Begin manual non dispatchable handle create for pBuffer;
                vkStream->unsetHandleMapping();
                uint64_t cgen_var_836;
                static_assert(8 == sizeof(VkBuffer), "handle map overwrite requres VkBuffer to be 8 bytes long");
                vkStream->handleMapping()->mapHandles_VkBuffer((VkBuffer*)pBuffer, 1);
                vkStream->write((VkBuffer*)pBuffer, 8 * 1);
                // Begin manual non dispatchable handle create for pBuffer;
                vkStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                if (pMemoryRequirements)
                {
                    transform_fromhost_VkMemoryRequirements(m_state, (VkMemoryRequirements*)(pMemoryRequirements));
                }
                marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(pMemoryRequirements));
                vkStream->write(&vkCreateBufferWithRequirementsGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkCreateBufferWithRequirementsGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkCreateBufferWithRequirementsGOOGLE_VkResult_return, device, pCreateInfo, pAllocator, pBuffer, pMemoryRequirements);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_GOOGLE_address_space_info
            case OP_vkGetMemoryHostAddressInfoGOOGLE:
            {
                VkDevice device;
                VkDeviceMemory memory;
                uint64_t* pAddress;
                uint64_t* pSize;
                uint64_t* pHostmemId;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_837;
                vkReadStream->read((uint64_t*)&cgen_var_837, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_837, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                uint64_t cgen_var_838;
                vkReadStream->read((uint64_t*)&cgen_var_838, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_838, (VkDeviceMemory*)&memory, 1);
                // Begin manual dispatchable handle unboxing for pAddress;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pAddress = (uint64_t*)(uintptr_t)vkReadStream->getBe64();
                if (pAddress)
                {
                    vkReadStream->alloc((void**)&pAddress, sizeof(uint64_t));
                    vkReadStream->read((uint64_t*)pAddress, sizeof(uint64_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pAddress;
                // Begin manual dispatchable handle unboxing for pSize;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pSize = (uint64_t*)(uintptr_t)vkReadStream->getBe64();
                if (pSize)
                {
                    vkReadStream->alloc((void**)&pSize, sizeof(uint64_t));
                    vkReadStream->read((uint64_t*)pSize, sizeof(uint64_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pSize;
                // Begin manual dispatchable handle unboxing for pHostmemId;
                vkReadStream->unsetHandleMapping();
                // WARNING PTR CHECK
                pHostmemId = (uint64_t*)(uintptr_t)vkReadStream->getBe64();
                if (pHostmemId)
                {
                    vkReadStream->alloc((void**)&pHostmemId, sizeof(uint64_t));
                    vkReadStream->read((uint64_t*)pHostmemId, sizeof(uint64_t));
                }
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for pHostmemId;
                if (m_logCalls)
                {
                    INFO("stream %p: call vkGetMemoryHostAddressInfoGOOGLE 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)pAddress, (unsigned long long)pSize, (unsigned long long)pHostmemId);
                }
                VkResult vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = (VkResult)0;
                vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = m_state->on_vkGetMemoryHostAddressInfoGOOGLE(&m_pool, device, memory, pAddress, pSize, pHostmemId);
                vkStream->unsetHandleMapping();
                // WARNING PTR CHECK
                uint64_t cgen_var_842 = (uint64_t)(uintptr_t)pAddress;
                vkStream->putBe64(cgen_var_842);
                if (pAddress)
                {
                    vkStream->write((uint64_t*)pAddress, sizeof(uint64_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_843 = (uint64_t)(uintptr_t)pSize;
                vkStream->putBe64(cgen_var_843);
                if (pSize)
                {
                    vkStream->write((uint64_t*)pSize, sizeof(uint64_t));
                }
                // WARNING PTR CHECK
                uint64_t cgen_var_844 = (uint64_t)(uintptr_t)pHostmemId;
                vkStream->putBe64(cgen_var_844);
                if (pHostmemId)
                {
                    vkStream->write((uint64_t*)pHostmemId, sizeof(uint64_t));
                }
                vkStream->write(&vkGetMemoryHostAddressInfoGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkGetMemoryHostAddressInfoGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkGetMemoryHostAddressInfoGOOGLE_VkResult_return, device, memory, pAddress, pSize, pHostmemId);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
#ifdef VK_GOOGLE_free_memory_sync
            case OP_vkFreeMemorySyncGOOGLE:
            {
                VkDevice device;
                VkDeviceMemory memory;
                const VkAllocationCallbacks* pAllocator;
                // Begin manual dispatchable handle unboxing for device;
                vkReadStream->unsetHandleMapping();
                uint64_t cgen_var_845;
                vkReadStream->read((uint64_t*)&cgen_var_845, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_845, (VkDevice*)&device, 1);
                auto unboxed_device = unbox_VkDevice(device);
                auto vk = dispatch_VkDevice(device);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual dispatchable handle unboxing for device;
                // Begin manual non dispatchable handle destroy unboxing for memory;
                VkDeviceMemory* boxed_memory_preserve;
                m_boxedHandleUnwrapAndDeletePreserveBoxedMapping.setup(&m_pool, (uint64_t**)&boxed_memory_preserve);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapAndDeletePreserveBoxedMapping);
                uint64_t cgen_var_846;
                vkReadStream->read((uint64_t*)&cgen_var_846, 1 * 8);
                vkReadStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_846, (VkDeviceMemory*)&memory, 1);
                vkReadStream->setHandleMapping(&m_boxedHandleUnwrapMapping);
                // End manual non dispatchable handle destroy unboxing for memory;
                // WARNING PTR CHECK
                pAllocator = (const VkAllocationCallbacks*)(uintptr_t)vkReadStream->getBe64();
                if (pAllocator)
                {
                    vkReadStream->alloc((void**)&pAllocator, sizeof(const VkAllocationCallbacks));
                    unmarshal_VkAllocationCallbacks(vkReadStream, (VkAllocationCallbacks*)(pAllocator));
                }
                if (pAllocator)
                {
                    transform_tohost_VkAllocationCallbacks(m_state, (VkAllocationCallbacks*)(pAllocator));
                }
                if (m_logCalls)
                {
                    INFO("stream %p: call vkFreeMemorySyncGOOGLE 0x%llx 0x%llx 0x%llx \n", ioStream, (unsigned long long)device, (unsigned long long)memory, (unsigned long long)pAllocator);
                }
                VkResult vkFreeMemorySyncGOOGLE_VkResult_return = (VkResult)0;
                vkFreeMemorySyncGOOGLE_VkResult_return = m_state->on_vkFreeMemorySyncGOOGLE(&m_pool, device, memory, pAllocator);
                vkStream->unsetHandleMapping();
                vkStream->write(&vkFreeMemorySyncGOOGLE_VkResult_return, sizeof(VkResult));
                vkStream->commitWrite();
                size_t snapshotTraceBytes = vkReadStream->endTrace();
                if (m_state->snapshotsEnabled())
                {
                    m_state->snapshot()->vkFreeMemorySyncGOOGLE(snapshotTraceBegin, snapshotTraceBytes, &m_pool, vkFreeMemorySyncGOOGLE_VkResult_return, device, *boxed_memory_preserve, pAllocator);
                }
                m_pool.freeAll();
                vkReadStream->clearPool();
                break;
            }
#endif
            default:
            {
                return ptr - (unsigned char *)buf;
            }
        }
        ptr += packetLen;
    }
    if (m_forSnapshotLoad)
    {
        m_state->clearCreatedHandlesForSnapshotLoad();
    }
    return ptr - (unsigned char*)buf;;
}


